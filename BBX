--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║          ANNOMALY X - Bad Business Module v2.2             ║
    ║                                                           ║
    ║  FIXES v2.2:                                              ║
    ║  - Fixed freeze on load (deferred heavy scans)            ║
    ║  - Added task.wait() between getgc iterations             ║
    ║  - Reduced scan frequency and batch sizes                 ║
    ║  - Fixed pcall/return bugs                                ║
    ║  - Safe AC bypass (no .Connect hooks)                     ║
    ║                                                           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getconnections = getconnections
local getgc = getgc
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Workspace = cloneref(game:GetService("Workspace"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- BB INTERNAL REFERENCES
-- ============================================
local BB_Framework = nil
local BB_EntityTable = nil
local BB_FireFunction = nil
local BB_FireHooked = false
local BB_ShootingRemotes = {}

-- ============================================
-- PHASE 1: SAFE AC BYPASS (lightweight, no freeze)
-- ============================================
local HookedFunctions = {}

local function ApplyBBACBypass()
    local results = {kick = false, errors = 0, memory = 0}

    -- Kick protection
    pcall(function()
        local oldKick = LocalPlayer.Kick
        if typeof(oldKick) == "function" then
            hookfunction(oldKick, newcclosure(function(self, ...)
                if self == LocalPlayer then return end
                return oldKick(self, ...)
            end))
            results.kick = true
        end
    end)

    -- Error suppression (SAFE: only Disable, NO .Connect hook)
    pcall(function()
        if not getconnections then return end
        local SC = cloneref(game:GetService("ScriptContext"))
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function()
                conn:Disable()
                results.errors = results.errors + 1
            end)
        end
    end)

    return results
end

local acResults = ApplyBBACBypass()

-- Lightweight continuous cleanup (NO getgc spam)
task.spawn(function()
    while true do
        task.wait(15 + math.random() * 10)
        pcall(function()
            -- Re-disable errors only
            pcall(function()
                if not getconnections then return end
                local SC = cloneref(game:GetService("ScriptContext"))
                for _, conn in ipairs(getconnections(SC.Error)) do
                    pcall(function() conn:Disable() end)
                end
            end)
        end)
    end
end)

-- Separate memory cleanup (runs less frequently, with yields)
task.spawn(function()
    while true do
        task.wait(30 + math.random() * 15)
        pcall(function()
            if not getgc then return end
            local batch = 0
            for _, obj in ipairs(getgc(true)) do
                if type(obj) == "table" then
                    pcall(function()
                        if rawget(obj, "__acsignature") then rawset(obj, "__acsignature", nil) end
                        if rawget(obj, "__checksum") then rawset(obj, "__checksum", nil) end
                        if rawget(obj, "__exploit_flag") then rawset(obj, "__exploit_flag", nil) end
                    end)
                end
                batch = batch + 1
                if batch % 500 == 0 then task.wait() end
            end
        end)
    end
end)

-- ============================================
-- PHASE 2: FRAMEWORK DISCOVERY (deferred, non-blocking)
-- All scans run in coroutines with yields to prevent freeze
-- ============================================
local function ScanForFramework()
    -- Method 1: Search _G (lightweight)
    pcall(function()
        for key, value in pairs(_G) do
            if type(value) == "table" then
                if rawget(value, "GetEntities") or rawget(value, "GetPlayers")
                   or rawget(value, "Entities") or rawget(value, "Players") then
                    BB_Framework = value
                    return
                end
            end
        end
    end)
    task.wait()

    -- Method 2: Search getgc for entity tables (with batching)
    pcall(function()
        if not getgc then return end
        local batch = 0
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    if rawget(obj, "Character") and rawget(obj, "Health") and rawget(obj, "Alive") then
                        if not BB_EntityTable then
                            BB_EntityTable = obj
                        end
                    end
                end)
            end
            batch = batch + 1
            if batch % 300 == 0 then task.wait() end
        end
    end)
    task.wait()

    -- Method 3: Search required modules (with batching)
    pcall(function()
        if not getgc then return end
        local batch = 0
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "function" then
                pcall(function()
                    local info = debug.info(obj, "s")
                    if type(info) == "string" then
                        if info:find("Projectile") or info:find("Bullet") or info:find("Weapon") or info:find("Gun") then
                            local ups = debug.getupvalues and debug.getupvalues(obj)
                            if ups then
                                for _, up in pairs(ups) do
                                    if type(up) == "table" then
                                        if rawget(up, "Fire") or rawget(up, "Shoot") or rawget(up, "CreateBullet") then
                                            BB_Framework = up
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
            batch = batch + 1
            if batch % 300 == 0 then task.wait() end
        end
    end)
end

local function ScanForProjectileHandler()
    pcall(function()
        if not getgc then return end
        local batch = 0
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "function" then
                pcall(function()
                    local src = debug.info(obj, "s")
                    if type(src) == "string" and (
                        src:find("ProjectileHandler") or src:find("BulletHandler")
                        or src:find("FireHandler") or src:find("ShootHandler")
                        or src:find("WeaponHandler") or src:find("GunHandler")
                    ) then
                        if debug.getupvalues then
                            local ups = debug.getupvalues(obj)
                            if ups then
                                for k, v in pairs(ups) do
                                    if type(v) == "function" then
                                        local fSrc = debug.info(v, "s")
                                        if type(fSrc) == "string" and (
                                            fSrc:find("fire") or fSrc:find("shoot")
                                            or fSrc:find("bullet") or fSrc:find("projectile")
                                        ) then
                                            if not BB_FireHooked then
                                                BB_FireFunction = v
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
            batch = batch + 1
            if batch % 300 == 0 then task.wait() end
        end
    end)
end

local function ScanForShootingRemotes()
    pcall(function()
        local batch = 0
        for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                BB_ShootingRemotes[remote] = "unknown"
            end
            batch = batch + 1
            if batch % 200 == 0 then task.wait() end
        end
    end)
    task.wait()

    -- Monitor remotes for shooting patterns (with batching)
    pcall(function()
        if not getconnections then return end
        local batch = 0
        for remote, _ in pairs(BB_ShootingRemotes) do
            if remote:IsA("RemoteEvent") and remote.OnClientEvent then
                pcall(function()
                    for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                        if conn and conn.Function then
                            pcall(function()
                                local src = debug.info(conn.Function, "s")
                                if type(src) == "string" and (
                                    src:find("Weapon") or src:find("Gun") or src:find("Shoot")
                                    or src:find("Projectile") or src:find("Bullet") or src:find("Fire")
                                    or src:find("Damage") or src:find("Hit")
                                ) then
                                    BB_ShootingRemotes[remote] = "shooting"
                                end
                            end)
                        end
                    end
                end)
            end
            batch = batch + 1
            if batch % 50 == 0 then task.wait() end
        end
    end)
end

-- Run all scans deferred (not on load, after game settles)
task.spawn(function()
    task.wait(4)
    ScanForFramework()
    task.wait(1)
    ScanForProjectileHandler()
    task.wait(1)
    ScanForShootingRemotes()

    -- Retry if nothing found
    task.wait(8)
    if not BB_Framework and not BB_FireFunction then
        ScanForFramework()
        task.wait(1)
        ScanForProjectileHandler()
    end
end)

-- ============================================
-- TEAM CHECK
-- ============================================
local function IsBBTeammate(player)
    if not player or player == LocalPlayer then return false end
    local ok, result = pcall(function()
        return player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team
    end)
    if ok and result then return true end
    local ok2, r2 = pcall(function()
        return player.TeamColor and LocalPlayer.TeamColor and player.TeamColor == LocalPlayer.TeamColor
    end)
    if ok2 and r2 then return true end
    return false
end

local function ShouldSkipBBPlayer(player, teamCheckEnabled)
    if not teamCheckEnabled then return false end
    if not player or player == LocalPlayer then return false end
    return IsBBTeammate(player)
end

-- ============================================
-- BB HEALTH DETECTION (FIXED pcall/return)
-- ============================================
local function GetBBHealth(player)
    if not player then return 0, 100 end

    local char = player.Character
    if not char then return 0, 100 end

    -- Method 1: Standard Humanoid
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        return hum.Health, hum.MaxHealth
    end

    -- Method 2: Attributes (FIXED)
    local attrOk, attrHp, attrMax = pcall(function()
        local hp = char:GetAttribute("Health")
        local maxHp = char:GetAttribute("MaxHealth") or 100
        if hp then return hp, maxHp end
        return nil, nil
    end)
    if attrOk and attrHp then return attrHp, attrMax end

    -- Method 3: Value objects (FIXED)
    local valOk, valHp, valMax = pcall(function()
        local hpVal = char:FindFirstChild("Health") or char:FindFirstChild("HP")
        if hpVal and (hpVal:IsA("NumberValue") or hpVal:IsA("IntValue")) then
            local maxVal = char:FindFirstChild("MaxHealth") or char:FindFirstChild("MaxHP")
            local maxHp = maxVal and maxVal.Value or 100
            return hpVal.Value, maxHp
        end
        return nil, nil
    end)
    if valOk and valHp then return valHp, valMax end

    -- Method 4: Entity table (FIXED)
    if BB_EntityTable and player.Name then
        local entOk, entHp, entMax = pcall(function()
            for _, entity in pairs(BB_EntityTable) do
                if type(entity) == "table" and rawget(entity, "Name") == player.Name then
                    local hp = rawget(entity, "Health") or rawget(entity, "HP")
                    local maxHp = rawget(entity, "MaxHealth") or rawget(entity, "MaxHP") or 100
                    if hp then return hp, maxHp end
                end
            end
            return nil, nil
        end)
        if entOk and entHp then return entHp, entMax end
    end

    return 100, 100
end

local function IsBBAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end

    -- Standard check
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then return hum.Health > 0 end

    -- Attribute check (FIXED)
    local deadOk, isDead = pcall(function()
        local hp = char:GetAttribute("Health")
        return hp and hp <= 0
    end)
    if deadOk and isDead then return false end

    -- Value object check (FIXED)
    local valOk, valDead = pcall(function()
        local hpVal = char:FindFirstChild("Health") or char:FindFirstChild("HP")
        if hpVal and (hpVal:IsA("NumberValue") or hpVal:IsA("IntValue")) then
            return hpVal.Value <= 0
        end
        return false
    end)
    if valOk and valDead then return false end

    -- Entity table check (FIXED)
    if BB_EntityTable and player.Name then
        local entOk, entDead = pcall(function()
            for _, entity in pairs(BB_EntityTable) do
                if type(entity) == "table" and rawget(entity, "Name") == player.Name then
                    local alive = rawget(entity, "Alive")
                    if alive == false then return true end
                    local hp = rawget(entity, "Health") or rawget(entity, "HP")
                    if hp and hp <= 0 then return true end
                end
            end
            return false
        end)
        if entOk and entDead then return false end
    end

    local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
    return root ~= nil
end

-- ============================================
-- VISIBILITY CHECK
-- ============================================
local function IsBBVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}
    params.IgnoreWater = true

    local origin = cam.CFrame.Position
    local targetPos = targetPart.Position
    local dir = targetPos - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end

    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetPart.Parent) then return true end

    -- Secondary rays (reduced from 6 to 3 for performance)
    for _, offset in ipairs({
        Vector3.new(0, 0.4, 0),
        Vector3.new(0, -0.4, 0),
        Vector3.new(0.3, 0, 0),
    }) do
        local oPos = targetPos + offset
        local oDir = oPos - origin
        local oResult = Workspace:Raycast(origin, oDir.Unit * (oDir.Magnitude - 0.3), params)
        if not oResult then return true end
        if oResult.Instance and oResult.Instance:IsDescendantOf(targetPart.Parent) then return true end
    end

    return false
end

-- ============================================
-- TARGET PART RESOLVER
-- ============================================
local BB_PARTS = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}

local bbSilentRandom = "Head"
local bbSilentSwitch = 0

local function GetBBTargetPart(character, setting)
    if not character then return nil end

    if setting == "Random" then
        local t = tick()
        if t - bbSilentSwitch > 0.5 then
            local valid = {}
            for _, n in ipairs(BB_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then bbSilentRandom = valid[math.random(1, #valid)] end
            bbSilentSwitch = t
        end
        local p = character:FindFirstChild(bbSilentRandom)
        if p and p:IsA("BasePart") then return p end
    end

    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

-- ============================================
-- ARTIFICIAL SPREAD
-- ============================================
local function ApplyArtificialSpread(targetPos, spreadAmount)
    if not spreadAmount or spreadAmount <= 0 then return targetPos end
    local offsetX = (math.random() - 0.5) * 2 * spreadAmount
    local offsetY = (math.random() - 0.5) * 2 * spreadAmount
    local offsetZ = (math.random() - 0.5) * 2 * spreadAmount
    return targetPos + Vector3.new(offsetX, offsetY, offsetZ)
end

local function ShouldIntentionallyMiss()
    return math.random(1, 100) <= 15
end

-- ============================================
-- SILENT AIM TARGET FINDER
-- ============================================
local CurrentBBTarget = nil

local function GetClosestBBTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end

    local closest, closestDist = nil, Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if ShouldSkipBBPlayer(player, Config.Silent.TeamCheck) then continue end

        local char = player.Character
        if not char then continue end
        if not IsBBAlive(player) then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end

        local tp = GetBBTargetPart(char, Config.Silent.TargetPart)
        if not tp then continue end

        if Config.Silent.VisibleCheck and not IsBBVisible(tp) then continue end

        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end

        local d = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if d < closestDist then
            closestDist = d
            closest = tp
        end
    end

    return closest
end

-- ============================================
-- AIMBOT TARGET FINDER
-- ============================================
local bbAimbotLocked = nil
local bbAimbotRandom = "Head"
local bbAimbotSwitch = 0

local function GetBBAimbotPart(character)
    if not character then return nil end
    local s = Config.Aimbot.TargetPart

    if s == "Random" then
        local t = tick()
        if t - bbAimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(BB_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then bbAimbotRandom = valid[math.random(1, #valid)] end
            bbAimbotSwitch = t
        end
        local p = character:FindFirstChild(bbAimbotRandom)
        if p and p:IsA("BasePart") then return p end
    end

    return character:FindFirstChild(s)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

local function IsBBPlayerValid(player)
    if not player or not player.Parent then return false end
    if player == LocalPlayer then return false end
    if ShouldSkipBBPlayer(player, Config.Aimbot.TeamCheck) then return false end
    local c = player.Character
    if not c then return false end
    if c:FindFirstChildOfClass("ForceField") then return false end
    return IsBBAlive(player)
end

local function GetBBAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end

    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local center = Vector2.new(vp.X / 2, vp.Y / 2)
    local mousePos = UserInputService:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos

    if Config.Aimbot.Method == "Aimlock" and bbAimbotLocked then
        if IsBBPlayerValid(bbAimbotLocked) then
            local tp = GetBBAimbotPart(bbAimbotLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsBBVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        bbAimbotLocked = nil
    end

    local best, bestDist, bestP = nil, fov, nil
    for _, player in ipairs(Players:GetPlayers()) do
        if not IsBBPlayerValid(player) then continue end
        local tp = GetBBAimbotPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsBBVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d best = tp bestP = player end
    end

    if Config.Aimbot.Method == "Aimlock" and bestP then
        bbAimbotLocked = bestP
    end
    return best
end

-- ============================================
-- SILENT AIM: __namecall HOOK
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if checkcaller() then return oldNamecall(self, ...) end

    if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
        local effectiveChance = Config.Silent.HitChance
        if ShouldIntentionallyMiss() then
            effectiveChance = 0
        end

        if math.random(1, 100) <= effectiveChance then
            local targetPos = CurrentBBTarget.Position
            targetPos = ApplyArtificialSpread(targetPos, 0.15)

            if self == Workspace or self == workspace then
                if method == "Raycast" then
                    local o, d = args[1], args[2]
                    if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                        return oldNamecall(self, o, (targetPos - o).Unit * d.Magnitude, select(3, ...))
                    end
                end

                if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                    local ray = args[1]
                    if typeof(ray) == "Ray" then
                        args[1] = Ray.new(ray.Origin, (targetPos - ray.Origin).Unit * ray.Direction.Magnitude)
                        return oldNamecall(self, unpack(args))
                    end
                end
            end

            if self:IsA("RemoteEvent") and method == "FireServer" then
                if BB_ShootingRemotes[self] == "shooting" then
                    local modified = false
                    for i, arg in ipairs(args) do
                        if typeof(arg) == "CFrame" then
                            args[i] = CFrame.new(arg.Position, targetPos)
                            modified = true
                        elseif typeof(arg) == "Vector3" and i > 1 then
                            local prevArg = args[i - 1]
                            if typeof(prevArg) == "Vector3" or typeof(prevArg) == "CFrame" then
                                local origin = typeof(prevArg) == "CFrame" and prevArg.Position or prevArg
                                args[i] = (targetPos - origin).Unit * arg.Magnitude
                                modified = true
                            end
                        end
                    end
                    if modified then return oldNamecall(self, unpack(args)) end
                end
            end
        end
    end

    return oldNamecall(self, ...)
end))

-- ============================================
-- PROJECTILE HANDLER HOOK (deferred, non-blocking)
-- ============================================
local function TryHookProjectileHandler()
    if BB_FireHooked then return end

    if BB_FireFunction and not BB_FireHooked then
        pcall(function()
            local originalFire = BB_FireFunction
            HookedFunctions[BB_FireFunction] = originalFire

            hookfunction(BB_FireFunction, newcclosure(function(data, ...)
                if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
                    if math.random(1, 100) <= Config.Silent.HitChance and not ShouldIntentionallyMiss() then
                        local targetPos = CurrentBBTarget.Position
                        targetPos = ApplyArtificialSpread(targetPos, 0.1)

                        if type(data) == "table" then
                            if data.Direction then
                                local origin = data.Origin or data.Position or (Camera and Camera.CFrame.Position)
                                if origin then
                                    data.Direction = (targetPos - origin).Unit
                                end
                            end
                            if data.Velocity and typeof(data.Velocity) == "Vector3" then
                                local origin = data.Origin or data.Position or Camera.CFrame.Position
                                data.Velocity = (targetPos - origin).Unit * data.Velocity.Magnitude
                            end
                        end
                    end
                end
                return originalFire(data, ...)
            end))

            BB_FireHooked = true
        end)
    end

    if not BB_FireHooked then
        pcall(function()
            if not getgc then return end
            local batch = 0
            for _, obj in ipairs(getgc(true)) do
                if BB_FireHooked then break end
                if type(obj) == "table" then
                    pcall(function()
                        local fireFunc = rawget(obj, "Fire") or rawget(obj, "fire")
                            or rawget(obj, "Shoot") or rawget(obj, "shoot")
                            or rawget(obj, "CreateBullet") or rawget(obj, "createBullet")

                        if typeof(fireFunc) == "function" and not BB_FireHooked then
                            local originalFire = fireFunc
                            HookedFunctions[fireFunc] = originalFire

                            local funcKey = rawget(obj, "Fire") and "Fire"
                                or rawget(obj, "fire") and "fire"
                                or rawget(obj, "Shoot") and "Shoot"
                                or rawget(obj, "shoot") and "shoot"
                                or rawget(obj, "CreateBullet") and "CreateBullet"
                                or rawget(obj, "createBullet") and "createBullet"

                            if funcKey then
                                rawset(obj, funcKey, function(data, ...)
                                    if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
                                        if math.random(1, 100) <= Config.Silent.HitChance and not ShouldIntentionallyMiss() then
                                            local targetPos = ApplyArtificialSpread(CurrentBBTarget.Position, 0.1)
                                            if type(data) == "table" then
                                                if data.Direction then
                                                    local origin = data.Origin or data.Position or Camera.CFrame.Position
                                                    data.Direction = (targetPos - origin).Unit
                                                end
                                                if data.Velocity and typeof(data.Velocity) == "Vector3" then
                                                    local origin = data.Origin or data.Position or Camera.CFrame.Position
                                                    data.Velocity = (targetPos - origin).Unit * data.Velocity.Magnitude
                                                end
                                            end
                                        end
                                    end
                                    return originalFire(data, ...)
                                end)
                                BB_FireHooked = true
                            end
                        end
                    end)
                end
                batch = batch + 1
                if batch % 300 == 0 then task.wait() end
            end
        end)
    end
end

task.spawn(function()
    task.wait(7)
    TryHookProjectileHandler()

    if not BB_FireHooked then
        for attempt = 1, 3 do
            task.wait(12)
            if BB_FireHooked then break end
            ScanForProjectileHandler()
            task.wait(1)
            TryHookProjectileHandler()
        end
    end
end)

-- ============================================
-- ESP SYSTEM
-- ============================================
local BBESP = {}
local BBLastESP = 0

local function CreateBBESP(player)
    if BBESP[player] then return end
    local e = {}
    e.Box = Drawing.new("Square") e.Box.Thickness = 1 e.Box.Filled = false e.Box.Visible = false
    e.Outline = Drawing.new("Square") e.Outline.Thickness = 3 e.Outline.Filled = false e.Outline.Color = Color3.fromRGB(0, 0, 0) e.Outline.Transparency = 0.5 e.Outline.Visible = false
    e.Name = Drawing.new("Text") e.Name.Size = 13 e.Name.Center = true e.Name.Outline = true e.Name.Color = Color3.fromRGB(255, 255, 255) e.Name.Visible = false
    e.Distance = Drawing.new("Text") e.Distance.Size = 12 e.Distance.Center = true e.Distance.Outline = true e.Distance.Color = Color3.fromRGB(200, 200, 200) e.Distance.Visible = false
    e.HealthBG = Drawing.new("Square") e.HealthBG.Thickness = 1 e.HealthBG.Filled = true e.HealthBG.Color = Color3.fromRGB(0, 0, 0) e.HealthBG.Transparency = 0.5 e.HealthBG.Visible = false
    e.HealthBar = Drawing.new("Square") e.HealthBar.Thickness = 1 e.HealthBar.Filled = true e.HealthBar.Color = Color3.fromRGB(0, 255, 0) e.HealthBar.Visible = false
    BBESP[player] = e
end

local function RemoveBBESP(p)
    local e = BBESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    BBESP[p] = nil
end

local function HideBBESP(p)
    local e = BBESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function UpdateBBESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(BBESP) do HideBBESP(p) end
        return
    end

    local now = tick()
    if now - BBLastESP < 0.08 then return end
    BBLastESP = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    local active = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true

        local isTm = IsBBTeammate(player)

        if Config.ESP.TeamCheck and isTm then
            HideBBESP(player)
            continue
        end

        if not BBESP[player] then CreateBBESP(player) end
        local esp = BBESP[player]
        if not esp then continue end

        local c = player.Character
        if not c then HideBBESP(player) continue end
        if not IsBBAlive(player) then HideBBESP(player) continue end
        if c:FindFirstChildOfClass("ForceField") then HideBBESP(player) continue end

        local rp = c:FindFirstChild("HumanoidRootPart")
            or c:FindFirstChild("UpperTorso")
            or c:FindFirstChild("Torso")
        local head = c:FindFirstChild("Head")

        if not rp then HideBBESP(player) continue end

        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideBBESP(player) continue end

        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideBBESP(player) continue end

        local hSP = head and Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0)) or sp
        local fSP = Camera:WorldToViewportPoint(rp.Position - Vector3.new(0, 3, 0))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width = height / 2
        local minX, minY = sp.X - width / 2, hSP.Y

        local col
        if isTm then
            col = Color3.fromRGB(80, 150, 255)
        else
            local visTarget = head or rp
            local isVis = IsBBVisible(visTarget)
            col = isVis and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        end

        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, minY - 1)
            esp.Outline.Visible = true
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, minY)
            esp.Box.Color = col
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end

        if Config.ESP.Names then
            esp.Name.Text = player.DisplayName or player.Name
            esp.Name.Position = Vector2.new(minX + width / 2, minY - 16)
            esp.Name.Color = col
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end

        if Config.ESP.Distance then
            esp.Distance.Text = math.floor(dist) .. "m"
            esp.Distance.Position = Vector2.new(minX + width / 2, minY + height + 2)
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end

        local hp, maxHp = GetBBHealth(player)
        if Config.ESP.Boxes and hp and maxHp and maxHp > 0 then
            local pct = math.clamp(hp / maxHp, 0, 1)
            local bh = height * pct
            local hc
            if pct > 0.5 then
                hc = Color3.fromRGB(math.floor(255 * (1 - pct) * 2), 255, 0)
            else
                hc = Color3.fromRGB(255, math.floor(255 * pct * 2), 0)
            end
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, minY)
            esp.HealthBG.Visible = true
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, minY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end

    for p in pairs(BBESP) do
        if not active[p] then
            if not p.Parent then RemoveBBESP(p) else HideBBESP(p) end
        end
    end
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera

    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentBBTarget = GetClosestBBTarget()
    else
        CurrentBBTarget = nil
    end

    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local t = GetBBAimbotTarget()
        if t then
            local pos = t.Position
            pcall(function()
                if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                    local v = t.AssemblyLinearVelocity
                    if v and v.Magnitude > 0.5 then
                        pos = pos + v * Config.Aimbot.Prediction
                    end
                end
            end)

            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)

            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    local d = math.sqrt(dx * dx + dy * dy)
                    if d > 1 then
                        local spd = math.clamp(1 / sm, 0.05, 0.8)
                        if d > 150 then spd = spd * 0.5
                        elseif d > 50 then spd = spd * 0.8
                        elseif d < 15 then spd = spd * 1.4 end
                        local mx = math.clamp(dx * spd, -150, 150)
                        local my = math.clamp(dy * spd, -150, 150)
                        if math.abs(mx) > 0.2 or math.abs(my) > 0.2 then
                            mousemoverel(mx, my)
                        end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then bbAimbotLocked = nil end
        end
    else
        if not Config.Aimbot.Active then bbAimbotLocked = nil end
    end
end)

RunService.Heartbeat:Connect(function()
    UpdateBBESP()
end)

-- ============================================
-- SIGNALS + INIT
-- ============================================
getgenv().AX_BBLoaded = true
getgenv().AX_BBHandlesAimbot = true
getgenv().AX_BBHandlesESP = true

for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then CreateBBESP(p) end
end
Players.PlayerAdded:Connect(function(p) CreateBBESP(p) end)
Players.PlayerRemoving:Connect(function(p)
    if bbAimbotLocked == p then bbAimbotLocked = nil end
    RemoveBBESP(p)
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentBBTarget = nil
    bbAimbotLocked = nil

    task.wait(3)
    ScanForShootingRemotes()
    if not BB_FireHooked then
        ScanForProjectileHandler()
        task.wait(1)
        TryHookProjectileHandler()
    end
end)

local hookStatus = BB_FireHooked and "ProjectileHandler hooked" or "__namecall fallback"
print("  ✅ BAD BUSINESS v2.2 - Silent Aim (" .. hookStatus .. ")")
print("  ✅ BAD BUSINESS v2.2 - Aimbot (dynamic smooth)")
print("  ✅ BAD BUSINESS v2.2 - ESP (multi-health detection)")
print("  ✅ BAD BUSINESS v2.2 - AC Bypass (safe, no freeze)")
