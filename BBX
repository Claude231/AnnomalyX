--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║          ANNOMALY X - Bad Business Module v2.0             ║
    ║                                                           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
    
    BAD BUSINESS ARCHITECTURE (from analysis):
    - PlaceId: 3233893879
    - Custom Character Controller (Humanoid is irrelevant for damage)
    - Uses "Skinning" (deformable meshes) + own controller
    - Projectile-based weapons (not hitscan) - bullets travel
    - Framework accessible via _G or required ModuleScripts
    - Entity table in client stores all alive players
    - RemoteEvent names are OBFUSCATED (change each update)
    - AC checks: fire rate, movement speed, teleportation
    - AC verifies if fire_bullet function has been modified
    
    SILENT AIM STRATEGY (from analysis):
    1. Find the ProjectileHandler/fire_bullet module via getgc/require
    2. Hook the bullet creation function
    3. Replace direction vector: V = (EnemyHead - Barrel).Unit
    4. Add artificial spread to avoid 100% accuracy detection
    
    FALLBACK STRATEGY:
    - If module hook fails, use __namecall on Raycast (some BB
      weapons still use hitscan for close range)
    - Network Event Spy: detect shooting remotes by monitoring
      argument patterns instead of names (they're obfuscated)
    
    AC BYPASS STRATEGY (from analysis):
    - hookmetamethod __index to return clean copies of hooked
      functions when AC tries to verify them
    - Don't modify fire rate or movement speed
    - Add intentional spread (miss ~15% on purpose)
    
    ESP STRATEGY:
    - BB uses complex character models with Bones
    - Standard Head/HumanoidRootPart still exist for positioning
    - Health is managed by custom system, may need to read from
      entity table or Humanoid (BB keeps it synced for display)
    - Use VisCheck raycast for color coding
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Workspace = cloneref(game:GetService("Workspace"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- BB INTERNAL REFERENCES
-- These are discovered at runtime via scanning
-- ============================================
local BB_Framework = nil         -- Main game framework table
local BB_EntityTable = nil       -- Table of alive entities
local BB_FireFunction = nil      -- Original fire_bullet function
local BB_FireHooked = false      -- Whether we successfully hooked fire
local BB_ShootingRemotes = {}    -- Detected shooting remotes (by pattern)
local BB_HealthCache = {}        -- Cached health values per player

-- ============================================
-- PHASE 1: AC BYPASS
-- Non-destructive, returns clean copies to AC
-- ============================================
local HookedFunctions = {} -- Store original copies for AC spoofing

local function ApplyBBACBypass()
    local results = {kick = false, errors = 0, index_hook = false, memory = 0}
    
    -- Kick protection
    pcall(function()
        local oldKick = LocalPlayer.Kick
        if typeof(oldKick) == "function" then
            hookfunction(oldKick, newcclosure(function(self, ...)
                if self == LocalPlayer then return end
                return oldKick(self, ...)
            end))
            results.kick = true
        end
    end)
    
    -- Error suppression
    pcall(function()
        local SC = cloneref(game:GetService("ScriptContext"))
        if getconnections then
            for _, conn in ipairs(getconnections(SC.Error)) do
                pcall(function() conn:Disable() results.errors = results.errors + 1 end)
            end
        end
    end)
    
    -- Memory signature cleanup
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    for _, k in ipairs({
                        "__acsignature", "__checksum", "__hash", "__integrity",
                        "__validation", "__exploit_flag", "_ac_token"
                    }) do
                        if rawget(obj, k) then
                            rawset(obj, k, nil)
                            results.memory = results.memory + 1
                        end
                    end
                end)
            end
        end
    end)
    
    return results
end

local acResults = ApplyBBACBypass()

-- Continuous cleanup
task.spawn(function()
    while true do
        task.wait(12 + math.random() * 8)
        pcall(function()
            -- Re-suppress errors
            pcall(function()
                if getconnections then
                    local SC = cloneref(game:GetService("ScriptContext"))
                    for _, conn in ipairs(getconnections(SC.Error)) do
                        pcall(function() conn:Disable() end)
                    end
                end
            end)
            -- Memory cleanup
            pcall(function()
                if getgc then
                    for _, obj in ipairs(getgc(true)) do
                        if type(obj) == "table" then
                            pcall(function()
                                if rawget(obj, "__acsignature") then rawset(obj, "__acsignature", nil) end
                                if rawget(obj, "__checksum") then rawset(obj, "__checksum", nil) end
                                if rawget(obj, "__exploit_flag") then rawset(obj, "__exploit_flag", nil) end
                            end)
                        end
                    end
                end
            end)
        end)
    end
end)

-- ============================================
-- PHASE 2: FRAMEWORK DISCOVERY
-- Scan for BB's internal game framework
-- ============================================
local function ScanForFramework()
    -- Method 1: Search _G for framework tables
    pcall(function()
        for key, value in pairs(_G) do
            if type(value) == "table" then
                -- BB framework typically has entity management functions
                if rawget(value, "GetEntities") or rawget(value, "GetPlayers") 
                   or rawget(value, "Entities") or rawget(value, "Players") then
                    BB_Framework = value
                    return
                end
            end
        end
    end)
    
    -- Method 2: Search getgc for entity tables
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    -- Look for tables that contain player-like entries
                    -- BB entity tables typically have Character, Health, Position fields
                    if rawget(obj, "Character") and rawget(obj, "Health") and rawget(obj, "Alive") then
                        if not BB_EntityTable then
                            BB_EntityTable = obj
                        end
                    end
                end)
            end
        end
    end)
    
    -- Method 3: Search required modules
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "function" then
                pcall(function()
                    local info = debug.info(obj, "s")
                    if type(info) == "string" then
                        if info:find("Projectile") or info:find("Bullet") or info:find("Weapon") or info:find("Gun") then
                            -- Found a weapon-related function
                            local ups = debug.getupvalues and debug.getupvalues(obj)
                            if ups then
                                for _, up in pairs(ups) do
                                    if type(up) == "table" then
                                        if rawget(up, "Fire") or rawget(up, "Shoot") or rawget(up, "CreateBullet") then
                                            BB_Framework = up
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        end
    end)
end

-- Method 4: Search for ProjectileHandler module
local function ScanForProjectileHandler()
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "function" then
                pcall(function()
                    local src = debug.info(obj, "s")
                    if type(src) == "string" and (
                        src:find("ProjectileHandler") or src:find("BulletHandler")
                        or src:find("FireHandler") or src:find("ShootHandler")
                        or src:find("WeaponHandler") or src:find("GunHandler")
                    ) then
                        -- Try to get upvalues that contain the fire function
                        if debug.getupvalues then
                            local ups = debug.getupvalues(obj)
                            if ups then
                                for k, v in pairs(ups) do
                                    if type(v) == "function" then
                                        -- Store as potential fire function
                                        local fSrc = debug.info(v, "s")
                                        if type(fSrc) == "string" and (
                                            fSrc:find("fire") or fSrc:find("shoot")
                                            or fSrc:find("bullet") or fSrc:find("projectile")
                                        ) then
                                            if not BB_FireHooked then
                                                BB_FireFunction = v
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        end
    end)
end

-- Method 5: Network Event Spy
-- Detect shooting remotes by monitoring argument patterns
local function ScanForShootingRemotes()
    pcall(function()
        -- Search all RemoteEvents
        for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
            if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                BB_ShootingRemotes[remote] = "unknown"
            end
        end
        
        -- Also check under game services
        for _, service in ipairs({
            game:GetService("ReplicatedFirst"),
            ReplicatedStorage,
        }) do
            for _, child in ipairs(service:GetDescendants()) do
                if child:IsA("RemoteEvent") then
                    BB_ShootingRemotes[child] = "unknown"
                end
            end
        end
    end)
    
    -- Monitor remotes for shooting patterns
    -- A shooting remote typically receives: CFrame/Vector3 (origin), Vector3 (direction), number (weapon id)
    pcall(function()
        if not getconnections then return end
        for remote, _ in pairs(BB_ShootingRemotes) do
            if remote:IsA("RemoteEvent") and remote.OnClientEvent then
                -- Check existing connections for weapon-related functions
                for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                    if conn and conn.Function then
                        pcall(function()
                            local src = debug.info(conn.Function, "s")
                            if type(src) == "string" and (
                                src:find("Weapon") or src:find("Gun") or src:find("Shoot")
                                or src:find("Projectile") or src:find("Bullet") or src:find("Fire")
                                or src:find("Damage") or src:find("Hit")
                            ) then
                                BB_ShootingRemotes[remote] = "shooting"
                            end
                        end)
                    end
                end
            end
        end
    end)
end

-- Run scans
task.spawn(function()
    task.wait(2)
    ScanForFramework()
    ScanForProjectileHandler()
    ScanForShootingRemotes()
    
    -- Retry after a delay if nothing found
    task.wait(5)
    if not BB_Framework and not BB_FireFunction then
        ScanForFramework()
        ScanForProjectileHandler()
    end
end)

-- ============================================
-- TEAM CHECK
-- BB uses standard Roblox Teams
-- ============================================
local function ShouldSkipBBPlayer(player, teamCheckEnabled)
    if not teamCheckEnabled then return false end
    if not player or player == LocalPlayer then return false end
    local ok, result = pcall(function()
        return player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team
    end)
    if ok and result then return true end
    -- TeamColor fallback
    local ok2, r2 = pcall(function()
        return player.TeamColor and LocalPlayer.TeamColor and player.TeamColor == LocalPlayer.TeamColor
    end)
    if ok2 and r2 then return true end
    return false
end

-- ============================================
-- BB HEALTH DETECTION
-- BB may use custom health system; try multiple methods
-- ============================================
local function GetBBHealth(player)
    if not player then return 0, 100 end
    
    -- Method 1: Standard Humanoid (BB keeps it synced for display)
    local char = player.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            return hum.Health, hum.MaxHealth
        end
    end
    
    -- Method 2: Check attributes
    pcall(function()
        if char then
            local hp = char:GetAttribute("Health")
            local maxHp = char:GetAttribute("MaxHealth") or 100
            if hp then return hp, maxHp end
        end
    end)
    
    -- Method 3: Check for health value objects
    pcall(function()
        if char then
            local hpVal = char:FindFirstChild("Health") or char:FindFirstChild("HP")
            if hpVal and (hpVal:IsA("NumberValue") or hpVal:IsA("IntValue")) then
                local maxVal = char:FindFirstChild("MaxHealth") or char:FindFirstChild("MaxHP")
                local maxHp = maxVal and maxVal.Value or 100
                return hpVal.Value, maxHp
            end
        end
    end)
    
    -- Method 4: From entity table
    if BB_EntityTable and player.Name then
        pcall(function()
            for _, entity in pairs(BB_EntityTable) do
                if type(entity) == "table" and rawget(entity, "Name") == player.Name then
                    local hp = rawget(entity, "Health") or rawget(entity, "HP")
                    local maxHp = rawget(entity, "MaxHealth") or rawget(entity, "MaxHP") or 100
                    if hp then return hp, maxHp end
                end
            end
        end)
    end
    
    return 100, 100 -- Default: assume full health
end

local function IsBBAlive(player)
    if not player then return false end
    local char = player.Character
    if not char then return false end
    
    -- Standard check
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then return hum.Health > 0 end
    
    -- Attribute check
    pcall(function()
        local hp = char:GetAttribute("Health")
        if hp and hp <= 0 then return false end
    end)
    
    -- If we can't determine, check if character has essential parts
    local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
    return root ~= nil
end

-- ============================================
-- VISIBILITY CHECK (multi-ray)
-- ============================================
local function IsBBVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}
    params.IgnoreWater = true
    
    local origin = cam.CFrame.Position
    local targetPos = targetPart.Position
    local dir = targetPos - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end
    
    -- Primary ray
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetPart.Parent) then return true end
    
    -- Secondary rays to handle BB's complex character meshes
    local offsets = {
        Vector3.new(0, 0.4, 0),    -- Above center
        Vector3.new(0, -0.4, 0),   -- Below center
        Vector3.new(0.3, 0, 0),    -- Right
        Vector3.new(-0.3, 0, 0),   -- Left
        Vector3.new(0, 0, 0.3),    -- Front
        Vector3.new(0, 0, -0.3),   -- Back
    }
    
    for _, offset in ipairs(offsets) do
        local oPos = targetPos + offset
        local oDir = oPos - origin
        local oResult = Workspace:Raycast(origin, oDir.Unit * (oDir.Magnitude - 0.3), params)
        if not oResult then return true end
        if oResult.Instance and oResult.Instance:IsDescendantOf(targetPart.Parent) then return true end
    end
    
    return false
end

-- ============================================
-- TARGET PART RESOLVER
-- BB uses R15 but with custom mesh deformation
-- ============================================
local BB_PARTS = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg"}

local bbSilentRandom = "Head"
local bbSilentSwitch = 0

local function GetBBTargetPart(character, setting)
    if not character then return nil end
    
    if setting == "Random" then
        local t = tick()
        if t - bbSilentSwitch > 0.5 then
            local valid = {}
            for _, n in ipairs(BB_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then bbSilentRandom = valid[math.random(1, #valid)] end
            bbSilentSwitch = t
        end
        local p = character:FindFirstChild(bbSilentRandom)
        if p and p:IsA("BasePart") then return p end
    end
    
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

-- ============================================
-- ARTIFICIAL SPREAD
-- Add intentional inaccuracy to avoid 100% headshot
-- detection by BB's behavioral analysis
-- ============================================
local function ApplyArtificialSpread(targetPos, spreadAmount)
    if not spreadAmount or spreadAmount <= 0 then return targetPos end
    
    local offsetX = (math.random() - 0.5) * 2 * spreadAmount
    local offsetY = (math.random() - 0.5) * 2 * spreadAmount
    local offsetZ = (math.random() - 0.5) * 2 * spreadAmount
    
    return targetPos + Vector3.new(offsetX, offsetY, offsetZ)
end

-- Intentionally miss ~15% of shots to appear human
local function ShouldIntentionallyMiss()
    return math.random(1, 100) <= 15
end

-- ============================================
-- SILENT AIM TARGET FINDER
-- ============================================
local CurrentBBTarget = nil

local function GetClosestBBTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    
    local closest, closestDist = nil, Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if ShouldSkipBBPlayer(player, Config.Silent.TeamCheck) then continue end
        
        local char = player.Character
        if not char then continue end
        if not IsBBAlive(player) then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end
        
        local tp = GetBBTargetPart(char, Config.Silent.TargetPart)
        if not tp then continue end
        
        if Config.Silent.VisibleCheck and not IsBBVisible(tp) then continue end
        
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        
        local d = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if d < closestDist then
            closestDist = d
            closest = tp
        end
    end
    
    return closest
end

-- ============================================
-- AIMBOT TARGET FINDER
-- ============================================
local bbAimbotLocked = nil
local bbAimbotRandom = "Head"
local bbAimbotSwitch = 0

local function GetBBAimbotPart(character)
    if not character then return nil end
    local s = Config.Aimbot.TargetPart
    
    if s == "Random" then
        local t = tick()
        if t - bbAimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(BB_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then bbAimbotRandom = valid[math.random(1, #valid)] end
            bbAimbotSwitch = t
        end
        local p = character:FindFirstChild(bbAimbotRandom)
        if p and p:IsA("BasePart") then return p end
    end
    
    return character:FindFirstChild(s)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

local function IsBBPlayerValid(player)
    if not player or not player.Parent then return false end
    if player == LocalPlayer then return false end
    if ShouldSkipBBPlayer(player, Config.Aimbot.TeamCheck) then return false end
    local c = player.Character
    if not c then return false end
    if c:FindFirstChildOfClass("ForceField") then return false end
    return IsBBAlive(player)
end

local function GetBBAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local center = Vector2.new(vp.X / 2, vp.Y / 2)
    local mousePos = UserInputService:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos
    
    -- Aimlock persistence
    if Config.Aimbot.Method == "Aimlock" and bbAimbotLocked then
        if IsBBPlayerValid(bbAimbotLocked) then
            local tp = GetBBAimbotPart(bbAimbotLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsBBVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        bbAimbotLocked = nil
    end
    
    local best, bestDist, bestP = nil, fov, nil
    for _, player in ipairs(Players:GetPlayers()) do
        if not IsBBPlayerValid(player) then continue end
        local tp = GetBBAimbotPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsBBVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d best = tp bestP = player end
    end
    
    if Config.Aimbot.Method == "Aimlock" and bestP then
        bbAimbotLocked = bestP
    end
    return best
end

-- ============================================
-- SILENT AIM: __namecall HOOK
-- Works for hitscan weapons and raycast-based
-- hit detection in BB
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if checkcaller() then return oldNamecall(self, ...) end
    
    if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
        -- Hit chance check (includes artificial miss)
        local effectiveChance = Config.Silent.HitChance
        if ShouldIntentionallyMiss() then
            effectiveChance = 0 -- Force miss this shot
        end
        
        if math.random(1, 100) <= effectiveChance then
            local targetPos = CurrentBBTarget.Position
            
            -- Apply small spread to avoid perfect accuracy flag
            targetPos = ApplyArtificialSpread(targetPos, 0.15)
            
            if self == Workspace or self == workspace then
                if method == "Raycast" then
                    local o, d = args[1], args[2]
                    if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                        return oldNamecall(self, o, (targetPos - o).Unit * d.Magnitude, select(3, ...))
                    end
                end
                
                if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                    local ray = args[1]
                    if typeof(ray) == "Ray" then
                        args[1] = Ray.new(ray.Origin, (targetPos - ray.Origin).Unit * ray.Direction.Magnitude)
                        return oldNamecall(self, unpack(args))
                    end
                end
            end
            
            -- Intercept shooting remotes (detected by pattern, not name)
            if self:IsA("RemoteEvent") and method == "FireServer" then
                if BB_ShootingRemotes[self] == "shooting" then
                    local modified = false
                    for i, arg in ipairs(args) do
                        if typeof(arg) == "CFrame" then
                            args[i] = CFrame.new(arg.Position, targetPos)
                            modified = true
                        elseif typeof(arg) == "Vector3" and i > 1 then
                            -- Direction vector argument
                            local prevArg = args[i - 1]
                            if typeof(prevArg) == "Vector3" or typeof(prevArg) == "CFrame" then
                                local origin = typeof(prevArg) == "CFrame" and prevArg.Position or prevArg
                                args[i] = (targetPos - origin).Unit * arg.Magnitude
                                modified = true
                            end
                        end
                    end
                    if modified then return oldNamecall(self, unpack(args)) end
                end
            end
        end
    end
    
    return oldNamecall(self, ...)
end))

-- ============================================
-- PROJECTILE HANDLER HOOK (if found)
-- This is the premium method for BB silent aim
-- ============================================
task.spawn(function()
    task.wait(5) -- Wait for game to fully load
    
    if BB_FireFunction and not BB_FireHooked then
        pcall(function()
            local originalFire = BB_FireFunction
            -- Store original for AC spoofing
            HookedFunctions[BB_FireFunction] = originalFire
            
            hookfunction(BB_FireFunction, newcclosure(function(data, ...)
                if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
                    if math.random(1, 100) <= Config.Silent.HitChance and not ShouldIntentionallyMiss() then
                        local targetPos = CurrentBBTarget.Position
                        targetPos = ApplyArtificialSpread(targetPos, 0.1)
                        
                        if type(data) == "table" then
                            -- Redirect direction
                            if data.Direction then
                                local origin = data.Origin or data.Position or (Camera and Camera.CFrame.Position)
                                if origin then
                                    data.Direction = (targetPos - origin).Unit
                                end
                            end
                            -- Some BB versions use Velocity instead
                            if data.Velocity and typeof(data.Velocity) == "Vector3" then
                                local origin = data.Origin or data.Position or Camera.CFrame.Position
                                data.Velocity = (targetPos - origin).Unit * data.Velocity.Magnitude
                            end
                        end
                    end
                end
                return originalFire(data, ...)
            end))
            
            BB_FireHooked = true
        end)
    end
    
    -- Try to find and hook via require scanning
    if not BB_FireHooked then
        pcall(function()
            if not getgc then return end
            for _, obj in ipairs(getgc(true)) do
                if type(obj) == "table" then
                    pcall(function()
                        local fireFunc = rawget(obj, "Fire") or rawget(obj, "fire")
                            or rawget(obj, "Shoot") or rawget(obj, "shoot")
                            or rawget(obj, "CreateBullet") or rawget(obj, "createBullet")
                        
                        if typeof(fireFunc) == "function" and not BB_FireHooked then
                            local originalFire = fireFunc
                            HookedFunctions[fireFunc] = originalFire
                            
                            local funcKey = rawget(obj, "Fire") and "Fire"
                                or rawget(obj, "fire") and "fire"
                                or rawget(obj, "Shoot") and "Shoot"
                                or rawget(obj, "shoot") and "shoot"
                                or rawget(obj, "CreateBullet") and "CreateBullet"
                                or rawget(obj, "createBullet") and "createBullet"
                            
                            if funcKey then
                                rawset(obj, funcKey, function(data, ...)
                                    if Config.Silent.Enabled and Config.Silent.Active and CurrentBBTarget and CurrentBBTarget.Parent then
                                        if math.random(1, 100) <= Config.Silent.HitChance and not ShouldIntentionallyMiss() then
                                            local targetPos = ApplyArtificialSpread(CurrentBBTarget.Position, 0.1)
                                            if type(data) == "table" then
                                                if data.Direction then
                                                    local origin = data.Origin or data.Position or Camera.CFrame.Position
                                                    data.Direction = (targetPos - origin).Unit
                                                end
                                                if data.Velocity and typeof(data.Velocity) == "Vector3" then
                                                    local origin = data.Origin or data.Position or Camera.CFrame.Position
                                                    data.Velocity = (targetPos - origin).Unit * data.Velocity.Magnitude
                                                end
                                            end
                                        end
                                    end
                                    return originalFire(data, ...)
                                end)
                                BB_FireHooked = true
                            end
                        end
                    end)
                end
            end
        end)
    end
end)

-- ============================================
-- ESP SYSTEM
-- ============================================
local BBESP = {}
local BBLastESP = 0

local function CreateBBESP(player)
    if BBESP[player] then return end
    local e = {}
    e.Box = Drawing.new("Square") e.Box.Thickness = 1 e.Box.Filled = false e.Box.Visible = false
    e.Outline = Drawing.new("Square") e.Outline.Thickness = 3 e.Outline.Filled = false e.Outline.Color = Color3.fromRGB(0,0,0) e.Outline.Transparency = 0.5 e.Outline.Visible = false
    e.Name = Drawing.new("Text") e.Name.Size = 13 e.Name.Center = true e.Name.Outline = true e.Name.Color = Color3.fromRGB(255,255,255) e.Name.Visible = false
    e.Distance = Drawing.new("Text") e.Distance.Size = 12 e.Distance.Center = true e.Distance.Outline = true e.Distance.Color = Color3.fromRGB(200,200,200) e.Distance.Visible = false
    e.HealthBG = Drawing.new("Square") e.HealthBG.Thickness = 1 e.HealthBG.Filled = true e.HealthBG.Color = Color3.fromRGB(0,0,0) e.HealthBG.Transparency = 0.5 e.HealthBG.Visible = false
    e.HealthBar = Drawing.new("Square") e.HealthBar.Thickness = 1 e.HealthBar.Filled = true e.HealthBar.Color = Color3.fromRGB(0,255,0) e.HealthBar.Visible = false
    BBESP[player] = e
end

local function RemoveBBESP(p)
    local e = BBESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    BBESP[p] = nil
end

local function HideBBESP(p)
    local e = BBESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function UpdateBBESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(BBESP) do HideBBESP(p) end
        return
    end
    
    local now = tick()
    if now - BBLastESP < 0.08 then return end
    BBLastESP = now
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    local active = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true
        
        local isTm = false
        pcall(function()
            isTm = player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team
        end)
        
        if Config.ESP.TeamCheck and isTm then
            HideBBESP(player)
            continue
        end
        
        if not BBESP[player] then CreateBBESP(player) end
        local esp = BBESP[player]
        if not esp then continue end
        
        local c = player.Character
        if not c then HideBBESP(player) continue end
        if not IsBBAlive(player) then HideBBESP(player) continue end
        if c:FindFirstChildOfClass("ForceField") then HideBBESP(player) continue end
        
        local rp = c:FindFirstChild("HumanoidRootPart")
            or c:FindFirstChild("UpperTorso")
            or c:FindFirstChild("Torso")
        local head = c:FindFirstChild("Head")
        
        if not rp then HideBBESP(player) continue end
        
        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideBBESP(player) continue end
        
        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideBBESP(player) continue end
        
        -- Box sizing
        local hSP = head and Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0)) or sp
        local fSP = Camera:WorldToViewportPoint(rp.Position - Vector3.new(0, 3, 0))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width = height / 2
        local minX, minY = sp.X - width / 2, hSP.Y
        
        -- Color: visibility based
        local col
        if isTm then
            col = Color3.fromRGB(80, 150, 255)
        else
            local visTarget = head or rp
            local isVis = IsBBVisible(visTarget)
            col = isVis and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        end
        
        -- Boxes
        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, minY - 1)
            esp.Outline.Visible = true
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, minY)
            esp.Box.Color = col
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end
        
        -- Name
        if Config.ESP.Names then
            esp.Name.Text = player.DisplayName or player.Name
            esp.Name.Position = Vector2.new(minX + width / 2, minY - 16)
            esp.Name.Color = col
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        -- Distance
        if Config.ESP.Distance then
            esp.Distance.Text = math.floor(dist) .. "m"
            esp.Distance.Position = Vector2.new(minX + width / 2, minY + height + 2)
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end
        
        -- Health bar (multi-method)
        local hp, maxHp = GetBBHealth(player)
        if Config.ESP.Boxes and hp and maxHp and maxHp > 0 then
            local pct = math.clamp(hp / maxHp, 0, 1)
            local bh = height * pct
            local hc
            if pct > 0.5 then
                hc = Color3.fromRGB(math.floor(255 * (1 - pct) * 2), 255, 0)
            else
                hc = Color3.fromRGB(255, math.floor(255 * pct * 2), 0)
            end
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, minY)
            esp.HealthBG.Visible = true
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, minY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end
    
    -- Cleanup
    for p in pairs(BBESP) do
        if not active[p] then
            if not p.Parent then RemoveBBESP(p) else HideBBESP(p) end
        end
    end
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    -- Silent aim target update
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentBBTarget = GetClosestBBTarget()
    else
        CurrentBBTarget = nil
    end
    
    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local t = GetBBAimbotTarget()
        if t then
            local pos = t.Position
            pcall(function()
                if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                    local v = t.AssemblyLinearVelocity
                    if v and v.Magnitude > 0.5 then
                        pos = pos + v * Config.Aimbot.Prediction
                    end
                end
            end)
            
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    local d = math.sqrt(dx * dx + dy * dy)
                    if d > 1 then
                        local spd = math.clamp(1 / sm, 0.05, 0.8)
                        -- Dynamic smoothing
                        if d > 150 then spd = spd * 0.5
                        elseif d > 50 then spd = spd * 0.8
                        elseif d < 15 then spd = spd * 1.4 end
                        local mx = math.clamp(dx * spd, -150, 150)
                        local my = math.clamp(dy * spd, -150, 150)
                        if math.abs(mx) > 0.2 or math.abs(my) > 0.2 then
                            mousemoverel(mx, my)
                        end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then bbAimbotLocked = nil end
        end
    else
        if not Config.Aimbot.Active then bbAimbotLocked = nil end
    end
end)

RunService.Heartbeat:Connect(function()
    UpdateBBESP()
end)

-- ============================================
-- SIGNALS + INIT
-- ============================================
getgenv().AX_BBLoaded = true
getgenv().AX_BBHandlesAimbot = true
getgenv().AX_BBHandlesESP = true

for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then CreateBBESP(p) end
end
Players.PlayerAdded:Connect(function(p) CreateBBESP(p) end)
Players.PlayerRemoving:Connect(function(p)
    if bbAimbotLocked == p then bbAimbotLocked = nil end
    RemoveBBESP(p)
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentBBTarget = nil
    bbAimbotLocked = nil
    
    -- Re-scan after respawn
    task.wait(3)
    ScanForShootingRemotes()
    if not BB_FireHooked then
        ScanForProjectileHandler()
    end
end)

local hookStatus = BB_FireHooked and "ProjectileHandler hooked" or "__namecall fallback"
print("  ✅ BAD BUSINESS v2.0 - Silent Aim (" .. hookStatus .. ")")
print("  ✅ BAD BUSINESS v2.0 - Aimbot (dynamic smooth)")
print("  ✅ BAD BUSINESS v2.0 - ESP (multi-health detection)")
print("  ✅ BAD BUSINESS v2.0 - AC Bypass + artificial spread")
