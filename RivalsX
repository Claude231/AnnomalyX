--[[
    ANNOMALY X - Rivals Module v3.3
    
    Cambios v3.3:
    - Pipeline hook: return nil (no task.wait 9e9)
    - Monitor continuo con pipeline rescan + full keys
    - Silent Aim con predicci칩n de velocidad
    - Silent Aim limitado por 치ngulo m치ximo (server validation)
    - Humanizaci칩n de impactos (offset aleatorio en hitbox)
    - Remote hook modifica Vector3 + CFrame + tablas nested
    - Rate limit en modificaciones de raycast
    - Kick hook incluye variante lowercase
    - No duplica kick hook si main script ya lo hizo
    - Assertion checks al inicio
    - SafeToString contra __tostring traps
    - Sin print statements
    - Sin LogService.MessageOut hook (causa freeze)
    
    Creator: ElSacaLeche
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

-- ============================================
-- ASSERTION CHECKS
-- ============================================
local _missing = {}
local function _check(name, ref)
    if not ref then table.insert(_missing, name) end
    return ref
end

local cloneref = _check("cloneref", cloneref) or function(o) return o end
local newcclosure = _check("newcclosure", newcclosure) or function(f) return f end
local hookfunction = _check("hookfunction", hookfunction or replaceclosure or detour_function)
local hookmetamethod = _check("hookmetamethod", hookmetamethod)
local getnamecallmethod = _check("getnamecallmethod", getnamecallmethod or get_namecall_method)
local checkcaller = checkcaller or function() return false end
local getconnections = getconnections
local getgc = getgc
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

-- Critical functions check
if not hookfunction or not hookmetamethod or not getnamecallmethod then
    return
end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ============================================
-- CONSTANTS
-- ============================================
local MAX_SILENT_ANGLE_DEG = 15
local HITBOX_OFFSET_SCALE = 0.3
local MIN_SHOT_INTERVAL = 0.06

local _lastShotModified = 0

-- ============================================
-- AC KEY LIST (centralized)
-- ============================================
local _acKeys = {
    "__acsignature", "__checksum", "__hash",
    "__integrity", "__validation", "__exploit_flag",
    "_ac_token", "_security_hash", "__anticheat",
    "__detect", "__banflag"
}

-- ============================================
-- SAFE TOSTRING (avoid __tostring traps)
-- ============================================
local function SafeToString(obj)
    if obj == nil then return "nil" end
    local ok, mt = pcall(getmetatable, obj)
    if ok and mt then
        local ok2, ts = pcall(rawget, mt, "__tostring")
        if ok2 and ts then return "[protected]" end
    end
    local ok3, result = pcall(tostring, obj)
    return ok3 and result or "[error]"
end

-- ============================================
-- PHASE 1: AC BYPASS
-- ============================================
local function DisableRivalsAC()
    local results = {pipeline = 0, remotes = 0, errors = 0, kick = false, memory = 0}

    -- 1. AnalyticsPipelineController via getgc
    pcall(function()
        if not getgc then return end
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" then
                local ok, src = pcall(debug.info, v, "s")
                if ok and type(src) == "string" and src:find("AnalyticsPipelineController") then
                    pcall(function()
                        hookfunction(v, newcclosure(function()
                            return nil
                        end))
                        results.pipeline = results.pipeline + 1
                    end)
                end
            end
        end
    end)

    -- 2. AnalyticsPipeline RemoteEvent connections
    pcall(function()
        if not getconnections then return end
        local remotes = ReplicatedStorage:FindFirstChild("Remotes")
        if not remotes then return end
        local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
        if not pipeline then return end
        local re = pipeline:FindFirstChild("RemoteEvent")
        if not re then return end
        if re.OnClientEvent then
            for _, conn in pairs(getconnections(re.OnClientEvent)) do
                if conn and conn.Function then
                    pcall(function()
                        hookfunction(conn.Function, newcclosure(function() end))
                        results.remotes = results.remotes + 1
                    end)
                end
            end
        end
    end)

    -- 3. ScriptContext.Error - Disable connections (safe method)
    pcall(function()
        if not getconnections then return end
        local SC = cloneref(game:GetService("ScriptContext"))
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function()
                conn:Disable()
                results.errors = results.errors + 1
            end)
        end
    end)

    -- 4. Kick protection (both cases, skip if main already did it)
    if not getgenv()._AX_KickHooked then
        pcall(function()
            for _, kickName in ipairs({"Kick", "kick"}) do
                local fn = LocalPlayer[kickName]
                if typeof(fn) == "function" then
                    local oldKick = fn
                    hookfunction(fn, newcclosure(function(self, ...)
                        if self == LocalPlayer then return end
                        return oldKick(self, ...)
                    end))
                end
            end
            getgenv()._AX_KickHooked = true
            results.kick = true
        end)
    end

    -- 5. Memory signature cleanup
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    for _, k in ipairs(_acKeys) do
                        if rawget(obj, k) then
                            rawset(obj, k, nil)
                            results.memory = results.memory + 1
                        end
                    end
                end)
            end
        end
    end)

    return results
end

local acResults = DisableRivalsAC()

-- Continuous AC monitor
task.spawn(function()
    while true do
        task.wait(10 + math.random() * 5)
        pcall(function()
            -- Re-check pipeline connections
            pcall(function()
                if not getconnections then return end
                local remotes = ReplicatedStorage:FindFirstChild("Remotes")
                if not remotes then return end
                local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
                if not pipeline then return end
                local re = pipeline:FindFirstChild("RemoteEvent")
                if not re then return end
                if re.OnClientEvent then
                    for _, conn in pairs(getconnections(re.OnClientEvent)) do
                        pcall(function()
                            hookfunction(conn.Function, newcclosure(function() end))
                        end)
                    end
                end
            end)

            -- Re-scan getgc for new pipeline functions
            pcall(function()
                if not getgc then return end
                for _, v in pairs(getgc(true)) do
                    if typeof(v) == "function" then
                        local ok, src = pcall(debug.info, v, "s")
                        if ok and type(src) == "string" and src:find("AnalyticsPipelineController") then
                            pcall(function()
                                hookfunction(v, newcclosure(function() return nil end))
                            end)
                        end
                    end
                end
            end)

            -- Re-disable error connections
            pcall(function()
                if not getconnections then return end
                local SC = cloneref(game:GetService("ScriptContext"))
                for _, conn in ipairs(getconnections(SC.Error)) do
                    pcall(function() conn:Disable() end)
                end
            end)

            -- Full key cleanup
            pcall(function()
                if not getgc then return end
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            for _, k in ipairs(_acKeys) do
                                if rawget(obj, k) then rawset(obj, k, nil) end
                            end
                        end)
                    end
                end
            end)
        end)
    end
end)

-- ============================================
-- TEAM CHECK
-- ============================================
local function IsRivalsTeammate(player)
    if not player or player == LocalPlayer then return false end
    local ok, result = pcall(function()
        return LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team
    end)
    if ok and result then return true end
    local ok2, result2 = pcall(function()
        return LocalPlayer.TeamColor and player.TeamColor and LocalPlayer.TeamColor == player.TeamColor
    end)
    if ok2 and result2 then return true end
    return false
end

local function ShouldSkipRivalsPlayer(player, teamCheckEnabled)
    if not teamCheckEnabled then return false end
    if not player or player == LocalPlayer then return false end
    return IsRivalsTeammate(player)
end

-- ============================================
-- VISIBILITY CHECK
-- ============================================
local function IsRivalsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}
    params.IgnoreWater = true
    local origin = cam.CFrame.Position
    local dir = targetPart.Position - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetPart.Parent) then return true end
    for _, offset in ipairs({Vector3.new(0, 0.3, 0), Vector3.new(0, -0.3, 0)}) do
        local oPos = targetPart.Position + offset
        local oDir = oPos - origin
        local oResult = Workspace:Raycast(origin, oDir.Unit * (oDir.Magnitude - 0.3), params)
        if not oResult then return true end
        if oResult.Instance and oResult.Instance:IsDescendantOf(targetPart.Parent) then return true end
    end
    return false
end

-- ============================================
-- ANGLE CHECK (server validation compliance)
-- ============================================
local function GetAngleToTarget(origin, currentDirection, targetPos)
    local toTarget = (targetPos - origin).Unit
    local currentDir = currentDirection.Unit
    local dot = currentDir:Dot(toTarget)
    dot = math.clamp(dot, -1, 1)
    return math.deg(math.acos(dot))
end

-- ============================================
-- HUMANIZATION (random offset within hitbox)
-- ============================================
local function HumanizeTargetPos(targetPos, targetPart)
    if not targetPart then return targetPos end
    local size = targetPart.Size
    local scale = HITBOX_OFFSET_SCALE
    local offset = Vector3.new(
        (math.random() - 0.5) * size.X * scale,
        (math.random() - 0.5) * size.Y * scale,
        (math.random() - 0.5) * size.Z * scale
    )
    return targetPos + offset
end

-- ============================================
-- TARGET PART
-- ============================================
local RIVALS_PARTS = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}
local rivalsRandomPart = "Head"
local rivalsRandomSwitch = 0

local function GetRivalsTargetPart(character, setting)
    if not character then return nil end
    if setting == "Random" then
        local t = tick()
        if t - rivalsRandomSwitch > 0.5 then
            local valid = {}
            for _, n in ipairs(RIVALS_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then rivalsRandomPart = valid[math.random(1, #valid)] end
            rivalsRandomSwitch = t
        end
        local p = character:FindFirstChild(rivalsRandomPart)
        if p and p:IsA("BasePart") then return p end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

-- ============================================
-- SILENT AIM TARGET (with prediction + angle limit)
-- ============================================
local CurrentRivalsTarget = nil
local CurrentRivalsTargetPos = nil
local CurrentRivalsTargetPart = nil

local function GetClosestRivalsTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil, nil, nil end
    local closest, closestDist, closestPos, closestPart = nil, Config.FOV.Enabled and Config.FOV.Radius or math.huge, nil, nil
    local mousePos = UserInputService:GetMouseLocation()
    local camCF = Camera.CFrame

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if ShouldSkipRivalsPlayer(player, Config.Silent.TeamCheck) then continue end
        local c = player.Character
        if not c then continue end
        local h = c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 then continue end
        if c:FindFirstChildOfClass("ForceField") then continue end
        local tp = GetRivalsTargetPart(c, Config.Silent.TargetPart)
        if not tp then continue end
        if Config.Silent.VisibleCheck and not IsRivalsVisible(tp) then continue end

        -- Apply prediction
        local pos = tp.Position
        pcall(function()
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                local vel = tp.AssemblyLinearVelocity
                if vel and vel.Magnitude > 0.5 then
                    pos = pos + vel * Config.Aimbot.Prediction
                end
            end
        end)

        -- Check angle deviation from current aim
        local angle = GetAngleToTarget(camCF.Position, camCF.LookVector, pos)
        if angle > MAX_SILENT_ANGLE_DEG then continue end

        local sp, on = Camera:WorldToViewportPoint(pos)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if d < closestDist then
            closestDist = d
            closest = tp
            closestPos = pos
            closestPart = tp
        end
    end
    return closest, closestPos, closestPart
end

-- ============================================
-- AIMBOT TARGET
-- ============================================
local rivalsAimbotLocked = nil
local rivalsAimbotRandom = "Head"
local rivalsAimbotSwitch = 0

local function GetRivalsAimbotPart(character)
    if not character then return nil end
    local s = Config.Aimbot.TargetPart
    if s == "Random" then
        local t = tick()
        if t - rivalsAimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(RIVALS_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then rivalsAimbotRandom = valid[math.random(1, #valid)] end
            rivalsAimbotSwitch = t
        end
        local p = character:FindFirstChild(rivalsAimbotRandom)
        if p and p:IsA("BasePart") then return p end
    end
    return character:FindFirstChild(s)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

local function IsRivalsPlayerValid(player)
    if not player or not player.Parent then return false end
    if player == LocalPlayer then return false end
    if ShouldSkipRivalsPlayer(player, Config.Aimbot.TeamCheck) then return false end
    local c = player.Character
    if not c then return false end
    if c:FindFirstChildOfClass("ForceField") then return false end
    local h = c:FindFirstChildOfClass("Humanoid")
    return h and h.Health > 0
end

local function GetRivalsAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local center = Vector2.new(vp.X / 2, vp.Y / 2)
    local mousePos = UserInputService:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos

    if Config.Aimbot.Method == "Aimlock" and rivalsAimbotLocked then
        if IsRivalsPlayerValid(rivalsAimbotLocked) then
            local tp = GetRivalsAimbotPart(rivalsAimbotLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsRivalsVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        rivalsAimbotLocked = nil
    end

    local best, bestDist, bestP = nil, fov, nil
    for _, player in ipairs(Players:GetPlayers()) do
        if not IsRivalsPlayerValid(player) then continue end
        local tp = GetRivalsAimbotPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsRivalsVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d best = tp bestP = player end
    end
    if Config.Aimbot.Method == "Aimlock" and bestP then rivalsAimbotLocked = bestP end
    return best
end

-- ============================================
-- SHOOTING REMOTE DETECTION
-- ============================================
local ShootingRemotes = {}
local RemoteScanDone = false

local function ScanForShootingRemotes()
    if RemoteScanDone then return end
    pcall(function()
        for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
            if remote:IsA("RemoteEvent") then
                local name = remote.Name:lower()
                if name:find("shoot") or name:find("fire") or name:find("hit")
                   or name:find("damage") or name:find("attack") or name:find("bullet")
                   or name:find("weapon") or name:find("projectile") then
                    ShootingRemotes[remote] = true
                end
            end
        end
    end)
    RemoteScanDone = true
end

task.delay(3, ScanForShootingRemotes)

-- ============================================
-- HELPER: Direction detection
-- ============================================
local function IsLikelyDirection(v3, origin)
    if typeof(v3) ~= "Vector3" then return false end
    local mag = v3.Magnitude
    if mag < 0.1 or mag > 5000 then return false end
    if origin and typeof(origin) == "Vector3" then
        if (v3.Unit - origin.Unit).Magnitude < 0.01 then return false end
    end
    return true
end

-- ============================================
-- __namecall HOOK (Silent Aim)
-- Server-validated, humanized, angle-limited
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if checkcaller() then return oldNamecall(self, ...) end

    if Config.Silent.Enabled and Config.Silent.Active
       and CurrentRivalsTarget and CurrentRivalsTarget.Parent
       and CurrentRivalsTargetPos then

        -- HitChance check
        if math.random(1, 100) > Config.Silent.HitChance then
            return oldNamecall(self, ...)
        end

        -- Rate limit modifications
        local now = tick()
        if now - _lastShotModified < MIN_SHOT_INTERVAL then
            return oldNamecall(self, ...)
        end

        -- Humanize target position
        local targetPos = HumanizeTargetPos(CurrentRivalsTargetPos, CurrentRivalsTargetPart)

        -- Raycast hooks
        if self == Workspace or self == workspace then
            if method == "Raycast" then
                local o, d = args[1], args[2]
                if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                    -- Verify angle is within server tolerance
                    local angle = GetAngleToTarget(o, d, targetPos)
                    if angle <= MAX_SILENT_ANGLE_DEG then
                        _lastShotModified = now
                        local newDir = (targetPos - o).Unit * d.Magnitude
                        local newArgs = {o, newDir}
                        for i = 3, #args do newArgs[i] = args[i] end
                        return oldNamecall(self, unpack(newArgs))
                    end
                end
            end
            if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local angle = GetAngleToTarget(ray.Origin, ray.Direction, targetPos)
                    if angle <= MAX_SILENT_ANGLE_DEG then
                        _lastShotModified = now
                        args[1] = Ray.new(ray.Origin, (targetPos - ray.Origin).Unit * ray.Direction.Magnitude)
                        return oldNamecall(self, unpack(args))
                    end
                end
            end
        end

        -- Remote interception (handle CFrame + Vector3 + nested tables)
        if self:IsA("RemoteEvent") and method == "FireServer" then
            if ShootingRemotes[self] then
                local modified = false
                local foundOrigin = nil

                -- First pass: find origin
                for i, arg in ipairs(args) do
                    if typeof(arg) == "Vector3" and arg.Magnitude > 10 then
                        foundOrigin = arg break
                    end
                    if typeof(arg) == "CFrame" then
                        foundOrigin = arg.Position break
                    end
                end

                -- Second pass: modify aim data
                for i, arg in ipairs(args) do
                    if typeof(arg) == "CFrame" then
                        local angle = GetAngleToTarget(arg.Position, arg.LookVector, targetPos)
                        if angle <= MAX_SILENT_ANGLE_DEG then
                            args[i] = CFrame.new(arg.Position, targetPos)
                            modified = true
                        end
                    elseif typeof(arg) == "Vector3" and foundOrigin then
                        if IsLikelyDirection(arg, foundOrigin) and arg ~= foundOrigin then
                            local angle = GetAngleToTarget(foundOrigin, arg, targetPos)
                            if angle <= MAX_SILENT_ANGLE_DEG then
                                args[i] = (targetPos - foundOrigin).Unit * arg.Magnitude
                                modified = true
                            end
                        end
                    elseif type(arg) == "table" then
                        pcall(function()
                            for k, v in pairs(arg) do
                                if typeof(v) == "CFrame" then
                                    local angle = GetAngleToTarget(v.Position, v.LookVector, targetPos)
                                    if angle <= MAX_SILENT_ANGLE_DEG then
                                        arg[k] = CFrame.new(v.Position, targetPos)
                                        modified = true
                                    end
                                end
                            end
                        end)
                    end
                end

                if modified then
                    _lastShotModified = now
                    return oldNamecall(self, unpack(args))
                end
            end
        end
    end

    return oldNamecall(self, ...)
end))

-- ============================================
-- ESP
-- ============================================
local RivalsESP = {}
local RivalsLastESP = 0

local function CreateRivalsESP(player)
    if RivalsESP[player] then return end
    local e = {}
    e.Box = Drawing.new("Square") e.Box.Thickness = 1 e.Box.Filled = false e.Box.Visible = false
    e.Outline = Drawing.new("Square") e.Outline.Thickness = 3 e.Outline.Filled = false e.Outline.Color = Color3.fromRGB(0,0,0) e.Outline.Transparency = 0.5 e.Outline.Visible = false
    e.Name = Drawing.new("Text") e.Name.Size = 13 e.Name.Center = true e.Name.Outline = true e.Name.Color = Color3.fromRGB(255,255,255) e.Name.Visible = false
    e.Distance = Drawing.new("Text") e.Distance.Size = 12 e.Distance.Center = true e.Distance.Outline = true e.Distance.Color = Color3.fromRGB(200,200,200) e.Distance.Visible = false
    e.HealthBG = Drawing.new("Square") e.HealthBG.Thickness = 1 e.HealthBG.Filled = true e.HealthBG.Color = Color3.fromRGB(0,0,0) e.HealthBG.Transparency = 0.5 e.HealthBG.Visible = false
    e.HealthBar = Drawing.new("Square") e.HealthBar.Thickness = 1 e.HealthBar.Filled = true e.HealthBar.Color = Color3.fromRGB(0,255,0) e.HealthBar.Visible = false
    RivalsESP[player] = e
end

local function RemoveRivalsESP(p)
    local e = RivalsESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    RivalsESP[p] = nil
end

local function HideRivalsESP(p)
    local e = RivalsESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function UpdateRivalsESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(RivalsESP) do HideRivalsESP(p) end
        return
    end

    local now = tick()
    if now - RivalsLastESP < 0.08 then return end
    RivalsLastESP = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    local active = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true

        local isTm = IsRivalsTeammate(player)

        if Config.ESP.TeamCheck and isTm then
            HideRivalsESP(player)
            continue
        end

        if not RivalsESP[player] then CreateRivalsESP(player) end
        local esp = RivalsESP[player]
        if not esp then continue end

        local c = player.Character
        if not c then HideRivalsESP(player) continue end
        local h = c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 then HideRivalsESP(player) continue end
        if c:FindFirstChildOfClass("ForceField") then HideRivalsESP(player) continue end

        local rp = c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso")
        local head = c:FindFirstChild("Head")

        if not rp then HideRivalsESP(player) continue end

        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideRivalsESP(player) continue end

        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideRivalsESP(player) continue end

        local hSP = head and Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0)) or sp
        local fSP = Camera:WorldToViewportPoint(rp.Position - Vector3.new(0, 3, 0))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width = height / 2
        local minX, minY = sp.X - width / 2, hSP.Y

        local col
        if isTm then
            col = Color3.fromRGB(80, 150, 255)
        else
            local isVis = head and IsRivalsVisible(head) or false
            col = isVis and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        end

        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, minY - 1)
            esp.Outline.Visible = true
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, minY)
            esp.Box.Color = col
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end

        if Config.ESP.Names then
            esp.Name.Text = player.DisplayName or player.Name
            esp.Name.Position = Vector2.new(minX + width / 2, minY - 16)
            esp.Name.Color = col
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end

        if Config.ESP.Distance then
            esp.Distance.Text = math.floor(dist) .. "m"
            esp.Distance.Position = Vector2.new(minX + width / 2, minY + height + 2)
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end

        if Config.ESP.Boxes and h then
            local pct = math.clamp(h.Health / h.MaxHealth, 0, 1)
            local bh = height * pct
            local hc
            if pct > 0.5 then
                hc = Color3.fromRGB(math.floor(255 * (1 - pct) * 2), 255, 0)
            else
                hc = Color3.fromRGB(255, math.floor(255 * pct * 2), 0)
            end
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, minY)
            esp.HealthBG.Visible = true
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, minY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end

    -- Cleanup disconnected players
    for p in pairs(RivalsESP) do
        if not active[p] then
            if not p.Parent then RemoveRivalsESP(p) else HideRivalsESP(p) end
        end
    end
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera

    -- Silent aim target with prediction + angle limit
    if Config.Silent.Enabled and Config.Silent.Active then
        local target, predictedPos, targetPart = GetClosestRivalsTarget()
        CurrentRivalsTarget = target
        CurrentRivalsTargetPos = predictedPos
        CurrentRivalsTargetPart = targetPart
    else
        CurrentRivalsTarget = nil
        CurrentRivalsTargetPos = nil
        CurrentRivalsTargetPart = nil
    end

    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local t = GetRivalsAimbotTarget()
        if t then
            local pos = t.Position
            pcall(function()
                if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                    local v = t.AssemblyLinearVelocity
                    if v and v.Magnitude > 0.5 then pos = pos + v * Config.Aimbot.Prediction end
                end
            end)
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    local d = math.sqrt(dx * dx + dy * dy)
                    if d > 1 then
                        local spd = math.clamp(1 / sm, 0.05, 0.8)
                        if d > 150 then spd = spd * 0.6
                        elseif d < 20 then spd = spd * 1.3 end
                        local mx = math.clamp(dx * spd, -150, 150)
                        local my = math.clamp(dy * spd, -150, 150)
                        if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then mousemoverel(mx, my) end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then rivalsAimbotLocked = nil end
        end
    else
        if not Config.Aimbot.Active then rivalsAimbotLocked = nil end
    end
end)

RunService.Heartbeat:Connect(function()
    UpdateRivalsESP()
end)

-- ============================================
-- INIT + CLEANUP
-- ============================================
local _f = getgenv()
_f.AX_RivalsLoaded = true
_f.AX_RivalsHandlesAimbot = true
_f.AX_RivalsHandlesESP = true

for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then CreateRivalsESP(p) end
end
Players.PlayerAdded:Connect(function(p)
    CreateRivalsESP(p)
    RemoteScanDone = false
    task.delay(2, ScanForShootingRemotes)
end)
Players.PlayerRemoving:Connect(function(p)
    if rivalsAimbotLocked == p then rivalsAimbotLocked = nil end
    RemoveRivalsESP(p)
end)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentRivalsTarget = nil
    CurrentRivalsTargetPos = nil
    CurrentRivalsTargetPart = nil
    rivalsAimbotLocked = nil
    task.wait(2)
    pcall(DisableRivalsAC)
    RemoteScanDone = false
    task.delay(1, ScanForShootingRemotes)
end)
