--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║          ANNOMALY X - Rivals Module v2                     ║
    ║          Enhanced AC Bypass + Bypassel Integration         ║
    ║          Creator: ElSacaLeche                              ║
    ╚═══════════════════════════════════════════════════════════╝
]]

-- Wait for Config
if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getconnections = getconnections
local getgc = getgc
local setreadonly = setreadonly or function() end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local LogService = cloneref(game:GetService("LogService"))
local ScriptContext = cloneref(game:GetService("ScriptContext"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- PHASE 1: RIVALS ANTICHEAT DISABLER
-- Combines original Rivals AC disable + Bypassel
-- ============================================
local function DisableRivalsAC()
    local results = {
        pipelineFunctions = 0,
        remoteConnections = 0,
        messageOutHooks = 0,
        errorConnections = 0,
        kickHooked = false,
        handshakes = 0,
        memoryPatches = 0,
        integrityBypasses = 0,
        signaturesCleaned = 0
    }
    
    -- ORIGINAL RIVALS METHOD: AnalyticsPipelineController
    task.spawn(function()
        pcall(function()
            for _, v in pairs(getgc(true)) do
                if typeof(v) == "function" then
                    local ok, src = pcall(function()
                        return debug.info(v, "s")
                    end)
                    if ok and type(src) == "string" and string.find(src, "AnalyticsPipelineController") then
                        results.pipelineFunctions = results.pipelineFunctions + 1
                        hookfunction(v, newcclosure(function(...)
                            return task.wait(9e9)
                        end))
                    end
                end
            end
        end)
    end)
    
    -- ORIGINAL: AnalyticsPipeline RemoteEvent
    task.spawn(function()
        pcall(function()
            local remotes = ReplicatedStorage:WaitForChild("Remotes", 5)
            if not remotes then return end
            local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
            if not pipeline then return end
            local remoteEvent = pipeline:FindFirstChild("RemoteEvent")
            if not remoteEvent then return end
            if remoteEvent.OnClientEvent then
                for _, conn in pairs(getconnections(remoteEvent.OnClientEvent)) do
                    if conn and conn.Function then
                        pcall(function()
                            hookfunction(conn.Function, newcclosure(function(...) end))
                            results.remoteConnections = results.remoteConnections + 1
                        end)
                    end
                end
            end
        end)
    end)
    
    -- ORIGINAL: MessageOut hooks
    task.spawn(function()
        pcall(function()
            for _, conn in pairs(getconnections(LogService.MessageOut)) do
                if conn and conn.Function then
                    pcall(function()
                        hookfunction(conn.Function, newcclosure(function(...) end))
                        results.messageOutHooks = results.messageOutHooks + 1
                    end)
                end
            end
        end)
    end)
    
    -- ORIGINAL: Error connections
    task.spawn(function()
        pcall(function()
            for _, conn in ipairs(getconnections(ScriptContext.Error)) do
                pcall(function()
                    conn:Disable()
                    results.errorConnections = results.errorConnections + 1
                end)
            end
            pcall(function()
                hookfunction(ScriptContext.Error.Connect, newcclosure(function(...)
                    return nil
                end))
            end)
        end)
    end)
    
    -- ORIGINAL: Kick protection
    task.spawn(function()
        pcall(function()
            local kickNames = {"Kick", "kick"}
            for _, name in ipairs(kickNames) do
                local fn = LocalPlayer[name]
                if type(fn) == "function" then
                    local oldKick
                    oldKick = hookfunction(fn, newcclosure(function(self, ...)
                        if self == LocalPlayer then return end
                        return oldKick(self, ...)
                    end))
                    results.kickHooked = true
                end
            end
        end)
    end)
    
    -- BYPASSEL: Handshake bypass
    task.spawn(function()
        pcall(function()
            for _, remote in pairs(ReplicatedStorage:GetDescendants()) do
                if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                    local name = remote.Name:lower()
                    if name:find("handshake") or name:find("validate") or name:find("verify") then
                        if remote:IsA("RemoteEvent") and remote.OnClientEvent then
                            for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                                pcall(function() conn:Disable() end)
                                results.handshakes = results.handshakes + 1
                            end
                        end
                    end
                end
            end
        end)
    end)
    
    -- BYPASSEL: Memory cleanup
    task.spawn(function()
        pcall(function()
            if getgc then
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            local acKeys = {"__acsignature", "__checksum", "__hash", "__integrity", "__validation"}
                            for _, key in ipairs(acKeys) do
                                if rawget(obj, key) then
                                    rawset(obj, key, nil)
                                    results.memoryPatches = results.memoryPatches + 1
                                end
                            end
                        end)
                    end
                end
            end
        end)
    end)
    
    -- BYPASSEL: Integrity checks
    task.spawn(function()
        pcall(function()
            if getconnections then
                pcall(function()
                    for _, conn in ipairs(getconnections(ScriptContext.ScriptAdded)) do
                        pcall(function() conn:Disable() end)
                        results.integrityBypasses = results.integrityBypasses + 1
                    end
                end)
                pcall(function()
                    for _, conn in ipairs(getconnections(ScriptContext.ScriptRemoved)) do
                        pcall(function() conn:Disable() end)
                        results.integrityBypasses = results.integrityBypasses + 1
                    end
                end)
            end
        end)
    end)
    
    -- BYPASSEL: Signature cleanup
    task.spawn(function()
        pcall(function()
            local sigKeys = {"signature", "checksum", "hash", "exploit", "cheat"}
            for key, _ in pairs(_G) do
                local keyStr = tostring(key):lower()
                for _, sigKey in ipairs(sigKeys) do
                    if keyStr:find(sigKey) then
                        _G[key] = nil
                        results.signaturesCleaned = results.signaturesCleaned + 1
                        break
                    end
                end
            end
        end)
    end)
    
    task.wait(0.5)
    return results
end

-- Execute AC disabler
local acResults = DisableRivalsAC()
print("  ✅ RIVALS AC v2 DISABLED:")
print("    Pipeline functions hanged: " .. acResults.pipelineFunctions)
print("    Remote connections hooked: " .. acResults.remoteConnections)
print("    MessageOut hooks: " .. acResults.messageOutHooks)
print("    Error connections: " .. acResults.errorConnections)
print("    Kick hooked: " .. tostring(acResults.kickHooked))
print("    Handshakes blocked: " .. acResults.handshakes)
print("    Memory patches: " .. acResults.memoryPatches)
print("    Integrity bypasses: " .. acResults.integrityBypasses)
print("    Signatures cleaned: " .. acResults.signaturesCleaned)

-- ============================================
-- PHASE 2: CONTINUOUS AC MONITOR
-- ============================================
task.spawn(function()
    while task.wait(8) do
        pcall(function()
            -- Re-check for new AC remotes
            pcall(function()
                local remotes = ReplicatedStorage:FindFirstChild("Remotes")
                if remotes then
                    local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
                    if pipeline then
                        local re = pipeline:FindFirstChild("RemoteEvent")
                        if re and re.OnClientEvent then
                            for _, conn in pairs(getconnections(re.OnClientEvent)) do
                                pcall(function()
                                    hookfunction(conn.Function, newcclosure(function(...) end))
                                end)
                            end
                        end
                    end
                end
            end)
            
            -- Re-disable errors
            pcall(function()
                for _, conn in ipairs(getconnections(ScriptContext.Error)) do
                    pcall(function() conn:Disable() end)
                end
            end)
            
            -- Clean memory signatures
            if getgc then
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            if rawget(obj, "__acsignature") then rawset(obj, "__acsignature", nil) end
                        end)
                    end
                end
            end
        end)
    end
end)

-- ============================================
-- PHASE 3: SILENT AIM
-- ============================================

local CurrentRivalsTarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, Camera}
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, targetPartSetting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if targetPartSetting == "Random" then
        local validParts = {}
        for _, partName in ipairs(parts) do
            local part = character:FindFirstChild(partName)
            if part then table.insert(validParts, part) end
        end
        if #validParts > 0 then return validParts[math.random(1, #validParts)] end
    end
    return character:FindFirstChild(targetPartSetting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

local function GetClosestRivalsTarget()
    Camera = Workspace.CurrentCamera
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local screenCenter = Camera.ViewportSize / 2
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local targetPart = GetTargetPart(character, Config.Silent.TargetPart)
        if not targetPart then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(targetPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if screenDist < closestDist then
            closestDist = screenDist
            closest = targetPart
        end
    end
    
    return closest
end

-- Target update loop
local rivalsTargetConnection = RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentRivalsTarget = GetClosestRivalsTarget()
    else
        CurrentRivalsTarget = nil
    end
end)

-- __namecall hook for Raycast redirection
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if checkcaller() then
        return oldNamecall(self, ...)
    end
    
    if Config.Silent.Enabled and Config.Silent.Active and CurrentRivalsTarget and CurrentRivalsTarget.Parent then
        if math.random(1, 100) > Config.Silent.HitChance then
            return oldNamecall(self, ...)
        end
        
        if (self == Workspace or self == workspace) then
            if method == "Raycast" then
                local origin = args[1]
                local direction = args[2]
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                    args[2] = (CurrentRivalsTarget.Position - origin).Unit * direction.Magnitude
                    return oldNamecall(self, unpack(args))
                end
            end
            
            if method == "FindPartOnRay" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local newDir = (CurrentRivalsTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                    args[1] = Ray.new(ray.Origin, newDir)
                    return oldNamecall(self, unpack(args))
                end
            end
            
            if method == "FindPartOnRayWithIgnoreList" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local newDir = (CurrentRivalsTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                    args[1] = Ray.new(ray.Origin, newDir)
                    return oldNamecall(self, unpack(args))
                end
            end
            
            if method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local newDir = (CurrentRivalsTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                    args[1] = Ray.new(ray.Origin, newDir)
                    return oldNamecall(self, unpack(args))
                end
            end
        end
        
        -- Also intercept shooting remotes
        if self:IsA("RemoteEvent") and method == "FireServer" then
            for i, arg in ipairs(args) do
                if typeof(arg) == "CFrame" then
                    args[i] = CFrame.new(arg.Position, CurrentRivalsTarget.Position)
                end
            end
            return oldNamecall(self, unpack(args))
        end
    end
    
    return oldNamecall(self, ...)
end))

-- ============================================
-- CLEANUP ON RESPAWN
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentRivalsTarget = nil
    
    -- Re-apply AC bypass after respawn
    task.wait(2)
    pcall(function() DisableRivalsAC() end)
end)

-- ============================================
-- SIGNAL
-- ============================================
getgenv().AX_RivalsLoaded = true

print("  ✅ RIVALS MODULE v2 - Enhanced AC bypass + Bypassel")
print("  ✅ RIVALS MODULE v2 - __namecall hooked (Raycast + Remotes)")
print("  ✅ RIVALS MODULE v2 - Continuous AC monitor active")
