--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║          ANNOMALY X - Rivals Module v3.1                   ║
    ║                                                           ║
    ║  FIXES v3.1:                                              ║
    ║  - Removed ScriptContext.Error.Connect hook (caused freeze)║
    ║  - Removed aggressive LogService.MessageOut hooks          ║
    ║  - AC bypass is now non-destructive                        ║
    ║  - __namecall hook is safe (main script skips Rivals)      ║
    ║                                                           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getconnections = getconnections
local getgc = getgc
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- PHASE 1: SAFE AC BYPASS
-- Non-destructive: does NOT hook .Connect or
-- block LogService (which causes freezes)
-- ============================================
local function DisableRivalsAC()
    local results = {pipeline = 0, remotes = 0, errors = 0, kick = false, memory = 0}

    -- AnalyticsPipelineController via getgc
    pcall(function()
        if not getgc then return end
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" then
                local ok, src = pcall(debug.info, v, "s")
                if ok and type(src) == "string" and src:find("AnalyticsPipelineController") then
                    pcall(function()
                        hookfunction(v, newcclosure(function(...)
                            return task.wait(9e9)
                        end))
                        results.pipeline = results.pipeline + 1
                    end)
                end
            end
        end
    end)

    -- AnalyticsPipeline RemoteEvent connections
    pcall(function()
        if not getconnections then return end
        local remotes = ReplicatedStorage:FindFirstChild("Remotes")
        if not remotes then return end
        local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
        if not pipeline then return end
        local re = pipeline:FindFirstChild("RemoteEvent")
        if not re then return end
        if re.OnClientEvent then
            for _, conn in pairs(getconnections(re.OnClientEvent)) do
                if conn and conn.Function then
                    pcall(function()
                        hookfunction(conn.Function, newcclosure(function(...) end))
                        results.remotes = results.remotes + 1
                    end)
                end
            end
        end
    end)

    -- Disable error connections (but do NOT hook .Connect itself)
    pcall(function()
        if not getconnections then return end
        local SC = cloneref(game:GetService("ScriptContext"))
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function()
                conn:Disable()
                results.errors = results.errors + 1
            end)
        end
    end)

    -- Kick protection
    pcall(function()
        local oldKick = LocalPlayer.Kick
        if typeof(oldKick) == "function" then
            hookfunction(oldKick, newcclosure(function(self, ...)
                if self == LocalPlayer then return end
                return oldKick(self, ...)
            end))
            results.kick = true
        end
    end)

    -- Memory signature cleanup
    pcall(function()
        if not getgc then return end
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    for _, k in ipairs({
                        "__acsignature", "__checksum", "__hash",
                        "__integrity", "__validation", "__exploit_flag"
                    }) do
                        if rawget(obj, k) then
                            rawset(obj, k, nil)
                            results.memory = results.memory + 1
                        end
                    end
                end)
            end
        end
    end)

    return results
end

local acResults = DisableRivalsAC()

-- Safe continuous AC monitor (no aggressive hooks)
task.spawn(function()
    while true do
        task.wait(10 + math.random() * 5)
        pcall(function()
            -- Re-check pipeline
            pcall(function()
                if not getconnections then return end
                local remotes = ReplicatedStorage:FindFirstChild("Remotes")
                if not remotes then return end
                local pipeline = remotes:FindFirstChild("AnalyticsPipeline")
                if not pipeline then return end
                local re = pipeline:FindFirstChild("RemoteEvent")
                if not re then return end
                if re.OnClientEvent then
                    for _, conn in pairs(getconnections(re.OnClientEvent)) do
                        pcall(function()
                            hookfunction(conn.Function, newcclosure(function(...) end))
                        end)
                    end
                end
            end)

            -- Re-disable errors (safe method)
            pcall(function()
                if not getconnections then return end
                local SC = cloneref(game:GetService("ScriptContext"))
                for _, conn in ipairs(getconnections(SC.Error)) do
                    pcall(function() conn:Disable() end)
                end
            end)

            -- Memory cleanup
            pcall(function()
                if not getgc then return end
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            if rawget(obj, "__acsignature") then rawset(obj, "__acsignature", nil) end
                            if rawget(obj, "__checksum") then rawset(obj, "__checksum", nil) end
                        end)
                    end
                end
            end)
        end)
    end
end)

-- ============================================
-- TEAM CHECK
-- ============================================
local function IsRivalsTeammate(player)
    if not player or player == LocalPlayer then return false end
    local ok, result = pcall(function()
        return LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team
    end)
    if ok and result then return true end
    local ok2, result2 = pcall(function()
        return LocalPlayer.TeamColor and player.TeamColor and LocalPlayer.TeamColor == player.TeamColor
    end)
    if ok2 and result2 then return true end
    return false
end

local function ShouldSkipRivalsPlayer(player, teamCheckEnabled)
    if not teamCheckEnabled then return false end
    if not player or player == LocalPlayer then return false end
    return IsRivalsTeammate(player)
end

-- ============================================
-- VISIBILITY CHECK
-- ============================================
local function IsRivalsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}
    params.IgnoreWater = true
    local origin = cam.CFrame.Position
    local dir = targetPart.Position - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetPart.Parent) then return true end
    -- Secondary rays
    for _, offset in ipairs({Vector3.new(0,0.3,0), Vector3.new(0,-0.3,0)}) do
        local oPos = targetPart.Position + offset
        local oDir = oPos - origin
        local oResult = Workspace:Raycast(origin, oDir.Unit * (oDir.Magnitude - 0.3), params)
        if not oResult then return true end
        if oResult.Instance and oResult.Instance:IsDescendantOf(targetPart.Parent) then return true end
    end
    return false
end

-- ============================================
-- TARGET PART
-- ============================================
local RIVALS_PARTS = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}
local rivalsRandomPart = "Head"
local rivalsRandomSwitch = 0

local function GetRivalsTargetPart(character, setting)
    if not character then return nil end
    if setting == "Random" then
        local t = tick()
        if t - rivalsRandomSwitch > 0.5 then
            local valid = {}
            for _, n in ipairs(RIVALS_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then rivalsRandomPart = valid[math.random(1,#valid)] end
            rivalsRandomSwitch = t
        end
        local p = character:FindFirstChild(rivalsRandomPart)
        if p and p:IsA("BasePart") then return p end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

-- ============================================
-- SILENT AIM TARGET
-- ============================================
local CurrentRivalsTarget = nil

local function GetClosestRivalsTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local closest, closestDist = nil, Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if ShouldSkipRivalsPlayer(player, Config.Silent.TeamCheck) then continue end
        local c = player.Character
        if not c then continue end
        local h = c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 then continue end
        if c:FindFirstChildOfClass("ForceField") then continue end
        local tp = GetRivalsTargetPart(c, Config.Silent.TargetPart)
        if not tp then continue end
        if Config.Silent.VisibleCheck and not IsRivalsVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if d < closestDist then closestDist = d closest = tp end
    end
    return closest
end

-- ============================================
-- AIMBOT TARGET
-- ============================================
local rivalsAimbotLocked = nil
local rivalsAimbotRandom = "Head"
local rivalsAimbotSwitch = 0

local function GetRivalsAimbotPart(character)
    if not character then return nil end
    local s = Config.Aimbot.TargetPart
    if s == "Random" then
        local t = tick()
        if t - rivalsAimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(RIVALS_PARTS) do
                local p = character:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then rivalsAimbotRandom = valid[math.random(1,#valid)] end
            rivalsAimbotSwitch = t
        end
        local p = character:FindFirstChild(rivalsAimbotRandom)
        if p and p:IsA("BasePart") then return p end
    end
    return character:FindFirstChild(s)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
end

local function IsRivalsPlayerValid(player)
    if not player or not player.Parent then return false end
    if player == LocalPlayer then return false end
    if ShouldSkipRivalsPlayer(player, Config.Aimbot.TeamCheck) then return false end
    local c = player.Character
    if not c then return false end
    if c:FindFirstChildOfClass("ForceField") then return false end
    local h = c:FindFirstChildOfClass("Humanoid")
    return h and h.Health > 0
end

local function GetRivalsAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local center = Vector2.new(vp.X / 2, vp.Y / 2)
    local mousePos = UserInputService:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos

    if Config.Aimbot.Method == "Aimlock" and rivalsAimbotLocked then
        if IsRivalsPlayerValid(rivalsAimbotLocked) then
            local tp = GetRivalsAimbotPart(rivalsAimbotLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsRivalsVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        rivalsAimbotLocked = nil
    end

    local best, bestDist, bestP = nil, fov, nil
    for _, player in ipairs(Players:GetPlayers()) do
        if not IsRivalsPlayerValid(player) then continue end
        local tp = GetRivalsAimbotPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsRivalsVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d best = tp bestP = player end
    end
    if Config.Aimbot.Method == "Aimlock" and bestP then rivalsAimbotLocked = bestP end
    return best
end

-- ============================================
-- SHOOTING REMOTE DETECTION
-- ============================================
local ShootingRemotes = {}
local RemoteScanDone = false

local function ScanForShootingRemotes()
    if RemoteScanDone then return end
    pcall(function()
        for _, remote in ipairs(ReplicatedStorage:GetDescendants()) do
            if remote:IsA("RemoteEvent") then
                local name = remote.Name:lower()
                if name:find("shoot") or name:find("fire") or name:find("hit")
                   or name:find("damage") or name:find("attack") or name:find("bullet")
                   or name:find("weapon") or name:find("projectile") then
                    ShootingRemotes[remote] = true
                end
            end
        end
    end)
    RemoteScanDone = true
end

task.delay(3, ScanForShootingRemotes)

-- ============================================
-- __namecall HOOK (Silent Aim)
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if checkcaller() then return oldNamecall(self, ...) end

    if Config.Silent.Enabled and Config.Silent.Active and CurrentRivalsTarget and CurrentRivalsTarget.Parent then
        if math.random(1, 100) <= Config.Silent.HitChance then
            local targetPos = CurrentRivalsTarget.Position

            if self == Workspace or self == workspace then
                if method == "Raycast" then
                    local o, d = args[1], args[2]
                    if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                        return oldNamecall(self, o, (targetPos - o).Unit * d.Magnitude, select(3, ...))
                    end
                end
                if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                    local ray = args[1]
                    if typeof(ray) == "Ray" then
                        args[1] = Ray.new(ray.Origin, (targetPos - ray.Origin).Unit * ray.Direction.Magnitude)
                        return oldNamecall(self, unpack(args))
                    end
                end
            end

            -- Targeted remote interception
            if self:IsA("RemoteEvent") and method == "FireServer" then
                if ShootingRemotes[self] then
                    local modified = false
                    for i, arg in ipairs(args) do
                        if typeof(arg) == "CFrame" then
                            args[i] = CFrame.new(arg.Position, targetPos)
                            modified = true
                        end
                    end
                    if modified then return oldNamecall(self, unpack(args)) end
                end
            end
        end
    end

    return oldNamecall(self, ...)
end))

-- ============================================
-- ESP
-- ============================================
local RivalsESP = {}
local RivalsLastESP = 0

local function CreateRivalsESP(player)
    if RivalsESP[player] then return end
    local e = {}
    e.Box = Drawing.new("Square") e.Box.Thickness=1 e.Box.Filled=false e.Box.Visible=false
    e.Outline = Drawing.new("Square") e.Outline.Thickness=3 e.Outline.Filled=false e.Outline.Color=Color3.fromRGB(0,0,0) e.Outline.Transparency=0.5 e.Outline.Visible=false
    e.Name = Drawing.new("Text") e.Name.Size=13 e.Name.Center=true e.Name.Outline=true e.Name.Color=Color3.fromRGB(255,255,255) e.Name.Visible=false
    e.Distance = Drawing.new("Text") e.Distance.Size=12 e.Distance.Center=true e.Distance.Outline=true e.Distance.Color=Color3.fromRGB(200,200,200) e.Distance.Visible=false
    e.HealthBG = Drawing.new("Square") e.HealthBG.Thickness=1 e.HealthBG.Filled=true e.HealthBG.Color=Color3.fromRGB(0,0,0) e.HealthBG.Transparency=0.5 e.HealthBG.Visible=false
    e.HealthBar = Drawing.new("Square") e.HealthBar.Thickness=1 e.HealthBar.Filled=true e.HealthBar.Color=Color3.fromRGB(0,255,0) e.HealthBar.Visible=false
    RivalsESP[player] = e
end
local function RemoveRivalsESP(p) local e=RivalsESP[p] if not e then return end for _,d in pairs(e) do pcall(function() d:Remove() end) end RivalsESP[p]=nil end
local function HideRivalsESP(p) local e=RivalsESP[p] if not e then return end for _,d in pairs(e) do pcall(function() d.Visible=false end) end end

local function UpdateRivalsESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(RivalsESP) do HideRivalsESP(p) end return
    end
    local now = tick() if now - RivalsLastESP < 0.08 then return end RivalsLastESP = now
    Camera = Workspace.CurrentCamera if not Camera then return end
    local active = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true
        local isTm = IsRivalsTeammate(player)
        if Config.ESP.TeamCheck and isTm then HideRivalsESP(player) continue end
        if not RivalsESP[player] then CreateRivalsESP(player) end
        local esp = RivalsESP[player] if not esp then continue end
        local c = player.Character
        if not c then HideRivalsESP(player) continue end
        local h = c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 then HideRivalsESP(player) continue end
        if c:FindFirstChildOfClass("ForceField") then HideRivalsESP(player) continue end
        local rp = c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("UpperTorso") or c:FindFirstChild("Torso")
        local head = c:FindFirstChild("Head")
        if not rp then HideRivalsESP(player) continue end
        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideRivalsESP(player) continue end
        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideRivalsESP(player) continue end
        local hSP = head and Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0)) or sp
        local fSP = Camera:WorldToViewportPoint(rp.Position - Vector3.new(0,3,0))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width = height / 2
        local minX, minY = sp.X - width/2, hSP.Y
        local col = isTm and Color3.fromRGB(80,150,255) or ((head and IsRivalsVisible(head)) and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,50,50))
        if Config.ESP.Boxes then
            esp.Outline.Size=Vector2.new(width+2,height+2) esp.Outline.Position=Vector2.new(minX-1,minY-1) esp.Outline.Visible=true
            esp.Box.Size=Vector2.new(width,height) esp.Box.Position=Vector2.new(minX,minY) esp.Box.Color=col esp.Box.Visible=true
        else esp.Box.Visible=false esp.Outline.Visible=false end
        if Config.ESP.Names then
            esp.Name.Text=player.DisplayName or player.Name esp.Name.Position=Vector2.new(minX+width/2,minY-16) esp.Name.Color=col esp.Name.Visible=true
        else esp.Name.Visible=false end
        if Config.ESP.Distance then
            esp.Distance.Text=math.floor(dist).."m" esp.Distance.Position=Vector2.new(minX+width/2,minY+height+2) esp.Distance.Visible=true
        else esp.Distance.Visible=false end
        if Config.ESP.Boxes and h then
            local pct=math.clamp(h.Health/h.MaxHealth,0,1) local bh=height*pct
            local hc=pct>0.5 and Color3.fromRGB(math.floor(255*(1-pct)*2),255,0) or Color3.fromRGB(255,math.floor(255*pct*2),0)
            esp.HealthBG.Size=Vector2.new(3,height) esp.HealthBG.Position=Vector2.new(minX-6,minY) esp.HealthBG.Visible=true
            esp.HealthBar.Size=Vector2.new(3,bh) esp.HealthBar.Position=Vector2.new(minX-6,minY+(height-bh)) esp.HealthBar.Color=hc esp.HealthBar.Visible=true
        else esp.HealthBG.Visible=false esp.HealthBar.Visible=false end
    end
    for p in pairs(RivalsESP) do if not active[p] then if not p.Parent then RemoveRivalsESP(p) else HideRivalsESP(p) end end end
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera

    -- Silent aim target
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentRivalsTarget = GetClosestRivalsTarget()
    else
        CurrentRivalsTarget = nil
    end

    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local t = GetRivalsAimbotTarget()
        if t then
            local pos = t.Position
            pcall(function()
                if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                    local v = t.AssemblyLinearVelocity
                    if v and v.Magnitude > 0.5 then pos = pos + v * Config.Aimbot.Prediction end
                end
            end)
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    local d = math.sqrt(dx*dx + dy*dy)
                    if d > 1 then
                        local spd = math.clamp(1 / sm, 0.05, 0.8)
                        if d > 150 then spd = spd * 0.6
                        elseif d < 20 then spd = spd * 1.3 end
                        local mx = math.clamp(dx * spd, -150, 150)
                        local my = math.clamp(dy * spd, -150, 150)
                        if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then mousemoverel(mx, my) end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then rivalsAimbotLocked = nil end
        end
    else
        if not Config.Aimbot.Active then rivalsAimbotLocked = nil end
    end
end)

RunService.Heartbeat:Connect(function()
    UpdateRivalsESP()
end)

-- ============================================
-- INIT + CLEANUP
-- ============================================
getgenv().AX_RivalsLoaded = true
getgenv().AX_RivalsHandlesAimbot = true
getgenv().AX_RivalsHandlesESP = true

for _, p in ipairs(Players:GetPlayers()) do if p ~= LocalPlayer then CreateRivalsESP(p) end end
Players.PlayerAdded:Connect(function(p) CreateRivalsESP(p) RemoteScanDone = false task.delay(2, ScanForShootingRemotes) end)
Players.PlayerRemoving:Connect(function(p)
    if rivalsAimbotLocked == p then rivalsAimbotLocked = nil end
    RemoveRivalsESP(p)
end)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1) Camera = Workspace.CurrentCamera CurrentRivalsTarget = nil rivalsAimbotLocked = nil
    task.wait(2) pcall(DisableRivalsAC) RemoteScanDone = false task.delay(1, ScanForShootingRemotes)
end)

print("  ✅ RIVALS v3.1 - Safe AC bypass (no freeze)")
print("  ✅ RIVALS v3.1 - Silent Aim + Aimbot + ESP")
