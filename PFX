--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Phantom Forces Module v5.0            ║
    ║                                                           ║
    ║  Ronix Compatible - No network hooks needed               ║
    ║  ESP: Part-position tracking via DescendantAdded          ║
    ║  Aimbot: Camera CFrame + mousemoverel                     ║
    ║  Hitbox: Enemy model expansion                            ║
    ║                                                           ║
    ║  NOTE: Silent Aim is NOT possible on Ronix executor       ║
    ║  because PF runs inside Actors which bypass all hooks.    ║
    ║  Use Aimbot + Hitbox Expansion as alternative.            ║
    ║                                                           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local PlayersFolder = Workspace:WaitForChild("Players")

-- ============================================
-- TEAM DETECTION
-- PF folder names are hashed random strings
-- Must find our model inside to detect team
-- ============================================
local myTeamFolder = nil
local enemyTeamFolder = nil

local function DetectTeams()
    myTeamFolder = nil
    enemyTeamFolder = nil
    
    -- Find which folder has our model
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        if folder:FindFirstChild(LocalPlayer.Name) then
            myTeamFolder = folder
            break
        end
    end
    
    -- The other folder is enemy
    if myTeamFolder then
        for _, folder in ipairs(PlayersFolder:GetChildren()) do
            if folder ~= myTeamFolder then
                enemyTeamFolder = folder
                break
            end
        end
    end
end

-- Initial detection with retry
task.spawn(function()
    for i = 1, 60 do
        DetectTeams()
        if myTeamFolder then
            print("[PF v5.0] Teams detected:")
            print("  My team: " .. myTeamFolder.Name)
            print("  Enemy: " .. (enemyTeamFolder and enemyTeamFolder.Name or "nil"))
            break
        end
        task.wait(0.5)
    end
    if not myTeamFolder then
        print("[PF v5.0] WARNING: Could not detect teams")
        local folders = PlayersFolder:GetChildren()
        if #folders >= 2 then
            myTeamFolder = folders[2]
            enemyTeamFolder = folders[1]
            print("[PF v5.0] Fallback: guessing teams")
        end
    end
end)

-- Re-detect on team change and respawn
LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function()
    task.wait(2)
    DetectTeams()
    print("[PF v5.0] Team changed, re-detected")
end)

local function IsEnemyModel(model)
    if not model or not model.Parent then return false end
    if model.Name == LocalPlayer.Name then return false end
    if not myTeamFolder then return true end
    return model.Parent ~= myTeamFolder
end

-- ============================================
-- PART NAME MAPPING
-- ============================================
local PART_MAP = {
    Head = "Head",
    Torso = "Torso",
    HumanoidRootPart = "HumanoidRootPart",
    UpperTorso = "Torso",
    LowerTorso = "Torso"
}
local PF_PARTS = {"Head", "Torso", "HumanoidRootPart", "Right Arm", "Left Arm", "Right Leg", "Left Leg"}

-- ============================================
-- VISIBILITY CHECK
-- ============================================
local function IsVisible(model)
    if not model then return false end
    local part = model:FindFirstChild("Head")
        or model:FindFirstChild("Torso")
        or model:FindFirstChild("HumanoidRootPart")
    if not part then return false end
    
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    
    local ignore = {model, cam}
    if LocalPlayer.Character then
        table.insert(ignore, LocalPlayer.Character)
    end
    if myTeamFolder then
        local mm = myTeamFolder:FindFirstChild(LocalPlayer.Name)
        if mm then table.insert(ignore, mm) end
    end
    local ig = Workspace:FindFirstChild("Ignore")
    if ig then table.insert(ignore, ig) end
    
    return #cam:GetPartsObscuringTarget({part.Position}, ignore) == 0
end

-- ============================================
-- ESP SYSTEM
-- ============================================
local ESPStore = {}

local function MakeESP()
    local d = {}
    
    d.Outline = Drawing.new("Square")
    d.Outline.Thickness = 3
    d.Outline.Filled = false
    d.Outline.Color = Color3.fromRGB(0, 0, 0)
    d.Outline.Transparency = 0.5
    d.Outline.Visible = false
    
    d.Box = Drawing.new("Square")
    d.Box.Thickness = 1
    d.Box.Filled = false
    d.Box.Visible = false
    
    d.Name = Drawing.new("Text")
    d.Name.Size = 13
    d.Name.Center = true
    d.Name.Outline = true
    d.Name.Font = 2
    d.Name.Visible = false
    
    d.Distance = Drawing.new("Text")
    d.Distance.Size = 12
    d.Distance.Center = true
    d.Distance.Outline = true
    d.Distance.Font = 2
    d.Distance.Visible = false
    
    d.Weapon = Drawing.new("Text")
    d.Weapon.Size = 12
    d.Weapon.Center = true
    d.Weapon.Outline = true
    d.Weapon.Font = 2
    d.Weapon.Color = Color3.fromRGB(0, 255, 30)
    d.Weapon.Visible = false
    
    d.HealthBG = Drawing.new("Square")
    d.HealthBG.Thickness = 1
    d.HealthBG.Filled = true
    d.HealthBG.Color = Color3.fromRGB(0, 0, 0)
    d.HealthBG.Transparency = 0.5
    d.HealthBG.Visible = false
    
    d.HealthBar = Drawing.new("Square")
    d.HealthBar.Thickness = 1
    d.HealthBar.Filled = true
    d.HealthBar.Visible = false
    
    return d
end

local function GetWeapon(model)
    local w = model:FindFirstChildWhichIsA("Model")
    if w then
        local parts = string.split(w.Name, " ")
        if #parts > 1 then
            local name = ""
            for i = 1, #parts - 1 do
                name = name .. parts[i]
                if i < #parts - 1 then name = name .. " " end
            end
            return name
        end
        return w.Name
    end
    return nil
end

local function AddESP(model)
    if ESPStore[model] or not model:IsA("Model") then return end
    ESPStore[model] = MakeESP()
end

local function RemoveESP(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do
        pcall(function() obj:Remove() end)
    end
    ESPStore[model] = nil
end

local function HideESP(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do
        pcall(function() obj.Visible = false end)
    end
end

-- Register existing models
for _, team in ipairs(PlayersFolder:GetChildren()) do
    for _, model in ipairs(team:GetChildren()) do
        AddESP(model)
    end
end

-- Watch for new/removed models
PlayersFolder.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") and desc.Parent and desc.Parent.Parent == PlayersFolder then
        AddESP(desc)
    end
end)

PlayersFolder.DescendantRemoving:Connect(function(desc)
    if desc:IsA("Model") then
        RemoveESP(desc)
    end
end)

local function UpdateESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for m in pairs(ESPStore) do HideESP(m) end
        return
    end
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    -- Get local position for distance
    local localPos = Camera.CFrame.Position
    local ig = Workspace:FindFirstChild("Ignore")
    if ig then
        local rp = ig:FindFirstChild("RefPlayer")
        if rp then
            local h = rp:FindFirstChild("HumanoidRootPart") or rp:FindFirstChild("Torso")
            if h then localPos = h.Position end
        end
    end
    
    for model, esp in pairs(ESPStore) do
        -- Validate model
        if not model.Parent or not model.Parent.Parent then
            HideESP(model)
            continue
        end
        
        -- Skip self
        if model.Name == LocalPlayer.Name then
            HideESP(model)
            continue
        end
        
        -- Team check
        local isEnemy = IsEnemyModel(model)
        if Config.ESP.TeamCheck and not isEnemy then
            HideESP(model)
            continue
        end
        
        -- Get position from actual parts
        local root = model:FindFirstChild("HumanoidRootPart")
            or model:FindFirstChild("Torso")
            or model:FindFirstChild("Head")
        if not root then
            HideESP(model)
            continue
        end
        
        local pos = root.Position
        local dist = (localPos - pos).Magnitude
        
        if dist > Config.ESP.MaxDistance then
            HideESP(model)
            continue
        end
        
        local sp, onScreen = Camera:WorldToViewportPoint(pos)
        if not onScreen then
            HideESP(model)
            continue
        end
        
        -- Calculate box from part positions
        local head = model:FindFirstChild("Head")
        local headY = head and head.Position.Y or (pos.Y + 1.5)
        local feetY = pos.Y - 3
        
        local topSP = Camera:WorldToViewportPoint(Vector3.new(pos.X, headY + 0.5, pos.Z))
        local botSP = Camera:WorldToViewportPoint(Vector3.new(pos.X, feetY, pos.Z))
        
        local height = math.max(math.abs(botSP.Y - topSP.Y), 10)
        local width = height * 0.6
        local centerX = sp.X
        local minX = centerX - width / 2
        local topY = topSP.Y
        
        -- Color: enemy visible=green, enemy hidden=red, ally=blue
        local color
        if not isEnemy then
            color = Color3.fromRGB(80, 150, 255)
        else
            color = IsVisible(model)
                and Color3.fromRGB(50, 255, 50)
                or Color3.fromRGB(255, 50, 50)
        end
        
        -- Box
        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, topY - 1)
            esp.Outline.Visible = true
            
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, topY)
            esp.Box.Color = color
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end
        
        -- Name
        if Config.ESP.Names then
            esp.Name.Text = model.Name
            esp.Name.Position = Vector2.new(centerX, topY - 16)
            esp.Name.Color = color
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        -- Distance
        if Config.ESP.Distance then
            esp.Distance.Text = "[" .. math.floor(dist) .. "] studs"
            esp.Distance.Position = Vector2.new(centerX, topY + height + 2)
            esp.Distance.Color = color
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end
        
        -- Weapon
        if Config.ESP.Names then
            local wep = GetWeapon(model)
            if wep then
                esp.Weapon.Text = wep
                esp.Weapon.Position = Vector2.new(centerX, topY - 30)
                esp.Weapon.Visible = true
            else
                esp.Weapon.Visible = false
            end
        else
            esp.Weapon.Visible = false
        end
        
        -- Health bar
        local hum = model:FindFirstChildOfClass("Humanoid")
        if Config.ESP.Boxes and hum and hum.MaxHealth > 0 then
            local hp = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
            local bh = height * hp
            local hc = hp > 0.5
                and Color3.fromRGB(math.floor(255 * (1 - hp) * 2), 255, 0)
                or Color3.fromRGB(255, math.floor(255 * hp * 2), 0)
            
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, topY)
            esp.HealthBG.Visible = true
            
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, topY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end
end

-- ============================================
-- HITBOX EXPANSION
-- ============================================
local HBExpanded = {}
local HBOrigSizes = {}
local HBOrigTransp = {}
local HBRandPart = {}
local HBRandTime = {}
local lastHBUpdate = 0

local function RestoreHitbox(model)
    if not HBOrigSizes[model] then return end
    for pn, sz in pairs(HBOrigSizes[model]) do
        local p = model:FindFirstChild(pn)
        if p then
            pcall(function()
                p.Size = sz
                p.Transparency = HBOrigTransp[model][pn]
            end)
        end
    end
    HBExpanded[model] = nil
    HBOrigSizes[model] = nil
    HBOrigTransp[model] = nil
    HBRandPart[model] = nil
    HBRandTime[model] = nil
end

local function CleanupHitboxes()
    for m in pairs(HBExpanded) do
        if m and m.Parent then RestoreHitbox(m) end
    end
    HBExpanded = {}
    HBOrigSizes = {}
    HBOrigTransp = {}
    HBRandPart = {}
    HBRandTime = {}
end

local function ExpandHitbox(model, targetPart, size)
    if not HBOrigSizes[model] then
        HBOrigSizes[model] = {}
        HBOrigTransp[model] = {}
    end
    
    for _, pn in ipairs({"Head", "Torso", "HumanoidRootPart"}) do
        local p = model:FindFirstChild(pn)
        if p and p:IsA("BasePart") then
            if not HBOrigSizes[model][pn] then
                HBOrigSizes[model][pn] = p.Size
                HBOrigTransp[model][pn] = p.Transparency
            end
            pcall(function()
                if pn == targetPart then
                    p.CanCollide = false
                    p.Massless = true
                    p.Size = Vector3.new(size, size, size)
                    p.Transparency = Config.Hitbox.Transparency
                else
                    p.Size = HBOrigSizes[model][pn]
                    p.Transparency = HBOrigTransp[model][pn]
                end
            end)
        end
    end
    HBExpanded[model] = true
end

local function UpdateHitboxes()
    if not Config.Hitbox.Enabled or not Config.Hitbox.Active then
        CleanupHitboxes()
        return
    end
    
    local now = tick()
    if now - lastHBUpdate < 0.05 then return end
    lastHBUpdate = now
    
    Camera = Workspace.CurrentCamera
    if not Camera or not enemyTeamFolder then return end
    
    local shouldExpand = {}
    
    for _, model in ipairs(enemyTeamFolder:GetChildren()) do
        if not model:IsA("Model") then continue end
        
        local pt = Config.Hitbox.TargetPart
        if pt == "Random" then
            local t = tick()
            if not HBRandTime[model] or t - HBRandTime[model] >= 0.5 then
                HBRandPart[model] = math.random(1, 2) == 1 and "Head" or "Torso"
                HBRandTime[model] = t
            end
            pt = HBRandPart[model] or "Head"
        elseif pt == "HumanoidRootPart" and not model:FindFirstChild("HumanoidRootPart") then
            pt = "Torso"
        end
        
        if Config.Hitbox.Method == "HE (Static)" then
            shouldExpand[model] = {part = pt, size = Config.Hitbox.MaxSize}
        else
            -- Dynamic
            local cp = model:FindFirstChild(pt)
                or model:FindFirstChild("Head")
                or model:FindFirstChild("Torso")
            if not cp then continue end
            
            local mouse = UserInputService:GetMouseLocation()
            local fov = Config.Hitbox.FOVEnabled and Config.Hitbox.FOVRadius or Config.FOV.Radius
            local sp, on = Camera:WorldToViewportPoint(cp.Position)
            if not on then continue end
            
            local d = (mouse - Vector2.new(sp.X, sp.Y)).Magnitude
            if d > fov then continue end
            
            local factor = 1 - (d / fov)
            shouldExpand[model] = {
                part = pt,
                size = 1 + (Config.Hitbox.MaxSize - 1) * factor
            }
        end
    end
    
    -- Restore models no longer needed
    for m in pairs(HBExpanded) do
        if not shouldExpand[m] then
            if m and m.Parent then
                RestoreHitbox(m)
            else
                HBExpanded[m] = nil
                HBOrigSizes[m] = nil
                HBOrigTransp[m] = nil
                HBRandPart[m] = nil
                HBRandTime[m] = nil
            end
        end
    end
    
    -- Expand
    for m, data in pairs(shouldExpand) do
        ExpandHitbox(m, data.part, data.size)
    end
end

-- ============================================
-- AIMBOT
-- Since silent aim is impossible on Ronix,
-- aimbot + hitbox expansion is the alternative
-- ============================================
local aimbotLocked = nil
local abRandomState = {"Head"}
local abRandomTime = {0}

local function GetAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera or not enemyTeamFolder then return nil end
    
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local ref = Config.Aimbot.Method == "Aimbot"
        and Vector2.new(vp.X / 2, vp.Y / 2)
        or UserInputService:GetMouseLocation()
    
    -- Aimlock: keep target
    if Config.Aimbot.Method == "Aimlock" and aimbotLocked and aimbotLocked.Parent then
        local setting = Config.Aimbot.TargetPart or "Head"
        local mapped = PART_MAP[setting] or setting
        local tp = aimbotLocked:FindFirstChild(mapped) or aimbotLocked:FindFirstChild("Head")
        if tp then
            if not Config.Aimbot.VisibleCheck or IsVisible(aimbotLocked) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        aimbotLocked = nil
    end
    
    local bestPart = nil
    local bestDist = fov
    local bestModel = nil
    
    for _, model in ipairs(enemyTeamFolder:GetChildren()) do
        if not model:IsA("Model") then continue end
        
        -- Resolve target part
        local setting = Config.Aimbot.TargetPart or "Head"
        if setting == "Random" then
            local t = tick()
            if t - abRandomTime[1] > 0.5 then
                local valid = {}
                for _, pn in ipairs(PF_PARTS) do
                    if model:FindFirstChild(pn) then
                        table.insert(valid, pn)
                    end
                end
                if #valid > 0 then
                    abRandomState[1] = valid[math.random(1, #valid)]
                end
                abRandomTime[1] = t
            end
            setting = abRandomState[1]
        end
        
        local mapped = PART_MAP[setting] or setting
        local part = model:FindFirstChild(mapped)
            or model:FindFirstChild("Head")
            or model:FindFirstChild("Torso")
        if not part then continue end
        
        -- Visibility check
        if Config.Aimbot.VisibleCheck and not IsVisible(model) then continue end
        
        -- Screen distance
        local sp, on = Camera:WorldToViewportPoint(part.Position)
        if not on then continue end
        
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then
            bestDist = d
            bestPart = part
            bestModel = model
        end
    end
    
    if Config.Aimbot.Method == "Aimlock" and bestModel then
        aimbotLocked = bestModel
    end
    
    return bestPart
end

-- Also provide silent aim target finder for FOV circle display
local function GetSilentTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    
    local fov = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mouse = UserInputService:GetMouseLocation()
    local bestDist = fov
    local bestPart = nil
    
    -- Use enemy folder
    if enemyTeamFolder then
        local hitPart = Config.Silent.TargetPart or "Head"
        if hitPart == "Random" then hitPart = ({"Head", "Torso"})[math.random(1, 2)] end
        hitPart = PART_MAP[hitPart] or hitPart
        
        for _, model in ipairs(enemyTeamFolder:GetChildren()) do
            if not model:IsA("Model") then continue end
            local part = model:FindFirstChild(hitPart) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
            if not part then continue end
            local sp, on = Camera:WorldToViewportPoint(part.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
            if d > bestDist then continue end
            if Config.Silent.VisibleCheck and not IsVisible(model) then continue end
            bestDist = d
            bestPart = part
        end
    end
    
    return bestPart
end

-- ============================================
-- MAIN RENDER LOOP
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local target = GetAimbotTarget()
        
        if target then
            local pos = target.Position
            
            -- Prediction
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                pcall(function()
                    local vel = target.AssemblyLinearVelocity
                    if vel and vel.Magnitude > 0.5 then
                        pos = pos + vel * Config.Aimbot.Prediction
                    end
                end)
            end
            
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            
            if Config.Aimbot.Method == "Aimbot" then
                -- Camera CFrame
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
            else
                -- Aimlock: mousemoverel
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx = sp.X - mp.X
                    local dy = sp.Y - mp.Y
                    local dist = math.sqrt(dx * dx + dy * dy)
                    
                    if dist > 1 then
                        local spd = math.clamp(1 / sm, 0.05, 0.8)
                        local mx = math.clamp(dx * spd, -150, 150)
                        local my = math.clamp(dy * spd, -150, 150)
                        
                        if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then
                            mousemoverel(mx, my)
                        end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then
                aimbotLocked = nil
            end
        end
    else
        if not Config.Aimbot.Active then
            aimbotLocked = nil
        end
    end
end)

-- ============================================
-- HEARTBEAT LOOP: ESP + Hitbox
-- ============================================
RunService.Heartbeat:Connect(function()
    UpdateESP()
    UpdateHitboxes()
end)

-- ============================================
-- SIGNALS TO MAIN SCRIPT
-- ============================================
getgenv().AX_PF_HandlesESP = true
getgenv().AX_PF_HandlesHitbox = true
getgenv().AX_PF_HandlesAimbot = true

-- ============================================
-- CLEANUP ON RESPAWN
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    Camera = Workspace.CurrentCamera
    aimbotLocked = nil
    CleanupHitboxes()
    DetectTeams()
end)

-- ============================================
-- CLEANUP ON MODEL REMOVAL
-- ============================================
task.spawn(function()
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        folder.ChildRemoved:Connect(function(child)
            if child:IsA("Model") then
                RemoveESP(child)
                if HBExpanded[child] then
                    HBExpanded[child] = nil
                    HBOrigSizes[child] = nil
                    HBOrigTransp[child] = nil
                    HBRandPart[child] = nil
                    HBRandTime[child] = nil
                end
                if aimbotLocked == child then
                    aimbotLocked = nil
                end
            end
        end)
    end
    
    PlayersFolder.ChildAdded:Connect(function(folder)
        task.wait(0.1)
        if folder:IsA("Folder") then
            folder.ChildRemoved:Connect(function(child)
                if child:IsA("Model") then
                    RemoveESP(child)
                end
            end)
        end
    end)
end)

-- ============================================
-- LOADED
-- ============================================
getgenv().AX_PFLoaded = true

print("  ╔═══════════════════════════════════════════════════╗")
print("  ║     PF MODULE v5.0 LOADED (Ronix Compatible)      ║")
print("  ╠═══════════════════════════════════════════════════╣")
print("  ║  ESP:        Part-position tracking               ║")
print("  ║  Aimbot:     Camera + MouseMoveRel                ║")
print("  ║  Hitbox:     Enemy model expansion                ║")
print("  ║  Silent Aim: NOT AVAILABLE (Ronix limitation)     ║")
print("  ║                                                   ║")
print("  ║  TIP: Use Aimbot + Hitbox Expansion together     ║")
print("  ║  for best results without silent aim.             ║")
print("  ╚═══════════════════════════════════════════════════╝")
