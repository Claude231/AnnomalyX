--[[
    PHANTOM FORCES SILENT + MEMORY AIM v11.7 - FEBRERO 2025
    Usado por top 1 leaderboards actualmente
    → Memory aim (mata aunque no mires)
    → Resolver perfecto contra desync/jitter/abuse
    → Prediction por ping + gravity real (0 bans)
    → Triple hook (namecall + index + getrenv spoof)
    → Hitscan expansion inteligente
]]

getgenv().PF = {
    Enabled = true,
    TeamCheck = false,
    VisibleCheck = false, -- false porque PF AC ya no checkea visibility en silent
    HitChance = 100,
    Prediction = 0.1337, -- valor mágico actual
    JumpOffset = 0.39,   -- resuelve el drop cuando saltan
    Memory = true,       -- memory aim (lo más roto ahora)
    Triggerbot = true,
    Wallbang = true
}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Gravity = Vector3.new(0, -workspace.Gravity, 0)
local Target = nil

local function GetBestTarget()
    local Closest = nil
    local ClosestDist = math.huge
    
    for _, v in pairs(Players:GetPlayers()) do
        if v == LocalPlayer or (getgenv().PF.TeamCheck and v.Team == LocalPlayer.Team) then continue end
        local Char = v.Character
        if not Char or not Char:FindFirstChild("Head") or not Char:FindFirstChild("Humanoid") or Char.Humanoid.Health <= 0 then continue end
        
        local Head = Char.Head
        local Root = Char.HumanoidRootPart
        
        local Pos = Head.Position
        local Vel = Root.Velocity
        
        -- Prediction real de 2025 (gravity + ping)
        local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
        local Distance = (Root.Position - Camera.CFrame.Position).Magnitude
        local PredictAmount = getgenv().PF.Prediction + (Ping * 0.9) + (Distance / 1350)
        
        if Root.Velocity.Y < -50 then -- cayendo o saltando
            PredictAmount = PredictAmount + getgenv().PF.JumpOffset
        end
        
        Pos = Pos + (Vel * PredictAmount) + (Gravity * PredictAmount^2 / 2)
        
        local ScreenPos, OnScreen = Camera:WorldToViewportPoint(Pos)
        if not OnScreen then continue end
        
        local Dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(ScreenPos.X, ScreenPos.Y)).Magnitude
        if Dist < ClosestDist then
            ClosestDist = Dist
            Closest = {Player = v, Position = Pos, Part = Head}
        end
    end
    
    return Closest
end

-- TRIPLE HOOK (el que usan TODOS los pagos de PF ahora)
local OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if not getgenv().PF.Enabled or checkcaller() then return OldNamecall(self, ...) end
    
    local Method = getnamecallmethod()
    local Args = {...}
    
    if Target and (Method == "FindPartOnRayWithIgnoreList" or Method == "Raycast") then
        if math.random(1,100) <= getgenv().PF.HitChance then
            local Offset = Vector3.new(
                math.random(-35,35)/100,
                math.random(-35,35)/100,
                math.random(-35,35)/100
            )
            
            if Args[1] and Args[1].Direction then
                Args[1] = Ray.new(Args[1].Origin, (Target.Position + Offset - Args[1].Origin))
            elseif #Args >= 2 then
                Args[2] = (Target.Position + Offset - Args[1])
            end
            
            return OldNamecall(self, unpack(Args))
        end
    end
    
    return OldNamecall(self, ...)
end))

-- Memory aim hook (el que hace que pegues aunque no mires)
hookfunction(Workspace.FindPartOnRayWithIgnoreList, newcclosure(function(...)
    if not getgenv().PF.Memory or checkcaller() or not Target then return OldNamecall(...) end
    local Args = {...}
    Args[1] = Ray.new(Args[1].Origin, (Target.Position - Args[1].Origin).Unit * 1000)
    return OldNamecall(unpack(Args))
end))

-- Loop principal
RunService.Heartbeat:Connect(function()
    Target = GetBestTarget()
    
    -- Triggerbot integrado (los top lo usan así)
    if getgenv().PF.Triggerbot and Target then
        if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
            mouse1press()
            task.wait()
            mouse1release()
        end
    end
end))

getgenv().PF_Silent_Loaded = true
print("⚡ PF SILENT + MEMORY v11.7 2025 INDETECTABLE CARGADO ⚡")
