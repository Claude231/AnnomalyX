--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Phantom Forces Module v4.2            ║
    ║                                                           ║
    ║  COMPLETE REWRITE - Based on working PF scripts           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

-- Compatibility
local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end

-- Services
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ============================================
-- PF WORKSPACE STRUCTURE
-- workspace.Players has exactly 2 child folders
-- Each folder = one team
-- Children of folders = player character models
-- ============================================
local PlayersFolder = Workspace:WaitForChild("Players")

-- ============================================
-- TEAM DETECTION (REWRITTEN)
-- Uses 3 methods to reliably detect which team
-- folder belongs to the local player
-- ============================================
local function GetMyTeamFolder()
    -- Method 1: Check which folder contains our model
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        if folder:FindFirstChild(LocalPlayer.Name) then
            return folder
        end
    end
    
    -- Method 2: Match TeamColor.Name
    if LocalPlayer.TeamColor then
        local tcName = LocalPlayer.TeamColor.Name
        for _, folder in ipairs(PlayersFolder:GetChildren()) do
            if folder.Name == tcName then
                return folder
            end
        end
    end
    
    -- Method 3: Match Team.Name
    if LocalPlayer.Team then
        local tName = LocalPlayer.Team.Name
        for _, folder in ipairs(PlayersFolder:GetChildren()) do
            if folder.Name == tName then
                return folder
            end
        end
    end
    
    return nil
end

local function GetEnemyTeamFolder()
    local myFolder = GetMyTeamFolder()
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        if folder ~= myFolder then
            return folder
        end
    end
    return nil
end

local function IsEnemyModel(model)
    if not model or not model.Parent then return false end
    local myFolder = GetMyTeamFolder()
    if not myFolder then return true end
    return model.Parent ~= myFolder
end

-- ============================================
-- PART NAME MAPPING
-- ============================================
local PF_PARTS = {"Head", "Torso", "HumanoidRootPart", "Right Arm", "Left Arm", "Right Leg", "Left Leg"}
local PART_MAP = {
    Head = "Head", Torso = "Torso", HumanoidRootPart = "HumanoidRootPart",
    UpperTorso = "Torso", LowerTorso = "Torso"
}

-- ============================================
-- PF INTERNAL MODULES (via getgc)
-- ============================================
local network = nil
local trajectoryFunc = nil
local gamelogic = nil
local getbodyparts = nil
local cameraModule = nil
local replicationInterface = nil
local weaponController = nil

local function ScanModules()
    -- getgc scan (scripts 5 & 6 method)
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            if rawget(v, "getbodyparts") and type(v.getbodyparts) == "function" then
                getbodyparts = v.getbodyparts
            end
        end
        if type(v) == "function" then
            pcall(function()
                if debug.getinfo(v).name == "trajectory" then
                    trajectoryFunc = v
                end
            end)
            pcall(function()
                for _, uv in pairs(debug.getupvalues(v)) do
                    if type(uv) == "table" then
                        if rawget(uv, "send") and type(rawget(uv, "send")) == "function" and not network then
                            network = uv
                        end
                        if rawget(uv, "gammo") and not gamelogic then
                            gamelogic = uv
                        end
                        if rawget(uv, "basecframe") and not cameraModule then
                            cameraModule = uv
                        end
                    end
                end
            end)
        end
    end
    
    -- shared.require scan (script 5 method)
    pcall(function()
        local req = getrenv().shared.require
        if not req then return end
        if not network then
            pcall(function()
                local nc = req("NetworkClient")
                if nc and nc.send then network = nc end
            end)
        end
        if not replicationInterface then
            pcall(function()
                local ri = req("ReplicationInterface")
                if ri and ri.operateOnAllEntries then replicationInterface = ri end
            end)
        end
        if not weaponController then
            pcall(function()
                local wc = req("WeaponControllerInterface")
                if wc then weaponController = wc end
            end)
        end
    end)
end

ScanModules()

print("[PF v4.2] Modules:")
print("  network: " .. (network and "YES" or "NO"))
print("  trajectory: " .. (trajectoryFunc and "YES" or "NO"))
print("  gamelogic: " .. (gamelogic and "YES" or "NO"))
print("  getbodyparts: " .. (getbodyparts and "YES" or "NO"))
print("  camera: " .. (cameraModule and "YES" or "NO"))
print("  replication: " .. (replicationInterface and "YES" or "NO"))
print("  weaponCtrl: " .. (weaponController and "YES" or "NO"))

-- ============================================
-- VISIBILITY CHECK
-- ============================================
local function IsVisible(model)
    if not model then return false end
    local part = model:FindFirstChild("Head") or model:FindFirstChild("Torso") or model:FindFirstChild("HumanoidRootPart")
    if not part then return false end
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    
    local ignore = {model, cam}
    if LocalPlayer.Character then table.insert(ignore, LocalPlayer.Character) end
    local myFolder = GetMyTeamFolder()
    if myFolder then
        local myModel = myFolder:FindFirstChild(LocalPlayer.Name)
        if myModel then table.insert(ignore, myModel) end
    end
    local ignF = Workspace:FindFirstChild("Ignore")
    if ignF then table.insert(ignore, ignF) end
    
    return #cam:GetPartsObscuringTarget({part.Position}, ignore) == 0
end

-- ============================================
-- BULLET SPEED & TRAJECTORY
-- ============================================
local function GetBulletSpeed()
    if weaponController then
        local s, v = pcall(function()
            return weaponController.getController():getActiveWeapon():getWeaponStat("bulletspeed")
        end)
        if s and v then return v end
    end
    if gamelogic and gamelogic.currentgun and gamelogic.currentgun.data then
        return gamelogic.currentgun.data.bulletspeed or 2000
    end
    return 2000
end

local function CalcTrajectory(origin, targetPos)
    local grav = Vector3.new(0, Workspace.Gravity, 0)
    local speed = GetBulletSpeed()
    
    if trajectoryFunc then
        local s, r = pcall(trajectoryFunc, origin, grav, targetPos, speed)
        if s and r then return r end
    end
    
    local dir = targetPos - origin
    local a = grav:Dot(grav) * 0.25
    local b = grav:Dot(dir) - speed ^ 2
    local c = dir:Dot(dir)
    local disc = b * b - 4 * a * c
    if disc >= 0 then
        local s2, r2 = pcall(function()
            local root = ((-b - math.sqrt(disc)) / (2 * a)) ^ 0.5
            return (dir / root + 0.5 * grav * root).Unit
        end)
        if s2 and r2 then return r2 end
    end
    return dir.Unit
end

-- ============================================
-- TARGET FINDER FOR SILENT AIM
-- Tries 3 methods in priority order
-- ============================================
local function GetSilentTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil, nil end
    
    local fov = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mouse = UserInputService:GetMouseLocation()
    local bestDist = fov
    local bestPart, bestPlayer
    
    local hitPart = Config.Silent.TargetPart or "Head"
    if hitPart == "Random" then hitPart = ({"Head", "Torso"})[math.random(1, 2)] end
    hitPart = PART_MAP[hitPart] or hitPart
    
    -- Method 1: replicationInterface (most reliable)
    if replicationInterface then
        pcall(function()
            replicationInterface.operateOnAllEntries(function(player, entry)
                if not entry:isAlive() then return end
                if player == LocalPlayer then return end
                if player.Team == LocalPlayer.Team then return end
                
                local ok, part = pcall(function()
                    return entry:getThirdPersonObject():getBodyPart(hitPart)
                end)
                if not ok or not part then return end
                
                local sp, on = Camera:WorldToViewportPoint(part.Position)
                if not on then return end
                local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
                if d > bestDist then return end
                if Config.Silent.VisibleCheck and part.Parent and not IsVisible(part.Parent) then return end
                
                bestDist = d
                bestPart = part
                bestPlayer = player
            end)
        end)
        if bestPart then return bestPart, bestPlayer end
    end
    
    -- Method 2: getbodyparts
    if getbodyparts then
        for _, player in pairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if player.Team == LocalPlayer.Team then continue end
            
            local s, bp = pcall(getbodyparts, player)
            if not s or not bp or not rawget(bp, "rootpart") then continue end
            local model = bp.rootpart.Parent
            if not model then continue end
            
            local part = model:FindFirstChild(hitPart) or model:FindFirstChild("Head")
            if not part then continue end
            
            local sp, on = Camera:WorldToViewportPoint(part.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
            if d > bestDist then continue end
            if Config.Silent.VisibleCheck and not IsVisible(model) then continue end
            
            bestDist = d
            bestPart = part
            bestPlayer = player
        end
        if bestPart then return bestPart, bestPlayer end
    end
    
    -- Method 3: workspace scan
    local enemyFolder = GetEnemyTeamFolder()
    if enemyFolder then
        for _, model in ipairs(enemyFolder:GetChildren()) do
            if not model:IsA("Model") then continue end
            local part = model:FindFirstChild(hitPart) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
            if not part then continue end
            
            local sp, on = Camera:WorldToViewportPoint(part.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
            if d > bestDist then continue end
            if Config.Silent.VisibleCheck and not IsVisible(model) then continue end
            
            bestDist = d
            bestPart = part
            bestPlayer = Players:FindFirstChild(model.Name)
        end
    end
    
    return bestPart, bestPlayer
end

-- ============================================
-- SILENT AIM: NETWORK HOOK
-- Based directly on scripts 5 and 6
-- ============================================
local networkHooked = false
local silentTarget = nil -- for namecall fallback

local function SetupNetworkHook()
    if not network or not network.send then
        warn("[PF v4.2] network.send not found")
        return false
    end
    
    local oldSend = network.send
    
    -- Verify hook is possible
    network.send = function(self, ...)
        local args = {...}
        
        -- INTERCEPT: newbullets
        if args[1] == "newbullets" and Config.Silent.Enabled and Config.Silent.Active then
            if math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                local targetPart, targetPlayer = GetSilentTarget()
                
                if targetPart and targetPlayer then
                    -- Detect packet format
                    local uniqueID, data, fireTime
                    
                    if type(args[2]) == "table" and rawget(args[2], "bullets") then
                        -- Format B (script 6): send(self, "newbullets", {firepos=..., bullets=...})
                        data = args[2]
                    elseif type(args[3]) == "table" and rawget(args[3], "bullets") then
                        -- Format A (script 5): send(self, "newbullets", uniqueID, {firepos=..., bullets=...}, fireTime)
                        uniqueID = args[2]
                        data = args[3]
                        fireTime = args[4]
                    else
                        return oldSend(self, ...)
                    end
                    
                    -- Fire position
                    local firePos = data.firepos
                    if cameraModule and cameraModule.basecframe then
                        firePos = cameraModule.basecframe.Position
                        data.firepos = firePos
                        if data.camerapos then data.camerapos = firePos end
                    end
                    
                    -- Redirect bullets
                    local targetPos = targetPart.Position
                    local traj = CalcTrajectory(firePos, targetPos)
                    
                    for _, bullet in pairs(data.bullets) do
                        bullet[1] = traj
                    end
                    
                    -- Send modified newbullets
                    if uniqueID then
                        oldSend(self, "newbullets", uniqueID, data, fireTime)
                    else
                        oldSend(self, "newbullets", data)
                    end
                    
                    -- Send bullethit for each bullet
                    for _, bullet in pairs(data.bullets) do
                        if bullet[2] then
                            if uniqueID and fireTime then
                                -- Format A (script 5)
                                oldSend(self, "bullethit", uniqueID, targetPlayer, targetPos, targetPart.Name, bullet[2], fireTime)
                            else
                                -- Format B (script 6) - sends Part instance as 4th arg
                                oldSend(self, "bullethit", targetPlayer, targetPos, targetPart, bullet[2])
                            end
                        end
                    end
                    
                    return
                end
            end
        end
        
        -- BLOCK original bullethit when silent aim is active
        if args[1] == "bullethit" and Config.Silent.Enabled and Config.Silent.Active then
            return
        end
        
        return oldSend(self, ...)
    end
    
    -- Verify hook applied
    if network.send ~= oldSend then
        networkHooked = true
        print("[PF v4.2] Network hook APPLIED")
        return true
    else
        warn("[PF v4.2] Network hook FAILED - table may be protected")
        return false
    end
end

-- Namecall fallback
local OldNamecall
local function SetupNamecallFallback()
    if networkHooked or not hookmetamethod then return end
    
    OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if not checkcaller() and Config.Silent.Enabled and Config.Silent.Active and silentTarget and silentTarget.Parent then
            if math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                local tPos = silentTarget.Position
                if self == Workspace or self == workspace then
                    if method == "Raycast" then
                        local o, d = ...
                        if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                            return OldNamecall(self, o, (tPos - o).Unit * d.Magnitude, select(3, ...))
                        end
                    end
                    if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                        local ray = select(1, ...)
                        if typeof(ray) == "Ray" then
                            local newRay = Ray.new(ray.Origin, (tPos - ray.Origin).Unit * ray.Direction.Magnitude)
                            return OldNamecall(self, newRay, select(2, ...))
                        end
                    end
                end
            end
        end
        return OldNamecall(self, ...)
    end))
    print("[PF v4.2] Namecall fallback applied")
end

SetupNetworkHook()
if not networkHooked then SetupNamecallFallback() end

-- ============================================
-- ESP SYSTEM (REWRITTEN)
-- Based on script 1 + script 7 patterns
-- Tracks ALL models via DescendantAdded/Removing
-- ============================================
local ESPStore = {} -- key = model, value = {drawings}

local function CreateESPDrawings()
    local d = {}
    d.Outline = Drawing.new("Square"); d.Outline.Thickness = 3; d.Outline.Filled = false; d.Outline.Color = Color3.fromRGB(0,0,0); d.Outline.Transparency = 0.5; d.Outline.Visible = false
    d.Box = Drawing.new("Square"); d.Box.Thickness = 1; d.Box.Filled = false; d.Box.Visible = false
    d.Name = Drawing.new("Text"); d.Name.Size = 13; d.Name.Center = true; d.Name.Outline = true; d.Name.Font = 2; d.Name.Visible = false
    d.Distance = Drawing.new("Text"); d.Distance.Size = 12; d.Distance.Center = true; d.Distance.Outline = true; d.Distance.Font = 2; d.Distance.Visible = false
    d.Weapon = Drawing.new("Text"); d.Weapon.Size = 12; d.Weapon.Center = true; d.Weapon.Outline = true; d.Weapon.Font = 2; d.Weapon.Color = Color3.fromRGB(0,255,30); d.Weapon.Visible = false
    d.HealthBG = Drawing.new("Square"); d.HealthBG.Thickness = 1; d.HealthBG.Filled = true; d.HealthBG.Color = Color3.fromRGB(0,0,0); d.HealthBG.Transparency = 0.5; d.HealthBG.Visible = false
    d.HealthBar = Drawing.new("Square"); d.HealthBar.Thickness = 1; d.HealthBar.Filled = true; d.HealthBar.Visible = false
    return d
end

local function GetWeaponName(model)
    local w = model:FindFirstChildWhichIsA("Model")
    if w then
        local parts = string.split(w.Name, " ")
        if #parts > 1 then
            local name = ""
            for i = 1, #parts - 1 do
                name = name .. parts[i]
                if i < #parts - 1 then name = name .. " " end
            end
            return name
        end
        return w.Name
    end
    return nil
end

local function AddESPModel(model)
    if ESPStore[model] then return end
    if not model:IsA("Model") then return end
    ESPStore[model] = CreateESPDrawings()
end

local function RemoveESPModel(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do
        pcall(function() obj:Remove() end)
    end
    ESPStore[model] = nil
end

local function HideESPModel(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do
        pcall(function() obj.Visible = false end)
    end
end

-- Register existing models
for _, team in ipairs(PlayersFolder:GetChildren()) do
    for _, model in ipairs(team:GetChildren()) do
        if model:IsA("Model") then
            AddESPModel(model)
        end
    end
end

-- Watch for new/removed models (script 1 pattern)
PlayersFolder.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") and desc.Parent and desc.Parent.Parent == PlayersFolder then
        AddESPModel(desc)
    end
end)

PlayersFolder.DescendantRemoving:Connect(function(desc)
    if desc:IsA("Model") then
        RemoveESPModel(desc)
    end
end)

local function UpdateAllESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for model in pairs(ESPStore) do HideESPModel(model) end
        return
    end
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    -- Get local position
    local localPos = Camera.CFrame.Position
    local ignoreF = Workspace:FindFirstChild("Ignore")
    if ignoreF then
        local rp = ignoreF:FindFirstChild("RefPlayer")
        if rp then pcall(function() localPos = rp:GetPivot().Position end) end
    end
    
    for model, esp in pairs(ESPStore) do
        -- Validate model still exists
        if not model.Parent or not model.Parent.Parent then
            HideESPModel(model)
            continue
        end
        
        -- Skip self
        if model.Name == LocalPlayer.Name then
            HideESPModel(model)
            continue
        end
        
        -- Team check
        local isEnemy = IsEnemyModel(model)
        if Config.ESP.TeamCheck and not isEnemy then
            HideESPModel(model)
            continue
        end
        
        -- Get root part
        local pivot = nil
        pcall(function() pivot = model:GetPivot() end)
        if not pivot then HideESPModel(model) continue end
        
        local position = pivot.Position
        local dist = (localPos - position).Magnitude
        
        -- Distance check
        if dist > Config.ESP.MaxDistance then HideESPModel(model) continue end
        
        -- Screen check
        local sp, onScreen = Camera:WorldToViewportPoint(position)
        if not onScreen then HideESPModel(model) continue end
        
        -- Calculate box (script 1 method)
        local TL = Camera:WorldToViewportPoint((pivot * CFrame.new(-3, 3, 0)).Position)
        local TR = Camera:WorldToViewportPoint((pivot * CFrame.new(3, 3, 0)).Position)
        local BL = Camera:WorldToViewportPoint((pivot * CFrame.new(-3, -3, 0)).Position)
        local BR = Camera:WorldToViewportPoint((pivot * CFrame.new(3, -3, 0)).Position)
        
        local topY = math.min(TL.Y, TR.Y)
        local botY = math.max(BL.Y, BR.Y)
        local leftX = math.min(TL.X, BL.X)
        local rightX = math.max(TR.X, BR.X)
        local height = math.max(botY - topY, 10)
        local width = math.max(rightX - leftX, height / 2)
        local centerX = (leftX + rightX) / 2
        local minX = centerX - width / 2
        
        -- Color
        local color
        if not isEnemy then
            color = Color3.fromRGB(80, 150, 255)
        else
            color = IsVisible(model) and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        end
        
        -- BOX
        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, topY - 1)
            esp.Outline.Visible = true
            
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, topY)
            esp.Box.Color = color
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end
        
        -- NAME
        if Config.ESP.Names then
            esp.Name.Text = model.Name
            esp.Name.Position = Vector2.new(centerX, topY - 16)
            esp.Name.Color = color
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        -- DISTANCE
        if Config.ESP.Distance then
            esp.Distance.Text = "[" .. math.floor(dist) .. "] studs"
            esp.Distance.Position = Vector2.new(centerX, botY + 2)
            esp.Distance.Color = color
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end
        
        -- WEAPON
        if Config.ESP.Names then
            local wep = GetWeaponName(model)
            if wep then
                esp.Weapon.Text = wep
                esp.Weapon.Position = Vector2.new(centerX, topY - 30)
                esp.Weapon.Color = Color3.fromRGB(0, 255, 30)
                esp.Weapon.Visible = true
            else
                esp.Weapon.Visible = false
            end
        else
            esp.Weapon.Visible = false
        end
        
        -- HEALTH BAR
        local hum = model:FindFirstChildOfClass("Humanoid")
        if Config.ESP.Boxes and hum and hum.MaxHealth > 0 then
            local hp = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
            local bh = height * hp
            local hc = hp > 0.5
                and Color3.fromRGB(math.floor(255 * (1 - hp) * 2), 255, 0)
                or Color3.fromRGB(255, math.floor(255 * hp * 2), 0)
            
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, topY)
            esp.HealthBG.Visible = true
            
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, topY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end
end

-- ============================================
-- HITBOX SYSTEM
-- ============================================
local HBExpanded = {}
local HBOrigSizes = {}
local HBOrigTransp = {}
local HBRandPart = {}
local HBRandTime = {}
local lastHBUpdate = 0

local function RestoreHitbox(model)
    if not HBOrigSizes[model] then return end
    for pn, sz in pairs(HBOrigSizes[model]) do
        local p = model:FindFirstChild(pn)
        if p then pcall(function() p.Size = sz; p.Transparency = HBOrigTransp[model][pn] end) end
    end
    HBExpanded[model] = nil; HBOrigSizes[model] = nil; HBOrigTransp[model] = nil
    HBRandPart[model] = nil; HBRandTime[model] = nil
end

local function CleanupHitboxes()
    for m in pairs(HBExpanded) do if m and m.Parent then RestoreHitbox(m) end end
    HBExpanded = {}; HBOrigSizes = {}; HBOrigTransp = {}; HBRandPart = {}; HBRandTime = {}
end

local function ExpandHitbox(model, targetPart, size)
    if not HBOrigSizes[model] then HBOrigSizes[model] = {}; HBOrigTransp[model] = {} end
    for _, pn in ipairs({"Head", "Torso", "HumanoidRootPart"}) do
        local p = model:FindFirstChild(pn)
        if p and p:IsA("BasePart") then
            if not HBOrigSizes[model][pn] then
                HBOrigSizes[model][pn] = p.Size
                HBOrigTransp[model][pn] = p.Transparency
            end
            pcall(function()
                if pn == targetPart then
                    p.CanCollide = false; p.Massless = true
                    p.Size = Vector3.new(size, size, size)
                    p.Transparency = Config.Hitbox.Transparency
                else
                    p.Size = HBOrigSizes[model][pn]
                    p.Transparency = HBOrigTransp[model][pn]
                end
            end)
        end
    end
    HBExpanded[model] = true
end

local function UpdateHitboxes()
    if not Config.Hitbox.Enabled or not Config.Hitbox.Active then CleanupHitboxes() return end
    local now = tick()
    if now - lastHBUpdate < 0.05 then return end
    lastHBUpdate = now
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    local enemyFolder = GetEnemyTeamFolder()
    if not enemyFolder then return end
    
    local should = {}
    for _, model in ipairs(enemyFolder:GetChildren()) do
        if not model:IsA("Model") then continue end
        
        local pt = Config.Hitbox.TargetPart
        if pt == "Random" then
            local t = tick()
            if not HBRandTime[model] or t - HBRandTime[model] >= 0.5 then
                HBRandPart[model] = math.random(1,2) == 1 and "Head" or "Torso"
                HBRandTime[model] = t
            end
            pt = HBRandPart[model] or "Head"
        elseif pt == "HumanoidRootPart" and not model:FindFirstChild("HumanoidRootPart") then
            pt = "Torso"
        end
        
        if Config.Hitbox.Method == "HE (Static)" then
            should[model] = {part = pt, size = Config.Hitbox.MaxSize}
        else
            local cp = model:FindFirstChild(pt) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
            if not cp then continue end
            local mouse = UserInputService:GetMouseLocation()
            local fov = Config.Hitbox.FOVEnabled and Config.Hitbox.FOVRadius or Config.FOV.Radius
            local sp, on = Camera:WorldToViewportPoint(cp.Position)
            if not on then continue end
            local d = (mouse - Vector2.new(sp.X, sp.Y)).Magnitude
            if d > fov then continue end
            should[model] = {part = pt, size = 1 + (Config.Hitbox.MaxSize - 1) * (1 - d/fov)}
        end
    end
    
    for m in pairs(HBExpanded) do
        if not should[m] then
            if m and m.Parent then RestoreHitbox(m) else
                HBExpanded[m] = nil; HBOrigSizes[m] = nil; HBOrigTransp[m] = nil
                HBRandPart[m] = nil; HBRandTime[m] = nil
            end
        end
    end
    for m, d in pairs(should) do ExpandHitbox(m, d.part, d.size) end
end

-- ============================================
-- AIMBOT
-- ============================================
local aimbotLocked = nil
local aimbotRandState = {"Head"}
local aimbotRandSwitch = {0}

local function GetAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    
    local enemyFolder = GetEnemyTeamFolder()
    if not enemyFolder then return nil end
    
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local ref = Config.Aimbot.Method == "Aimbot" and Vector2.new(vp.X/2, vp.Y/2) or UserInputService:GetMouseLocation()
    
    if Config.Aimbot.Method == "Aimlock" and aimbotLocked and aimbotLocked.Parent then
        local setting = Config.Aimbot.TargetPart or "Head"
        local mapped = PART_MAP[setting] or setting
        local tp = aimbotLocked:FindFirstChild(mapped) or aimbotLocked:FindFirstChild("Head")
        if tp then
            if not Config.Aimbot.VisibleCheck or IsVisible(aimbotLocked) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        aimbotLocked = nil
    end
    
    local bestPart, bestDist, bestModel = nil, fov, nil
    
    for _, model in ipairs(enemyFolder:GetChildren()) do
        if not model:IsA("Model") then continue end
        
        local setting = Config.Aimbot.TargetPart or "Head"
        if setting == "Random" then
            local t = tick()
            if t - aimbotRandSwitch[1] > 0.5 then
                local v = {}
                for _, pn in ipairs(PF_PARTS) do
                    if model:FindFirstChild(pn) then table.insert(v, pn) end
                end
                if #v > 0 then aimbotRandState[1] = v[math.random(1,#v)] end
                aimbotRandSwitch[1] = t
            end
            setting = aimbotRandState[1]
        end
        local mapped = PART_MAP[setting] or setting
        local part = model:FindFirstChild(mapped) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
        if not part then continue end
        
        if Config.Aimbot.VisibleCheck and not IsVisible(model) then continue end
        
        local sp, on = Camera:WorldToViewportPoint(part.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d; bestPart = part; bestModel = model end
    end
    
    if Config.Aimbot.Method == "Aimlock" and bestModel then aimbotLocked = bestModel end
    return bestPart
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    -- Silent target for namecall fallback
    if not networkHooked and Config.Silent.Enabled and Config.Silent.Active then
        silentTarget = GetSilentTarget()
    elseif not networkHooked then
        silentTarget = nil
    end
    
    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local target = GetAimbotTarget()
        if target then
            local pos = target.Position
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                pcall(function()
                    local vel = target.AssemblyLinearVelocity
                    if vel and vel.Magnitude > 0.5 then pos = pos + vel * Config.Aimbot.Prediction end
                end)
            end
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1/sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    if math.sqrt(dx*dx+dy*dy) > 1 then
                        local spd = math.clamp(1/sm, 0.05, 0.8)
                        local mx, my = math.clamp(dx*spd, -150, 150), math.clamp(dy*spd, -150, 150)
                        if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then
                            (mousemoverel or function() end)(mx, my)
                        end
                    end
                end
            end
        elseif not Config.Aimbot.Active then aimbotLocked = nil end
    elseif not Config.Aimbot.Active then aimbotLocked = nil end
end)

RunService.Heartbeat:Connect(function()
    UpdateAllESP()
    UpdateHitboxes()
end)

-- ============================================
-- SIGNALS & CLEANUP
-- ============================================
getgenv().AX_PF_HandlesESP = true
getgenv().AX_PF_HandlesHitbox = true
getgenv().AX_PF_HandlesAimbot = true

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    silentTarget = nil; aimbotLocked = nil
    CleanupHitboxes()
    task.wait(2)
    ScanModules()
    if not networkHooked then SetupNetworkHook() end
end)

getgenv().AX_PFLoaded = true

print("  ╔═══════════════════════════════════════════════════╗")
print("  ║     PF MODULE v4.2 LOADED                         ║")
print("  ╠═══════════════════════════════════════════════════╣")
print("  ║  Silent: " .. (networkHooked and "Network Hook" or "Namecall Fallback"))
print("  ║  ESP:    DescendantAdded tracking")
print("  ║  Team:   " .. (GetLocalTeamName() or GetLocalTeamColorName() or "?"))
print("  ╚═══════════════════════════════════════════════════╝")
