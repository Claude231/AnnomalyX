--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Phantom Forces Module v4.3            ║
    ║                                                           ║
    ║  KEY FIX: moduleCache scanning (Wapus method)             ║
    ║  KEY FIX: ESP uses part positions, not GetPivot           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Workspace = cloneref(game:GetService("Workspace"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local PlayersFolder = Workspace:WaitForChild("Players")

-- ============================================
-- PF MODULE CACHE SCANNER
-- Wapus method: find the master moduleCache table
-- that contains ScreenCull AND NetworkClient
-- Then extract individual modules from it
-- ============================================
local moduleCache = nil
local network = nil
local trajectoryFunc = nil
local gamelogic = nil
local getbodyparts = nil
local cameraModule = nil
local replicationInterface = nil
local weaponController = nil
local contentInterface = nil

local function FindModuleCache()
    print("[PF v4.3] Scanning getgc for moduleCache...")
    
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            -- Wapus method: find table with ScreenCull AND NetworkClient
            if rawget(v, "ScreenCull") and rawget(v, "NetworkClient") then
                moduleCache = v
                print("[PF v4.3] Found moduleCache (ScreenCull + NetworkClient)")
                break
            end
        end
    end
    
    if not moduleCache then
        -- Fallback: try finding table with just NetworkClient
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" and rawget(v, "NetworkClient") then
                moduleCache = v
                print("[PF v4.3] Found moduleCache (NetworkClient only)")
                break
            end
        end
    end
    
    if not moduleCache then
        print("[PF v4.3] moduleCache NOT FOUND via getgc, trying shared.require...")
    end
end

local function ExtractModules()
    if moduleCache then
        -- Extract NetworkClient
        if moduleCache.NetworkClient then
            local nc = moduleCache.NetworkClient
            if type(nc) == "table" and nc.send then
                network = nc
                print("[PF v4.3] Extracted network from moduleCache.NetworkClient")
            end
        end
        
        -- Extract ReplicationInterface
        if moduleCache.ReplicationInterface then
            local ri = moduleCache.ReplicationInterface
            if type(ri) == "table" and ri.operateOnAllEntries then
                replicationInterface = ri
                print("[PF v4.3] Extracted replicationInterface")
            end
        end
        
        -- Extract WeaponControllerInterface
        if moduleCache.WeaponControllerInterface then
            weaponController = moduleCache.WeaponControllerInterface
            print("[PF v4.3] Extracted weaponController")
        end
        
        -- Extract ContentInterface
        if moduleCache.ContentInterface then
            contentInterface = moduleCache.ContentInterface
            print("[PF v4.3] Extracted contentInterface")
        end
    end
    
    -- shared.require fallback
    pcall(function()
        local req = getrenv().shared.require
        if not req then return end
        
        if not network then
            pcall(function()
                local nc = req("NetworkClient")
                if nc and nc.send then
                    network = nc
                    print("[PF v4.3] Got network via shared.require")
                end
            end)
        end
        if not replicationInterface then
            pcall(function()
                local ri = req("ReplicationInterface")
                if ri and ri.operateOnAllEntries then
                    replicationInterface = ri
                    print("[PF v4.3] Got replicationInterface via shared.require")
                end
            end)
        end
        if not weaponController then
            pcall(function()
                local wc = req("WeaponControllerInterface")
                if wc then
                    weaponController = wc
                    print("[PF v4.3] Got weaponController via shared.require")
                end
            end)
        end
    end)
    
    -- getgc scan for remaining modules (trajectory, gamelogic, etc)
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            if rawget(v, "getbodyparts") and type(v.getbodyparts) == "function" and not getbodyparts then
                getbodyparts = v.getbodyparts
                print("[PF v4.3] Found getbodyparts")
            end
        end
        if type(v) == "function" then
            pcall(function()
                if debug.getinfo(v).name == "trajectory" and not trajectoryFunc then
                    trajectoryFunc = v
                    print("[PF v4.3] Found trajectory function")
                end
            end)
            pcall(function()
                for _, uv in pairs(debug.getupvalues(v)) do
                    if type(uv) == "table" then
                        if rawget(uv, "gammo") and not gamelogic then
                            gamelogic = uv
                            print("[PF v4.3] Found gamelogic")
                        end
                        if rawget(uv, "basecframe") and not cameraModule then
                            cameraModule = uv
                            print("[PF v4.3] Found cameraModule")
                        end
                    end
                end
            end)
        end
    end
end

FindModuleCache()
ExtractModules()

-- Final status
print("[PF v4.3] === MODULE STATUS ===")
print("  moduleCache:  " .. (moduleCache and "FOUND" or "NOT FOUND"))
print("  network:      " .. (network and "FOUND" or "NOT FOUND"))
print("  trajectory:   " .. (trajectoryFunc and "FOUND" or "NOT FOUND"))
print("  gamelogic:    " .. (gamelogic and "FOUND" or "NOT FOUND"))
print("  bodyparts:    " .. (getbodyparts and "FOUND" or "NOT FOUND"))
print("  camera:       " .. (cameraModule and "FOUND" or "NOT FOUND"))
print("  replication:  " .. (replicationInterface and "FOUND" or "NOT FOUND"))
print("  weaponCtrl:   " .. (weaponController and "FOUND" or "NOT FOUND"))

-- ============================================
-- TEAM DETECTION
-- ============================================
local function GetMyTeamFolder()
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        if folder:FindFirstChild(LocalPlayer.Name) then
            return folder
        end
    end
    if LocalPlayer.TeamColor then
        for _, folder in ipairs(PlayersFolder:GetChildren()) do
            if folder.Name == LocalPlayer.TeamColor.Name then return folder end
        end
    end
    if LocalPlayer.Team then
        for _, folder in ipairs(PlayersFolder:GetChildren()) do
            if folder.Name == LocalPlayer.Team.Name then return folder end
        end
    end
    return nil
end

local function GetEnemyTeamFolder()
    local my = GetMyTeamFolder()
    for _, folder in ipairs(PlayersFolder:GetChildren()) do
        if folder ~= my then return folder end
    end
    return nil
end

local function IsEnemyModel(model)
    if not model or not model.Parent then return false end
    local my = GetMyTeamFolder()
    if not my then return true end
    return model.Parent ~= my
end

-- Log team info
task.spawn(function()
    task.wait(2)
    local my = GetMyTeamFolder()
    local en = GetEnemyTeamFolder()
    print("[PF v4.3] My team folder: " .. (my and my.Name or "nil"))
    print("[PF v4.3] Enemy folder: " .. (en and en.Name or "nil"))
end)

-- ============================================
-- VISIBILITY
-- ============================================
local function IsVisible(model)
    if not model then return false end
    local part = model:FindFirstChild("Head") or model:FindFirstChild("Torso") or model:FindFirstChild("HumanoidRootPart")
    if not part then return false end
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    
    local ignore = {model, cam}
    if LocalPlayer.Character then table.insert(ignore, LocalPlayer.Character) end
    local my = GetMyTeamFolder()
    if my then
        local mm = my:FindFirstChild(LocalPlayer.Name)
        if mm then table.insert(ignore, mm) end
    end
    local ig = Workspace:FindFirstChild("Ignore")
    if ig then table.insert(ignore, ig) end
    
    return #cam:GetPartsObscuringTarget({part.Position}, ignore) == 0
end

-- ============================================
-- BULLET SPEED & TRAJECTORY
-- ============================================
local PART_MAP = {
    Head = "Head", Torso = "Torso", HumanoidRootPart = "HumanoidRootPart",
    UpperTorso = "Torso", LowerTorso = "Torso"
}
local PF_PARTS = {"Head", "Torso", "HumanoidRootPart", "Right Arm", "Left Arm", "Right Leg", "Left Leg"}

local function GetBulletSpeed()
    if weaponController then
        local s, v = pcall(function()
            return weaponController.getController():getActiveWeapon():getWeaponStat("bulletspeed")
        end)
        if s and v then return v end
    end
    if gamelogic and gamelogic.currentgun and gamelogic.currentgun.data then
        return gamelogic.currentgun.data.bulletspeed or 2000
    end
    return 2000
end

local function CalcTrajectory(origin, targetPos)
    local grav = Vector3.new(0, Workspace.Gravity, 0)
    local speed = GetBulletSpeed()
    if trajectoryFunc then
        local s, r = pcall(trajectoryFunc, origin, grav, targetPos, speed)
        if s and r then return r end
    end
    local dir = targetPos - origin
    local a = grav:Dot(grav) * 0.25
    local b = grav:Dot(dir) - speed ^ 2
    local c = dir:Dot(dir)
    local disc = b * b - 4 * a * c
    if disc >= 0 then
        local s2, r2 = pcall(function()
            local root = ((-b - math.sqrt(disc)) / (2 * a)) ^ 0.5
            return (dir / root + 0.5 * grav * root).Unit
        end)
        if s2 and r2 then return r2 end
    end
    return dir.Unit
end

-- ============================================
-- TARGET FINDER (SILENT AIM)
-- ============================================
local function GetSilentTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil, nil end
    
    local fov = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mouse = UserInputService:GetMouseLocation()
    local bestDist = fov
    local bestPart, bestPlayer
    
    local hitPart = Config.Silent.TargetPart or "Head"
    if hitPart == "Random" then hitPart = ({"Head", "Torso"})[math.random(1, 2)] end
    hitPart = PART_MAP[hitPart] or hitPart
    
    -- Method 1: replicationInterface
    if replicationInterface then
        pcall(function()
            replicationInterface.operateOnAllEntries(function(player, entry)
                if not entry:isAlive() then return end
                if player == LocalPlayer then return end
                if player.Team == LocalPlayer.Team then return end
                local ok, part = pcall(function()
                    return entry:getThirdPersonObject():getBodyPart(hitPart)
                end)
                if not ok or not part then return end
                local sp, on = Camera:WorldToViewportPoint(part.Position)
                if not on then return end
                local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
                if d > bestDist then return end
                if Config.Silent.VisibleCheck and part.Parent and not IsVisible(part.Parent) then return end
                bestDist = d; bestPart = part; bestPlayer = player
            end)
        end)
        if bestPart then return bestPart, bestPlayer end
    end
    
    -- Method 2: getbodyparts
    if getbodyparts then
        for _, player in pairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if player.Team == LocalPlayer.Team then continue end
            local s, bp = pcall(getbodyparts, player)
            if not s or not bp or not rawget(bp, "rootpart") then continue end
            local model = bp.rootpart.Parent
            if not model then continue end
            local part = model:FindFirstChild(hitPart) or model:FindFirstChild("Head")
            if not part then continue end
            local sp, on = Camera:WorldToViewportPoint(part.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
            if d > bestDist then continue end
            if Config.Silent.VisibleCheck and not IsVisible(model) then continue end
            bestDist = d; bestPart = part; bestPlayer = player
        end
        if bestPart then return bestPart, bestPlayer end
    end
    
    -- Method 3: workspace
    local ef = GetEnemyTeamFolder()
    if ef then
        for _, model in ipairs(ef:GetChildren()) do
            if not model:IsA("Model") then continue end
            local part = model:FindFirstChild(hitPart) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
            if not part then continue end
            local sp, on = Camera:WorldToViewportPoint(part.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
            if d > bestDist then continue end
            if Config.Silent.VisibleCheck and not IsVisible(model) then continue end
            bestDist = d; bestPart = part; bestPlayer = Players:FindFirstChild(model.Name)
        end
    end
    
    return bestPart, bestPlayer
end

-- ============================================
-- SILENT AIM: NETWORK HOOK
-- Using the correct network from moduleCache
-- ============================================
local networkHooked = false
local silentTarget = nil

local function SetupNetworkHook()
    if not network then
        warn("[PF v4.3] Cannot hook - network not found")
        return false
    end
    if not network.send then
        warn("[PF v4.3] Cannot hook - network.send not found")
        return false
    end
    
    print("[PF v4.3] Hooking network.send...")
    
    local oldSend = network.send
    
    network.send = function(self, ...)
        local args = {...}
        
        if args[1] == "newbullets" and Config.Silent.Enabled and Config.Silent.Active then
            if math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                local targetPart, targetPlayer = GetSilentTarget()
                
                if targetPart and targetPlayer then
                    local uniqueID, data, fireTime
                    
                    if type(args[2]) == "table" and rawget(args[2], "bullets") then
                        data = args[2]
                    elseif type(args[3]) == "table" and rawget(args[3], "bullets") then
                        uniqueID = args[2]
                        data = args[3]
                        fireTime = args[4]
                    else
                        -- Try raw check without rawget
                        if type(args[2]) == "table" then
                            data = args[2]
                            if not data.bullets then
                                return oldSend(self, ...)
                            end
                        else
                            return oldSend(self, ...)
                        end
                    end
                    
                    local firePos = data.firepos
                    if cameraModule and cameraModule.basecframe then
                        firePos = cameraModule.basecframe.Position
                        data.firepos = firePos
                        if data.camerapos then data.camerapos = firePos end
                    end
                    
                    local targetPos = targetPart.Position
                    local traj = CalcTrajectory(firePos, targetPos)
                    
                    for _, bullet in pairs(data.bullets) do
                        bullet[1] = traj
                    end
                    
                    if uniqueID then
                        oldSend(self, "newbullets", uniqueID, data, fireTime)
                        for _, bullet in pairs(data.bullets) do
                            if bullet[2] then
                                oldSend(self, "bullethit", uniqueID, targetPlayer, targetPos, targetPart.Name, bullet[2], fireTime)
                            end
                        end
                    else
                        oldSend(self, "newbullets", data)
                        for _, bullet in pairs(data.bullets) do
                            if bullet[2] then
                                oldSend(self, "bullethit", targetPlayer, targetPos, targetPart, bullet[2])
                            end
                        end
                    end
                    
                    return
                end
            end
        end
        
        if args[1] == "bullethit" and Config.Silent.Enabled and Config.Silent.Active then
            return
        end
        
        return oldSend(self, ...)
    end
    
    -- Verify
    if rawget(network, "send") ~= oldSend then
        networkHooked = true
        print("[PF v4.3] Network hook SUCCESS")
        return true
    else
        warn("[PF v4.3] Network hook may have FAILED")
        networkHooked = true -- Still try
        return true
    end
end

-- Namecall fallback
local OldNamecall
local function SetupNamecallFallback()
    if networkHooked or not hookmetamethod then return end
    OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if not checkcaller() and Config.Silent.Enabled and Config.Silent.Active and silentTarget and silentTarget.Parent then
            if math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                local tPos = silentTarget.Position
                if self == Workspace or self == workspace then
                    if method == "Raycast" then
                        local o, d = ...
                        if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                            return OldNamecall(self, o, (tPos - o).Unit * d.Magnitude, select(3, ...))
                        end
                    end
                    if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                        local ray = select(1, ...)
                        if typeof(ray) == "Ray" then
                            return OldNamecall(self, Ray.new(ray.Origin, (tPos - ray.Origin).Unit * ray.Direction.Magnitude), select(2, ...))
                        end
                    end
                end
            end
        end
        return OldNamecall(self, ...)
    end))
    print("[PF v4.3] Namecall fallback applied")
end

SetupNetworkHook()
if not networkHooked then SetupNamecallFallback() end

-- ============================================
-- ESP SYSTEM (FIXED)
-- Uses direct part positions, NOT GetPivot
-- Tracks via DescendantAdded like script 1
-- ============================================
local ESPStore = {}

local function CreateESPDrawings()
    local d = {}
    d.Outline = Drawing.new("Square"); d.Outline.Thickness = 3; d.Outline.Filled = false; d.Outline.Color = Color3.fromRGB(0,0,0); d.Outline.Transparency = 0.5; d.Outline.Visible = false
    d.Box = Drawing.new("Square"); d.Box.Thickness = 1; d.Box.Filled = false; d.Box.Visible = false
    d.Name = Drawing.new("Text"); d.Name.Size = 13; d.Name.Center = true; d.Name.Outline = true; d.Name.Font = 2; d.Name.Visible = false
    d.Distance = Drawing.new("Text"); d.Distance.Size = 12; d.Distance.Center = true; d.Distance.Outline = true; d.Distance.Font = 2; d.Distance.Visible = false
    d.Weapon = Drawing.new("Text"); d.Weapon.Size = 12; d.Weapon.Center = true; d.Weapon.Outline = true; d.Weapon.Font = 2; d.Weapon.Color = Color3.fromRGB(0,255,30); d.Weapon.Visible = false
    d.HealthBG = Drawing.new("Square"); d.HealthBG.Thickness = 1; d.HealthBG.Filled = true; d.HealthBG.Color = Color3.fromRGB(0,0,0); d.HealthBG.Transparency = 0.5; d.HealthBG.Visible = false
    d.HealthBar = Drawing.new("Square"); d.HealthBar.Thickness = 1; d.HealthBar.Filled = true; d.HealthBar.Visible = false
    return d
end

local function GetWeaponName(model)
    local w = model:FindFirstChildWhichIsA("Model")
    if w then
        local parts = string.split(w.Name, " ")
        if #parts > 1 then
            local name = ""
            for i = 1, #parts - 1 do
                name = name .. parts[i]
                if i < #parts - 1 then name = name .. " " end
            end
            return name
        end
        return w.Name
    end
    return nil
end

local function AddModel(model)
    if ESPStore[model] then return end
    if not model:IsA("Model") then return end
    ESPStore[model] = CreateESPDrawings()
end

local function RemoveModel(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do pcall(function() obj:Remove() end) end
    ESPStore[model] = nil
end

local function HideModel(model)
    local d = ESPStore[model]
    if not d then return end
    for _, obj in pairs(d) do pcall(function() obj.Visible = false end) end
end

-- Register existing
for _, team in ipairs(PlayersFolder:GetChildren()) do
    for _, model in ipairs(team:GetChildren()) do
        AddModel(model)
    end
end

-- Watch changes
PlayersFolder.DescendantAdded:Connect(function(desc)
    if desc:IsA("Model") and desc.Parent and desc.Parent.Parent == PlayersFolder then
        AddModel(desc)
    end
end)
PlayersFolder.DescendantRemoving:Connect(function(desc)
    if desc:IsA("Model") then RemoveModel(desc) end
end)

-- ESP update function - FIXED: use part positions directly
local function UpdateESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for m in pairs(ESPStore) do HideModel(m) end
        return
    end
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    -- Local position for distance
    local localPos = Camera.CFrame.Position
    local ig = Workspace:FindFirstChild("Ignore")
    if ig then
        local rp = ig:FindFirstChild("RefPlayer")
        if rp then
            local hrp = rp:FindFirstChild("HumanoidRootPart") or rp:FindFirstChild("Torso")
            if hrp then localPos = hrp.Position end
        end
    end
    
    for model, esp in pairs(ESPStore) do
        if not model.Parent or not model.Parent.Parent then
            HideModel(model)
            continue
        end
        
        if model.Name == LocalPlayer.Name then
            HideModel(model)
            continue
        end
        
        local isEnemy = IsEnemyModel(model)
        if Config.ESP.TeamCheck and not isEnemy then
            HideModel(model)
            continue
        end
        
        -- Get position from actual parts (NOT GetPivot)
        local rootPart = model:FindFirstChild("HumanoidRootPart")
            or model:FindFirstChild("Torso")
            or model:FindFirstChild("Head")
        
        if not rootPart then
            HideModel(model)
            continue
        end
        
        local position = rootPart.Position
        local dist = (localPos - position).Magnitude
        
        if dist > Config.ESP.MaxDistance then HideModel(model) continue end
        
        local sp, onScreen = Camera:WorldToViewportPoint(position)
        if not onScreen then HideModel(model) continue end
        
        -- Box calculation using actual part positions
        local head = model:FindFirstChild("Head")
        local headPos = head and head.Position or (position + Vector3.new(0, 1.5, 0))
        local feetPos = position - Vector3.new(0, 3, 0)
        
        -- Project corners using character dimensions
        local cf = CFrame.new(position, position + Camera.CFrame.LookVector)
        local right = cf.RightVector
        
        local topLeft = Camera:WorldToViewportPoint(headPos + Vector3.new(0, 0.5, 0) - right * 2.5)
        local topRight = Camera:WorldToViewportPoint(headPos + Vector3.new(0, 0.5, 0) + right * 2.5)
        local botLeft = Camera:WorldToViewportPoint(feetPos - right * 2.5)
        local botRight = Camera:WorldToViewportPoint(feetPos + right * 2.5)
        
        local topY = math.min(topLeft.Y, topRight.Y)
        local botY = math.max(botLeft.Y, botRight.Y)
        local leftX = math.min(topLeft.X, botLeft.X)
        local rightX = math.max(topRight.X, botRight.X)
        
        local height = math.max(botY - topY, 10)
        local width = math.max(rightX - leftX, height * 0.6)
        local centerX = (leftX + rightX) / 2
        local minX = centerX - width / 2
        
        -- Color
        local color
        if not isEnemy then
            color = Color3.fromRGB(80, 150, 255)
        else
            color = IsVisible(model) and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
        end
        
        -- BOX
        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, topY - 1)
            esp.Outline.Visible = true
            
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, topY)
            esp.Box.Color = color
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end
        
        -- NAME
        if Config.ESP.Names then
            esp.Name.Text = model.Name
            esp.Name.Position = Vector2.new(centerX, topY - 16)
            esp.Name.Color = color
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        -- DISTANCE
        if Config.ESP.Distance then
            esp.Distance.Text = "[" .. math.floor(dist) .. "] studs"
            esp.Distance.Position = Vector2.new(centerX, botY + 2)
            esp.Distance.Color = color
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end
        
        -- WEAPON
        if Config.ESP.Names then
            local wep = GetWeaponName(model)
            if wep then
                esp.Weapon.Text = wep
                esp.Weapon.Position = Vector2.new(centerX, topY - 30)
                esp.Weapon.Visible = true
            else
                esp.Weapon.Visible = false
            end
        else
            esp.Weapon.Visible = false
        end
        
        -- HEALTH
        local hum = model:FindFirstChildOfClass("Humanoid")
        if Config.ESP.Boxes and hum and hum.MaxHealth > 0 then
            local hp = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
            local bh = height * hp
            local hc = hp > 0.5
                and Color3.fromRGB(math.floor(255 * (1 - hp) * 2), 255, 0)
                or Color3.fromRGB(255, math.floor(255 * hp * 2), 0)
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, topY)
            esp.HealthBG.Visible = true
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, topY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end
end

-- ============================================
-- HITBOX
-- ============================================
local HBExpanded = {}; local HBSizes = {}; local HBTransp = {}
local HBRand = {}; local HBRandT = {}; local lastHB = 0

local function RestoreHB(m)
    if not HBSizes[m] then return end
    for pn, sz in pairs(HBSizes[m]) do
        local p = m:FindFirstChild(pn)
        if p then pcall(function() p.Size = sz; p.Transparency = HBTransp[m][pn] end) end
    end
    HBExpanded[m] = nil; HBSizes[m] = nil; HBTransp[m] = nil; HBRand[m] = nil; HBRandT[m] = nil
end

local function CleanHB()
    for m in pairs(HBExpanded) do if m and m.Parent then RestoreHB(m) end end
    HBExpanded = {}; HBSizes = {}; HBTransp = {}; HBRand = {}; HBRandT = {}
end

local function ExpandHB(model, tp, size)
    if not HBSizes[model] then HBSizes[model] = {}; HBTransp[model] = {} end
    for _, pn in ipairs({"Head", "Torso", "HumanoidRootPart"}) do
        local p = model:FindFirstChild(pn)
        if p and p:IsA("BasePart") then
            if not HBSizes[model][pn] then
                HBSizes[model][pn] = p.Size; HBTransp[model][pn] = p.Transparency
            end
            pcall(function()
                if pn == tp then
                    p.CanCollide = false; p.Massless = true
                    p.Size = Vector3.new(size, size, size)
                    p.Transparency = Config.Hitbox.Transparency
                else
                    p.Size = HBSizes[model][pn]; p.Transparency = HBTransp[model][pn]
                end
            end)
        end
    end
    HBExpanded[model] = true
end

local function UpdateHB()
    if not Config.Hitbox.Enabled or not Config.Hitbox.Active then CleanHB() return end
    local now = tick()
    if now - lastHB < 0.05 then return end
    lastHB = now
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    local ef = GetEnemyTeamFolder()
    if not ef then return end
    local should = {}
    for _, m in ipairs(ef:GetChildren()) do
        if not m:IsA("Model") then continue end
        local pt = Config.Hitbox.TargetPart
        if pt == "Random" then
            local t = tick()
            if not HBRandT[m] or t - HBRandT[m] >= 0.5 then
                HBRand[m] = math.random(1,2) == 1 and "Head" or "Torso"; HBRandT[m] = t
            end
            pt = HBRand[m] or "Head"
        elseif pt == "HumanoidRootPart" and not m:FindFirstChild("HumanoidRootPart") then pt = "Torso" end
        if Config.Hitbox.Method == "HE (Static)" then
            should[m] = {p = pt, s = Config.Hitbox.MaxSize}
        else
            local cp = m:FindFirstChild(pt) or m:FindFirstChild("Head") or m:FindFirstChild("Torso")
            if not cp then continue end
            local mouse = UserInputService:GetMouseLocation()
            local fov = Config.Hitbox.FOVEnabled and Config.Hitbox.FOVRadius or Config.FOV.Radius
            local sp, on = Camera:WorldToViewportPoint(cp.Position)
            if not on then continue end
            local d = (mouse - Vector2.new(sp.X, sp.Y)).Magnitude
            if d > fov then continue end
            should[m] = {p = pt, s = 1 + (Config.Hitbox.MaxSize - 1) * (1 - d/fov)}
        end
    end
    for m in pairs(HBExpanded) do
        if not should[m] then
            if m and m.Parent then RestoreHB(m) else
                HBExpanded[m] = nil; HBSizes[m] = nil; HBTransp[m] = nil; HBRand[m] = nil; HBRandT[m] = nil
            end
        end
    end
    for m, d in pairs(should) do ExpandHB(m, d.p, d.s) end
end

-- ============================================
-- AIMBOT
-- ============================================
local aimbotLocked = nil
local abRand = {"Head"}; local abRandT = {0}

local function GetAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local ef = GetEnemyTeamFolder()
    if not ef then return nil end
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local ref = Config.Aimbot.Method == "Aimbot" and Vector2.new(vp.X/2, vp.Y/2) or UserInputService:GetMouseLocation()
    if Config.Aimbot.Method == "Aimlock" and aimbotLocked and aimbotLocked.Parent then
        local s = Config.Aimbot.TargetPart or "Head"
        local tp = aimbotLocked:FindFirstChild(PART_MAP[s] or s) or aimbotLocked:FindFirstChild("Head")
        if tp and (not Config.Aimbot.VisibleCheck or IsVisible(aimbotLocked)) then
            local sp, on = Camera:WorldToViewportPoint(tp.Position)
            if on then return tp end
        end
        aimbotLocked = nil
    end
    local bestP, bestD, bestM = nil, fov, nil
    for _, m in ipairs(ef:GetChildren()) do
        if not m:IsA("Model") then continue end
        local s = Config.Aimbot.TargetPart or "Head"
        if s == "Random" then
            local t = tick()
            if t - abRandT[1] > 0.5 then
                local v = {}
                for _, pn in ipairs(PF_PARTS) do if m:FindFirstChild(pn) then table.insert(v, pn) end end
                if #v > 0 then abRand[1] = v[math.random(1,#v)] end; abRandT[1] = t
            end
            s = abRand[1]
        end
        local p = m:FindFirstChild(PART_MAP[s] or s) or m:FindFirstChild("Head") or m:FindFirstChild("Torso")
        if not p then continue end
        if Config.Aimbot.VisibleCheck and not IsVisible(m) then continue end
        local sp, on = Camera:WorldToViewportPoint(p.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestD then bestD = d; bestP = p; bestM = m end
    end
    if Config.Aimbot.Method == "Aimlock" and bestM then aimbotLocked = bestM end
    return bestP
end

-- ============================================
-- MAIN LOOPS
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    if not networkHooked and Config.Silent.Enabled and Config.Silent.Active then
        silentTarget = GetSilentTarget()
    elseif not networkHooked then
        silentTarget = nil
    end
    
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local t = GetAimbotTarget()
        if t then
            local pos = t.Position
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                pcall(function()
                    local vel = t.AssemblyLinearVelocity
                    if vel and vel.Magnitude > 0.5 then pos = pos + vel * Config.Aimbot.Prediction end
                end)
            end
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                Camera.CFrame = sm <= 1 and CFrame.lookAt(cur.Position, pos) or cur:Lerp(CFrame.lookAt(cur.Position, pos), 1/sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                    if math.sqrt(dx*dx+dy*dy) > 1 then
                        local spd = math.clamp(1/sm, 0.05, 0.8)
                        local mx, my = math.clamp(dx*spd,-150,150), math.clamp(dy*spd,-150,150)
                        if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then
                            (mousemoverel or function() end)(mx, my)
                        end
                    end
                end
            end
        elseif not Config.Aimbot.Active then aimbotLocked = nil end
    elseif not Config.Aimbot.Active then aimbotLocked = nil end
end)

RunService.Heartbeat:Connect(function()
    UpdateESP()
    UpdateHB()
end)

-- ============================================
-- SIGNALS & CLEANUP
-- ============================================
getgenv().AX_PF_HandlesESP = true
getgenv().AX_PF_HandlesHitbox = true
getgenv().AX_PF_HandlesAimbot = true

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    silentTarget = nil; aimbotLocked = nil
    CleanHB()
    task.wait(2)
    FindModuleCache()
    ExtractModules()
    if not networkHooked then SetupNetworkHook() end
end)

getgenv().AX_PFLoaded = true

local method = networkHooked and "Network Hook" or "Namecall Fallback"
print("  ╔═══════════════════════════════════════════════════╗")
print("  ║     PF MODULE v4.3 LOADED                         ║")
print("  ╠═══════════════════════════════════════════════════╣")
print("  ║  Silent: " .. method)
print("  ║  ESP:    Part-based tracking")
print("  ║  Team:   " .. (GetLocalTeamName() or "?"))
print("  ╚═══════════════════════════════════════════════════╝")
