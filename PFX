--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Phantom Forces Module v4.0            ║
    ║                                                           ║
    ║  Silent Aim: network.send hook ("newbullets" packet)      ║
    ║  ESP: PF workspace structure (Players/Ghosts|Phantoms)    ║
    ║  Hitbox: PF-specific model expansion                      ║
    ║                                                           ║
    ║  Creator: ElSacaLeche                                     ║
    ╚═══════════════════════════════════════════════════════════╝

    PF CHARACTER STRUCTURE:
    Workspace.Players
    ├── Ghosts   → [PlayerModel] → Head/Torso/HumanoidRootPart
    └── Phantoms → [PlayerModel] → Head/Torso/HumanoidRootPart

    PF PART IDENTIFICATION (sin nombres estándar):
    - Head:   BasePart con NameTagGui hijo
    - Torso:  BasePart con MeshId == rbxassetid://4049240078
    - Arm:    BasePart con MeshId == rbxassetid://4049240209
    - Leg:    BasePart con MeshId == rbxassetid://4049240323

    SILENT AIM: network.send hook (CORRECTO para PF)
    ─────────────────────────────────────────────────
    PF NO usa workspace:Raycast para registrar hits.
    Usa su propio sistema de red. El flujo real es:

      client → network.send("newbullets", uid, data, fireTime)
        data.bullets[i][1] = Vector3 (dirección del disparo)
        data.firepos        = posición de origen del disparo

      client → network.send("bullethit", uid, player, pos, part, bulletData, fireTime)

    Para silent aim CORRECTO:
    1. Hookear network.send
    2. En "newbullets": redirigir data.bullets[i][1] al target
    3. Llamar send original con data modificada
    4. Enviar "bullethit" manualmente al servidor

    CÓMO ENCONTRAR network:
    - Método A (Actor): getrenv().shared.require("NetworkClient")
    - Método B (getgc): buscar tabla con rawget(v, "send")
      y rawget(v, "getbodyparts") en upvalues

    POR QUÉ EL HOOK DE NAMECALL NO FUNCIONABA:
    - workspace:Raycast() es para colisiones visuales/físicas
    - PF no valida hits server-side vía raycast del cliente
    - El hit real va por NetworkClient.send → servidor lo procesa
    - Interceptar raycast solo afecta efectos locales, no el daño
]]

-- ============================================
-- WAIT FOR CONFIG
-- ============================================
if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end
local Config = getgenv().AX_Config

local cloneref    = cloneref    or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local checkcaller = checkcaller or function() return false end

local Players         = cloneref(game:GetService("Players"))
local RunService      = cloneref(game:GetService("RunService"))
local UserInputService= cloneref(game:GetService("UserInputService"))
local Workspace       = cloneref(game:GetService("Workspace"))
local Camera          = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- STATE
-- ============================================
local pfTarget           = nil
local pfAimbotLockedModel= nil

local PF_ESPObjects      = {}
local PF_LastESPUpdate   = 0
local PF_ESP_RATE        = 0.08

local PF_ExpandedModels     = {}
local PF_OriginalSizes      = {}
local PF_OriginalTransp     = {}
local PF_OriginalCanCollide = {}
local PF_OriginalMassless   = {}
local PF_RandomPartSel      = {}
local PF_LastRandomSwitch   = {}
local PF_LastHitboxUpdate   = 0
local PF_HITBOX_RATE        = 0.05

-- ============================================
-- PF TEAM / FOLDER HELPERS
-- ============================================
local function GetLocalTeamName()
    local team = LocalPlayer.Team
    return team and team.Name or nil
end
local function GetEnemyTeamName()
    local t = GetLocalTeamName()
    if t == "Ghosts"   then return "Phantoms" end
    if t == "Phantoms" then return "Ghosts"   end
    return nil
end
local function GetPlayersFolder()
    return Workspace:FindFirstChild("Players")
end
local function GetTeamFolder(name)
    local pf = GetPlayersFolder()
    return pf and name and pf:FindFirstChild(name) or nil
end
local function GetEnemyFolder()   return GetTeamFolder(GetEnemyTeamName())  end
local function GetLocalFolder()   return GetTeamFolder(GetLocalTeamName())  end

-- ============================================
-- PF PART IDENTIFICATION
-- Script 4 method: buscar por MeshId / NameTagGui
-- ============================================
local function IdentifyPFParts(model)
    -- Renombra las partes al primer frame (igual que Script 4)
    -- Util para GetAllEnemyModels si los nombres son raros
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            -- Head: tiene NameTagGui hijo
            if part:FindFirstChild("NameTagGui") then
                part.Name = "Head"
            end
            local mesh = part:FindFirstChildOfClass("SpecialMesh")
            if mesh then
                if mesh.MeshId == "rbxassetid://4049240078" then part.Name = "Torso"
                elseif mesh.MeshId == "rbxassetid://4049240209" then part.Name = "Arm"
                elseif mesh.MeshId == "rbxassetid://4049240323" then part.Name = "Leg"
                end
            end
        end
    end
end

-- ============================================
-- MODEL COLLECTORS
-- ============================================
local function GetAllEnemyModels()
    local models = {}
    local folder = GetEnemyFolder()
    if not folder then return models end
    for _, child in ipairs(folder:GetChildren()) do
        if child:IsA("Model") and child.Name ~= LocalPlayer.Name then
            local head  = child:FindFirstChild("Head")
            local torso = child:FindFirstChild("Torso") or child:FindFirstChild("HumanoidRootPart")
            if head or torso then
                table.insert(models, child)
            end
        end
    end
    return models
end

local function GetAllPlayerModels()
    local result = {}
    local pf = GetPlayersFolder()
    if not pf then return result end
    local localTeam = GetLocalTeamName()
    for _, teamFolder in ipairs(pf:GetChildren()) do
        local isEnemy = (teamFolder.Name ~= localTeam)
        for _, model in ipairs(teamFolder:GetChildren()) do
            if model:IsA("Model") and model.Name ~= LocalPlayer.Name then
                local head  = model:FindFirstChild("Head")
                local torso = model:FindFirstChild("Torso") or model:FindFirstChild("HumanoidRootPart")
                if head or torso then
                    table.insert(result, {model=model, teamName=teamFolder.Name, isEnemy=isEnemy})
                end
            end
        end
    end
    return result
end

-- ============================================
-- VISIBILITY
-- ============================================
local _pfVisParams = RaycastParams.new()
_pfVisParams.FilterType = Enum.RaycastFilterType.Exclude
_pfVisParams.IgnoreWater = true

local function UpdatePFVisFilter(targetModel)
    local list = {targetModel}
    if LocalPlayer.Character then table.insert(list, LocalPlayer.Character) end
    local myFolder = GetLocalFolder()
    if myFolder then
        local myModel = myFolder:FindFirstChild(LocalPlayer.Name)
        if myModel then table.insert(list, myModel) end
    end
    _pfVisParams.FilterDescendantsInstances = list
end

local function IsPFVisible(targetModel, targetPart)
    if not targetPart then return false end
    UpdatePFVisFilter(targetModel)
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    local origin = cam.CFrame.Position
    local dir    = targetPart.Position - origin
    local dist   = dir.Magnitude
    if dist < 3 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.5), _pfVisParams)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(targetModel)
end

-- ============================================
-- TARGET PART RESOLVER
-- ============================================
local PF_PARTS = {"Head","Torso","HumanoidRootPart","Arm","Leg"}

local pfSilentRandomPart = "Head"
local pfSilentRandomTime = 0
local pfAimbotRandomPart = "Head"
local pfAimbotRandomTime = 0

local function GetPFPart(model, setting, randomPart, randomTime)
    if setting == "Random" then
        local t = tick()
        if t - randomTime > (Config.Silent.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(PF_PARTS) do
                local p = model:FindFirstChild(n)
                if p and p:IsA("BasePart") then table.insert(valid, n) end
            end
            if #valid > 0 then randomPart = valid[math.random(1,#valid)] end
            randomTime = t
        end
        local p = model:FindFirstChild(randomPart)
        return (p and p:IsA("BasePart") and p), randomPart, randomTime
    end
    local p = model:FindFirstChild(setting)
           or model:FindFirstChild("Head")
           or model:FindFirstChild("Torso")
           or model:FindFirstChild("HumanoidRootPart")
    return p, randomPart, randomTime
end

-- ============================================
-- CLOSEST TARGET (Silent Aim)
-- ============================================
local function GetClosestPFTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local enemyModels = GetAllEnemyModels()
    local fovRadius   = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos    = UserInputService:GetMouseLocation()
    local closest, closestDist = nil, fovRadius
    for _, model in ipairs(enemyModels) do
        local part, rp, rt = GetPFPart(model, Config.Silent.TargetPart, pfSilentRandomPart, pfSilentRandomTime)
        pfSilentRandomPart = rp pfSilentRandomTime = rt
        if not part then continue end
        local sp, on = Camera:WorldToViewportPoint(part.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if d >= closestDist then continue end
        if Config.Silent.VisibleCheck and not IsPFVisible(model, part) then continue end
        closestDist = d
        closest     = part
    end
    return closest
end

-- ============================================
-- CLOSEST TARGET (Aimbot)
-- ============================================
local function GetClosestPFAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil, nil end
    local enemyModels = GetAllEnemyModels()
    local fovRadius   = Config.Aimbot.FOVRadius or 150
    local vp          = Camera.ViewportSize
    local center      = Vector2.new(vp.X/2, vp.Y/2)
    local mousePos    = UserInputService:GetMouseLocation()
    local ref         = Config.Aimbot.Method == "Aimbot" and center or mousePos

    -- Aimlock sticky
    if Config.Aimbot.Method == "Aimlock" and pfAimbotLockedModel then
        if pfAimbotLockedModel.Parent then
            local part, rp, rt = GetPFPart(pfAimbotLockedModel, Config.Aimbot.TargetPart, pfAimbotRandomPart, pfAimbotRandomTime)
            pfAimbotRandomPart = rp pfAimbotRandomTime = rt
            if part then
                if not Config.Aimbot.VisibleCheck or IsPFVisible(pfAimbotLockedModel, part) then
                    local sp, on = Camera:WorldToViewportPoint(part.Position)
                    if on then return part, pfAimbotLockedModel end
                end
            end
        end
        pfAimbotLockedModel = nil
    end

    local closestPart, closestModel, closestDist = nil, nil, fovRadius
    for _, model in ipairs(enemyModels) do
        local part, rp, rt = GetPFPart(model, Config.Aimbot.TargetPart, pfAimbotRandomPart, pfAimbotRandomTime)
        pfAimbotRandomPart = rp pfAimbotRandomTime = rt
        if not part then continue end
        if Config.Aimbot.VisibleCheck and not IsPFVisible(model, part) then continue end
        local sp, on = Camera:WorldToViewportPoint(part.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < closestDist then
            closestDist = d closestPart = part closestModel = model
        end
    end
    if Config.Aimbot.Method == "Aimlock" and closestModel then
        pfAimbotLockedModel = closestModel
    end
    return closestPart, closestModel
end

-- ============================================
-- SILENT AIM: network.send HOOK
-- ─────────────────────────────────────────────
-- PF hit registration flow:
--   network.send("newbullets", uniqueID, data, fireTime)
--     data = {
--       firepos  = Vector3 (origin of shot),
--       camerapos= Vector3,
--       bullets  = { {direction:Vector3, bulletData}, ... }
--     }
--   network.send("bullethit", uid, targetPlayer, hitPos, hitPart, bulletData, fireTime)
--
-- Para silent aim:
--   1. Modificar direction en cada bullet para apuntar al target
--   2. Enviar newbullets modificado
--   3. Enviar bullethit manualmente (registro instantáneo del hit)
-- ============================================
local pfNetworkClient = nil
local pfReplicationInterface = nil
local pfNetworkHooked = false
local pfNetworkOld    = nil

-- Método A: Actor-aware require (PF usa Actors)
local function TryRequireMethod()
    local ok, shared_require = pcall(function()
        return assert(getrenv().shared.require, "no shared require")
    end)
    if not ok then return end
    
    pcall(function()
        pfNetworkClient = shared_require("NetworkClient")
        pfReplicationInterface = shared_require("ReplicationInterface")
    end)
end

-- Método B: getgc scan (más universal, funciona fuera del Actor)
local function TryGetGCMethod()
    if not getgc then return end
    
    local network, getbodyparts, gamelogic, trajectory_fn
    
    for _, v in ipairs(getgc(true)) do
        if type(v) == "table" then
            -- NetworkClient tiene método "send"
            if not network and rawget(v, "send") and type(rawget(v,"send")) == "function" then
                -- Verificar que también tenga otros métodos de red
                if rawget(v, "receive") or rawget(v, "connect") or rawget(v, "disconnect") then
                    network = v
                end
            end
            -- getbodyparts como método de tabla
            if not getbodyparts and rawget(v, "getbodyparts") then
                getbodyparts = v
            end
        end
        -- Buscar en upvalues de funciones
        if type(v) == "function" and debug and debug.getupvalues then
            pcall(function()
                local uvs = debug.getupvalues(v)
                if type(uvs) ~= "table" then return end
                for _, uv in pairs(uvs) do
                    if type(uv) == "table" then
                        if not network and rawget(uv, "send") and (rawget(uv,"receive") or rawget(uv,"connect")) then
                            network = uv
                        end
                        if not getbodyparts and rawget(uv, "getbodyparts") then
                            getbodyparts = uv
                        end
                        if not gamelogic and rawget(uv, "gammo") then
                            gamelogic = uv
                        end
                    end
                end
            end)
        end
    end
    
    if network then pfNetworkClient = network end
    if getbodyparts then getgenv().AX_PF_Getbodyparts = getbodyparts end
    if gamelogic    then getgenv().AX_PF_Gamelogic    = gamelogic    end
end

local function HookNetworkSend()
    if pfNetworkHooked or not pfNetworkClient then return end
    if type(pfNetworkClient.send) ~= "function" then return end
    
    pfNetworkHooked = true
    local old = pfNetworkClient.send
    pfNetworkOld = old
    
    pfNetworkClient.send = function(self, name, ...)
        -- Interceptar "bullethit" original del juego para no duplicarlo
        if name == "bullethit" then
            -- Solo bloquear si nosotros vamos a enviar el nuestro
            -- (cuando silent aim está activo y tenemos target)
            if Config.Silent.Enabled and Config.Silent.Active and pfTarget and pfTarget.Parent then
                return -- bloquear el bullethit del juego, nosotros enviamos el nuestro
            end
            return old(self, name, ...)
        end
        
        if name == "newbullets" then
            if Config.Silent.Enabled and Config.Silent.Active
                and pfTarget and pfTarget.Parent then
                
                if math.random(1,100) > Config.Silent.HitChance then
                    return old(self, name, ...)
                end
                
                local uniqueID, data, fireTime = ...
                
                if data and data.bullets and type(data.bullets) == "table" then
                    local targetPos = pfTarget.Position
                    local firepos   = data.firepos or (Camera and Camera.CFrame.Position) or Vector3.new()
                    
                    -- Override firepos y camerapos para máxima efectividad
                    -- (algunos scripts de referencia hacen esto)
                    -- data.firepos   = firepos  -- no modificar origen para evitar detección
                    
                    for _, bullet in ipairs(data.bullets) do
                        if type(bullet) == "table" and bullet[1] then
                            -- bullet[1] = dirección del disparo (Vector3)
                            -- Redirigir hacia el target
                            local newDir = (targetPos - firepos)
                            if newDir.Magnitude > 0 then
                                bullet[1] = newDir.Unit
                            end
                        end
                    end
                    
                    -- Enviar newbullets modificado
                    old(self, name, uniqueID, data, fireTime)
                    
                    -- Enviar bullethit manualmente para registro inmediato
                    -- Estructura: "bullethit", uid, targetPlayer, hitPos, hitPart, bulletData, fireTime
                    for _, bullet in ipairs(data.bullets) do
                        if type(bullet) == "table" then
                            -- Encontrar a qué Player corresponde el target
                            local targetPlayer = nil
                            local playersFolder = GetPlayersFolder()
                            if playersFolder then
                                for _, teamFolder in ipairs(playersFolder:GetChildren()) do
                                    for _, model in ipairs(teamFolder:GetChildren()) do
                                        if model:IsA("Model") then
                                            if model:IsAncestorOf(pfTarget) or model == pfTarget.Parent then
                                                -- Buscar Player por nombre del modelo
                                                targetPlayer = Players:FindFirstChild(model.Name)
                                            end
                                        end
                                    end
                                end
                            end
                            
                            if targetPlayer then
                                pcall(function()
                                    old(self, "bullethit",
                                        uniqueID,
                                        targetPlayer,
                                        pfTarget.Position,
                                        pfTarget,
                                        bullet[2],   -- bulletData (ID, etc.)
                                        fireTime
                                    )
                                end)
                            end
                        end
                    end
                    
                    return -- ya enviamos, no llamar old de nuevo
                end
            end
        end
        
        return old(self, name, ...)
    end
    
    print("  ✅ PFX v4.0 - network.send hooked!")
end

-- Intentar hookear
task.spawn(function()
    -- Método A primero
    TryRequireMethod()
    if pfNetworkClient then
        HookNetworkSend()
        return
    end
    
    -- Método B: getgc (puede tardar un poco en poblar)
    task.wait(2)
    TryGetGCMethod()
    if pfNetworkClient then
        HookNetworkSend()
        return
    end
    
    -- Reintentar cada 3 segundos (por si el juego carga lento)
    for _ = 1, 5 do
        task.wait(3)
        TryRequireMethod()
        TryGetGCMethod()
        if pfNetworkClient then
            HookNetworkSend()
            return
        end
    end
    
    warn("  ⚠ PFX v4.0 - No se pudo hookear network.send. Silent Aim inactivo.")
end)

-- ============================================
-- PART IDENTIFICATION LOOP
-- Renames parts using Script 4 method on a timer
-- so GetAllEnemyModels() always finds Head/Torso
-- ============================================
task.spawn(function()
    while true do
        task.wait(1)
        local pf = GetPlayersFolder()
        if pf then
            for _, teamFolder in ipairs(pf:GetChildren()) do
                for _, model in ipairs(teamFolder:GetChildren()) do
                    if model:IsA("Model") then
                        pcall(IdentifyPFParts, model)
                    end
                end
            end
        end
    end
end)

-- ============================================
-- RENDER LOOP: target tracking + aimbot
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera

    -- Silent aim target
    if Config.Silent.Enabled and Config.Silent.Active then
        pfTarget = GetClosestPFTarget()
    else
        pfTarget = nil
    end

    -- Aimbot
    if Config.Aimbot.Enabled and Config.Aimbot.Active then
        local aimPart = GetClosestPFAimbotTarget()
        if aimPart then
            local pos = aimPart.Position
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                pcall(function()
                    local vel = aimPart.AssemblyLinearVelocity
                    if vel and vel.Magnitude > 0.5 then
                        pos = pos + vel * Config.Aimbot.Prediction
                    end
                end)
            end
            local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
            if Config.Aimbot.Method == "Aimbot" then
                local cur = Camera.CFrame
                local tgt = CFrame.lookAt(cur.Position, pos)
                Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1/sm)
            else
                local sp, on = Camera:WorldToViewportPoint(pos)
                if on then
                    local mp = UserInputService:GetMouseLocation()
                    local dx, dy = sp.X-mp.X, sp.Y-mp.Y
                    local dist = math.sqrt(dx*dx+dy*dy)
                    if dist > 1 then
                        local spd = math.clamp(1/sm, 0.05, 0.8)
                        local mx = math.clamp(dx*spd, -150, 150)
                        local my = math.clamp(dy*spd, -150, 150)
                        if math.abs(mx)>0.3 or math.abs(my)>0.3 then
                            pcall(mousemoverel, mx, my)
                        end
                    end
                end
            end
        else
            if not Config.Aimbot.Active then pfAimbotLockedModel = nil end
        end
    else
        if not Config.Aimbot.Active then pfAimbotLockedModel = nil end
    end
end)

-- ============================================
-- ESP SYSTEM
-- ============================================
local function CreatePFESP(model)
    if PF_ESPObjects[model] then return end
    local e = {}

    e.Box = Drawing.new("Square")
    e.Box.Thickness=1 e.Box.Filled=false e.Box.Visible=false

    e.Outline = Drawing.new("Square")
    e.Outline.Thickness=3 e.Outline.Filled=false
    e.Outline.Color=Color3.fromRGB(0,0,0) e.Outline.Transparency=0.5 e.Outline.Visible=false

    e.Name = Drawing.new("Text")
    e.Name.Size=13 e.Name.Center=true e.Name.Outline=true
    e.Name.Color=Color3.fromRGB(255,255,255) e.Name.Visible=false

    e.Distance = Drawing.new("Text")
    e.Distance.Size=12 e.Distance.Center=true e.Distance.Outline=true
    e.Distance.Color=Color3.fromRGB(200,200,200) e.Distance.Visible=false

    e.HealthBG = Drawing.new("Square")
    e.HealthBG.Thickness=1 e.HealthBG.Filled=true
    e.HealthBG.Color=Color3.fromRGB(0,0,0) e.HealthBG.Transparency=0.5 e.HealthBG.Visible=false

    e.HealthBar = Drawing.new("Square")
    e.HealthBar.Thickness=1 e.HealthBar.Filled=true
    e.HealthBar.Color=Color3.fromRGB(0,255,0) e.HealthBar.Visible=false

    PF_ESPObjects[model] = e
end

local function HidePFESP(model)
    local e = PF_ESPObjects[model] if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible=false end) end
end

local function RemovePFESP(model)
    local e = PF_ESPObjects[model] if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    PF_ESPObjects[model] = nil
end

local function UpdatePFESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for model in pairs(PF_ESPObjects) do HidePFESP(model) end
        return
    end
    local now = tick()
    if now - PF_LastESPUpdate < PF_ESP_RATE then return end
    PF_LastESPUpdate = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    local allPlayers = GetAllPlayerModels()
    local active = {}

    for _, data in ipairs(allPlayers) do
        local model   = data.model
        local isEnemy = data.isEnemy
        active[model] = true

        if Config.ESP.TeamCheck and not isEnemy then HidePFESP(model) continue end

        if not PF_ESPObjects[model] then CreatePFESP(model) end
        local esp = PF_ESPObjects[model]
        if not esp then continue end

        local rootPart = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Torso")
        local head     = model:FindFirstChild("Head")
        if not rootPart then HidePFESP(model) continue end

        local dist = (Camera.CFrame.Position - rootPart.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HidePFESP(model) continue end

        local sp, on = Camera:WorldToViewportPoint(rootPart.Position)
        if not on then HidePFESP(model) continue end

        local headSP = {Y = sp.Y - 50}
        if head then
            local hs = Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0))
            headSP.Y = hs.Y
        end
        local footSP = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0,3,0))

        local height = math.max(math.abs(headSP.Y - footSP.Y), 10)
        local width  = height / 2
        local minX   = sp.X - width/2
        local minY   = headSP.Y

        local espColor
        if not isEnemy then
            espColor = Color3.fromRGB(80,150,255)
        else
            local isVis = IsPFVisible(model, head or rootPart)
            espColor = isVis and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,50,50)
        end

        if Config.ESP.Boxes then
            esp.Outline.Size=Vector2.new(width+2,height+2)
            esp.Outline.Position=Vector2.new(minX-1,minY-1) esp.Outline.Visible=true
            esp.Box.Size=Vector2.new(width,height)
            esp.Box.Position=Vector2.new(minX,minY)
            esp.Box.Color=espColor esp.Box.Visible=true
        else
            esp.Box.Visible=false esp.Outline.Visible=false
        end

        if Config.ESP.Names then
            esp.Name.Text=model.Name
            esp.Name.Position=Vector2.new(minX+width/2, minY-16)
            esp.Name.Color=espColor esp.Name.Visible=true
        else
            esp.Name.Visible=false
        end

        if Config.ESP.Distance then
            esp.Distance.Text=math.floor(dist).."m"
            esp.Distance.Position=Vector2.new(minX+width/2, minY+height+2)
            esp.Distance.Visible=true
        else
            esp.Distance.Visible=false
        end

        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if Config.ESP.Boxes and humanoid and humanoid.MaxHealth > 0 then
            local pct = math.clamp(humanoid.Health/humanoid.MaxHealth,0,1)
            local barH = height*pct
            local hc
            if pct > 0.5 then
                hc = Color3.fromRGB(math.floor(255*(1-pct)*2), 255, 0)
            else
                hc = Color3.fromRGB(255, math.floor(255*pct*2), 0)
            end
            esp.HealthBG.Size=Vector2.new(3,height)
            esp.HealthBG.Position=Vector2.new(minX-6,minY) esp.HealthBG.Visible=true
            esp.HealthBar.Size=Vector2.new(3,barH)
            esp.HealthBar.Position=Vector2.new(minX-6,minY+(height-barH))
            esp.HealthBar.Color=hc esp.HealthBar.Visible=true
        else
            esp.HealthBG.Visible=false esp.HealthBar.Visible=false
        end
    end

    for model in pairs(PF_ESPObjects) do
        if not active[model] then
            if not model.Parent then RemovePFESP(model)
            else HidePFESP(model) end
        end
    end
end

-- ============================================
-- HITBOX SYSTEM
-- ============================================
local function SavePFOriginal(model, partName, part)
    if not PF_OriginalSizes[model] then
        PF_OriginalSizes[model]      = {}
        PF_OriginalTransp[model]     = {}
        PF_OriginalCanCollide[model] = {}
        PF_OriginalMassless[model]   = {}
    end
    if not PF_OriginalSizes[model][partName] then
        PF_OriginalSizes[model][partName]      = part.Size
        PF_OriginalTransp[model][partName]     = part.Transparency
        PF_OriginalCanCollide[model][partName] = part.CanCollide
        PF_OriginalMassless[model][partName]   = part.Massless
    end
end

local function RestorePFHitbox(model)
    if not PF_OriginalSizes[model] then return end
    for partName, origSize in pairs(PF_OriginalSizes[model]) do
        local part = model:FindFirstChild(partName)
        if part then pcall(function()
            part.Size        = origSize
            part.Transparency= PF_OriginalTransp[model][partName]
            part.CanCollide  = PF_OriginalCanCollide[model][partName]
            part.Massless    = PF_OriginalMassless[model][partName]
        end) end
    end
    PF_ExpandedModels[model]     = nil
    PF_OriginalSizes[model]      = nil
    PF_OriginalTransp[model]     = nil
    PF_OriginalCanCollide[model] = nil
    PF_OriginalMassless[model]   = nil
    PF_RandomPartSel[model]      = nil
    PF_LastRandomSwitch[model]   = nil
end

local function CleanupAllPFHitboxes()
    for model in pairs(PF_ExpandedModels) do
        if model and model.Parent then RestorePFHitbox(model) end
    end
    PF_ExpandedModels={} PF_OriginalSizes={} PF_OriginalTransp={}
    PF_OriginalCanCollide={} PF_OriginalMassless={} PF_RandomPartSel={} PF_LastRandomSwitch={}
end

local function GetPFRandomPart(model)
    local t = tick()
    local interval = Config.Hitbox.RandomInterval or 0.5
    if not PF_LastRandomSwitch[model] or (t-PF_LastRandomSwitch[model]) >= interval then
        PF_RandomPartSel[model] = math.random(1,2)==1 and "Head" or "Torso"
        PF_LastRandomSwitch[model] = t
    end
    return PF_RandomPartSel[model] or "Head"
end

local function ExpandPFHitbox(model, partToModify, size)
    local partsToCheck = {"Head","Torso","HumanoidRootPart"}
    for _, partName in ipairs(partsToCheck) do
        local part = model:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            SavePFOriginal(model, partName, part)
            local shouldMod = (partName == partToModify)
            pcall(function()
                if shouldMod then
                    part.CanCollide=false part.Massless=true
                    part.Size=Vector3.new(size,size,size)
                    part.Transparency=Config.Hitbox.Transparency
                elseif PF_OriginalSizes[model] and PF_OriginalSizes[model][partName] then
                    part.Size        = PF_OriginalSizes[model][partName]
                    part.Transparency= PF_OriginalTransp[model][partName]
                    part.CanCollide  = PF_OriginalCanCollide[model][partName]
                    part.Massless    = PF_OriginalMassless[model][partName]
                end
            end)
        end
    end
    PF_ExpandedModels[model] = true
end

local function UpdatePFHitboxes()
    if not Config.Hitbox.Enabled or not Config.Hitbox.Active then
        CleanupAllPFHitboxes() return
    end
    local now = tick()
    if now - PF_LastHitboxUpdate < PF_HITBOX_RATE then return end
    PF_LastHitboxUpdate = now
    Camera = Workspace.CurrentCamera
    if not Camera then return end

    local enemyModels = GetAllEnemyModels()
    local shouldExpand = {}
    local mousePos = UserInputService:GetMouseLocation()
    local fovRadius = Config.Hitbox.FOVEnabled and Config.Hitbox.FOVRadius or Config.FOV.Radius

    for _, model in ipairs(enemyModels) do
        local ptm = Config.Hitbox.TargetPart
        if ptm == "Random"          then ptm = GetPFRandomPart(model)
        elseif ptm == "HumanoidRootPart" then
            if not model:FindFirstChild("HumanoidRootPart") then ptm = "Torso" end
        end
        if Config.Hitbox.Method == "HE (Static)" then
            shouldExpand[model] = {partToModify=ptm, size=Config.Hitbox.MaxSize}
        else
            local cp = model:FindFirstChild(ptm) or model:FindFirstChild("Head") or model:FindFirstChild("Torso")
            if not cp then continue end
            local sp, on = Camera:WorldToViewportPoint(cp.Position)
            if not on then continue end
            local sd = (mousePos - Vector2.new(sp.X, sp.Y)).Magnitude
            if sd > fovRadius then continue end
            local pf_factor = 1-(sd/fovRadius)
            shouldExpand[model] = {partToModify=ptm, size=1+(Config.Hitbox.MaxSize-1)*pf_factor}
        end
    end

    for model in pairs(PF_ExpandedModels) do
        if not shouldExpand[model] then
            if model and model.Parent then RestorePFHitbox(model)
            else
                PF_ExpandedModels[model]=nil PF_OriginalSizes[model]=nil
                PF_OriginalTransp[model]=nil PF_OriginalCanCollide[model]=nil
                PF_OriginalMassless[model]=nil PF_RandomPartSel[model]=nil
                PF_LastRandomSwitch[model]=nil
            end
        end
    end
    for model, data in pairs(shouldExpand) do
        ExpandPFHitbox(model, data.partToModify, data.size)
    end
end

-- ============================================
-- HEARTBEAT LOOP
-- ============================================
RunService.Heartbeat:Connect(function()
    UpdatePFESP()
    UpdatePFHitboxes()
end)

-- ============================================
-- PLAYERS FOLDER MONITORING
-- ============================================
task.spawn(function()
    local pf = GetPlayersFolder()
    if not pf then return end
    for _, teamFolder in ipairs(pf:GetChildren()) do
        if teamFolder:IsA("Folder") then
            teamFolder.ChildRemoved:Connect(function(child)
                if not child:IsA("Model") then return end
                if PF_ESPObjects[child]   then RemovePFESP(child) end
                if PF_ExpandedModels[child] then
                    PF_ExpandedModels[child]=nil PF_OriginalSizes[child]=nil
                    PF_OriginalTransp[child]=nil PF_OriginalCanCollide[child]=nil
                    PF_OriginalMassless[child]=nil PF_RandomPartSel[child]=nil
                    PF_LastRandomSwitch[child]=nil
                end
                if pfAimbotLockedModel == child then pfAimbotLockedModel = nil end
            end)
        end
    end
end)

-- ============================================
-- CHARACTER RESPAWN
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    pfTarget = nil
    pfAimbotLockedModel = nil
    CleanupAllPFHitboxes()
end)

-- ============================================
-- FLAGS AL MAIN SCRIPT
-- ============================================
getgenv().AX_PF_HandlesESP     = true
getgenv().AX_PF_HandlesHitbox  = true
getgenv().AX_PF_HandlesAimbot  = true
getgenv().AX_PF_HandlesSilent  = true   -- v4.0: ahora sí manejamos silent
getgenv().AX_PFLoaded          = true

local teamName = GetLocalTeamName() or "detecting..."
print("  ✅ PFX v4.0 - network.send hook (newbullets + bullethit)")
print("  ✅ PFX v4.0 - Part identifier (NameTagGui + MeshId)")
print("  ✅ PFX v4.0 - Custom ESP (model-keyed, color-coded)")
print("  ✅ PFX v4.0 - Custom Hitbox (DHE + HE)")
print("  ✅ PFX v4.0 - Custom Aimbot (PF models)")
print("  ✅ PFX v4.0 - Team: " .. teamName)
