--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Combat Arena Module v3                ║
    ║        BACS-Safe: NO metamethod hooks                     ║
    ║        Method: Direct Remote hookfunction                 ║
    ║        Creator: ElSacaLeche                               ║
    ╚═══════════════════════════════════════════════════════════╝
    
    WHY BACS KICKS:
    BACS (Byfron Anti-Cheat System) operates at PROCESS level.
    It detects:
    - hookmetamethod calls on game objects
    - __namecall, __newindex, __index modifications
    - Metatable tampering on core services
    
    BACS CANNOT be bypassed from Lua scripts.
    It depends on your EXECUTOR having Byfron bypass.
    
    WHAT WE CAN DO:
    - Avoid triggering BACS by NOT using hookmetamethod
    - Use hookfunction on specific remote FireServer instead
    - Use getconnections to intercept specific remotes
    - Scan for shooting remotes via getgc and hook them directly
    
    THIS METHOD:
    1. Scans getgc() for the game's shooting/firing functions
    2. Hooks them with hookfunction (NOT hookmetamethod)
    3. Redirects bullet/aim data inside those functions
    4. Falls back to remote scanning if GC scan fails
    5. NO metamethods touched = BACS stays quiet
]]

-- Wait for Config
if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local getconnections = getconnections
local getgc = getgc

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- ============================================
-- RESULTS TRACKING
-- ============================================
local BypassResults = {
    remotesHooked = 0,
    gcFunctionsHooked = 0,
    acFunctionsNeutralized = 0,
    kickBlocked = false,
    errorsBlocked = 0,
    method = "none"
}

-- ============================================
-- PHASE 1: SAFE AC NEUTRALIZATION
-- No metamethods - only hookfunction + getconnections
-- ============================================

-- 1A. Kick Protection (hookfunction only, no metatable)
pcall(function()
    local oldKick = LocalPlayer.Kick
    if typeof(oldKick) == "function" then
        hookfunction(oldKick, newcclosure(function(self, ...)
            if self == LocalPlayer then
                warn("[AX] Blocked kick: " .. tostring((...)))
                return
            end
            return oldKick(self, ...)
        end))
        BypassResults.kickBlocked = true
    end
end)

-- 1B. Error Suppression (getconnections only)
pcall(function()
    local ScriptContext = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        for _, conn in ipairs(getconnections(ScriptContext.Error)) do
            pcall(function()
                conn:Disable()
                BypassResults.errorsBlocked = BypassResults.errorsBlocked + 1
            end)
        end
    end
end)

-- 1C. LogService Suppression
pcall(function()
    local LogService = cloneref(game:GetService("LogService"))
    if getconnections then
        for _, conn in pairs(getconnections(LogService.MessageOut)) do
            if conn and conn.Function then
                pcall(function()
                    hookfunction(conn.Function, newcclosure(function(...) end))
                    BypassResults.errorsBlocked = BypassResults.errorsBlocked + 1
                end)
            end
        end
    end
end)

-- 1D. Integrity Check Disable
pcall(function()
    local ScriptContext = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        pcall(function()
            for _, conn in ipairs(getconnections(ScriptContext.ScriptAdded)) do
                pcall(function() conn:Disable() end)
            end
        end)
        pcall(function()
            for _, conn in ipairs(getconnections(ScriptContext.ScriptRemoved)) do
                pcall(function() conn:Disable() end)
            end
        end)
    end
end)

-- 1E. GC Signature Cleanup
pcall(function()
    if getgc then
        for _, obj in ipairs(getgc(true)) do
            if type(obj) == "table" then
                pcall(function()
                    local acKeys = {
                        "__acsignature", "__checksum", "__hash",
                        "__integrity", "__validation", "__exploit_flag"
                    }
                    for _, key in ipairs(acKeys) do
                        if rawget(obj, key) then
                            rawset(obj, key, nil)
                        end
                    end
                end)
            end
        end
    end
end)

-- 1F. Neutralize AC functions found in GC
pcall(function()
    if getgc then
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" then
                local ok, src = pcall(function()
                    return debug.info(v, "s")
                end)
                if ok and type(src) == "string" then
                    local acSources = {
                        "AntiCheat", "anticheat", "AntiExploit",
                        "Integrity", "Validation", "Detection",
                        "Security", "Checker", "Monitor", "Guard"
                    }
                    for _, keyword in ipairs(acSources) do
                        if src:find(keyword) then
                            pcall(function()
                                hookfunction(v, newcclosure(function(...)
                                    return nil
                                end))
                                BypassResults.acFunctionsNeutralized = BypassResults.acFunctionsNeutralized + 1
                            end)
                            break
                        end
                    end
                end
            end
            
            if typeof(v) == "table" then
                pcall(function()
                    local acTableKeys = {
                        "Detect", "detect", "Detected",
                        "Ban", "ban", "Report", "report",
                        "Flag", "flag", "Punish", "Violation"
                    }
                    for _, key in ipairs(acTableKeys) do
                        local func = rawget(v, key)
                        if typeof(func) == "function" then
                            hookfunction(func, newcclosure(function(...) return nil end))
                            BypassResults.acFunctionsNeutralized = BypassResults.acFunctionsNeutralized + 1
                        end
                    end
                end)
            end
        end
    end
end)

-- 1G. Block AC Remotes via getconnections
pcall(function()
    local function BlockACRemote(remote)
        if remote:IsA("RemoteEvent") and remote.OnClientEvent then
            pcall(function()
                for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                    pcall(function() conn:Disable() end)
                end
            end)
        end
    end
    
    for _, child in pairs(ReplicatedStorage:GetDescendants()) do
        if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
            local name = child.Name:lower()
            local acNames = {
                "anticheat", "anti_cheat", "integrity", "validation",
                "security", "detect", "report", "flag", "violation",
                "verify", "monitor", "bac", "guard", "sentinel"
            }
            for _, acName in ipairs(acNames) do
                if name:find(acName) then
                    BlockACRemote(child)
                    break
                end
            end
        end
    end
end)

print("[AX] CA Phase 1 complete: AC neutralized (no metamethods)")

-- ============================================
-- PHASE 2: TARGET FINDER
-- ============================================

local CurrentCATarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, Camera}
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, targetPartSetting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if targetPartSetting == "Random" then
        local validParts = {}
        for _, partName in ipairs(parts) do
            local part = character:FindFirstChild(partName)
            if part then table.insert(validParts, part) end
        end
        if #validParts > 0 then return validParts[math.random(1, #validParts)] end
    end
    return character:FindFirstChild(targetPartSetting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function GetClosestCATarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local screenCenter = Camera.ViewportSize / 2
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local targetPart = GetTargetPart(character, Config.Silent.TargetPart)
        if not targetPart then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(targetPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if screenDist < closestDist then
            closestDist = screenDist
            closest = targetPart
        end
    end
    
    return closest
end

-- ============================================
-- PHASE 3: SILENT AIM - DIRECT REMOTE HOOK
-- NO hookmetamethod - uses hookfunction on
-- specific RemoteEvent.FireServer instances
-- ============================================

-- METHOD A: Hook FireServer on specific shooting remotes
local hookedRemotes = {}

local function IsShootingRemote(name)
    local lower = name:lower()
    local shootKeywords = {
        "shoot", "fire", "bullet", "gun", "weapon",
        "attack", "cast", "projectile", "damage",
        "swing", "slash", "strike", "combat", "hit"
    }
    local acKeywords = {
        "anticheat", "anti_cheat", "integrity", "validation",
        "security", "detect", "report", "flag", "verify", "monitor"
    }
    
    -- Skip AC remotes
    for _, keyword in ipairs(acKeywords) do
        if lower:find(keyword) then return false end
    end
    
    for _, keyword in ipairs(shootKeywords) do
        if lower:find(keyword) then return true end
    end
    return false
end

local function ModifyShootingArgs(args)
    if not CurrentCATarget or not CurrentCATarget.Parent then return args end
    if not Config.Silent.Enabled or not Config.Silent.Active then return args end
    if math.random(1, 100) > Config.Silent.HitChance then return args end
    
    Camera = Workspace.CurrentCamera
    if not Camera then return args end
    
    for i, arg in ipairs(args) do
        if typeof(arg) == "Vector3" then
            local mag = arg.Magnitude
            if mag > 0.1 and mag < 5 then
                local origin = Camera.CFrame.Position
                args[i] = (CurrentCATarget.Position - origin).Unit * mag
            end
        elseif typeof(arg) == "CFrame" then
            args[i] = CFrame.new(arg.Position, CurrentCATarget.Position)
        elseif typeof(arg) == "Ray" then
            local newDir = (CurrentCATarget.Position - arg.Origin).Unit * arg.Direction.Magnitude
            args[i] = Ray.new(arg.Origin, newDir)
        elseif typeof(arg) == "table" then
            pcall(function()
                for key, value in pairs(arg) do
                    local keyLower = tostring(key):lower()
                    if typeof(value) == "Vector3" then
                        if keyLower:find("dir") or keyLower:find("direction")
                            or keyLower:find("look") or keyLower:find("aim") then
                            local origin = Camera.CFrame.Position
                            arg[key] = (CurrentCATarget.Position - origin).Unit
                        elseif keyLower:find("target") or keyLower:find("hit")
                            or keyLower:find("point") or keyLower:find("end") then
                            arg[key] = CurrentCATarget.Position
                        end
                    elseif typeof(value) == "CFrame" then
                        if keyLower:find("aim") or keyLower:find("camera")
                            or keyLower:find("look") or keyLower:find("cf") then
                            arg[key] = CFrame.new(value.Position, CurrentCATarget.Position)
                        end
                    end
                end
            end)
        end
    end
    
    return args
end

local function HookRemoteFireServer(remote)
    if hookedRemotes[remote] then return end
    
    pcall(function()
        local originalFire = remote.FireServer
        hookfunction(remote.FireServer, newcclosure(function(self, ...)
            if self == remote and Config.Silent.Enabled and Config.Silent.Active 
                and CurrentCATarget and CurrentCATarget.Parent then
                local args = {...}
                args = ModifyShootingArgs(args)
                return originalFire(self, unpack(args))
            end
            return originalFire(self, ...)
        end))
        hookedRemotes[remote] = true
        BypassResults.remotesHooked = BypassResults.remotesHooked + 1
    end)
end

-- Scan and hook existing shooting remotes
local function ScanAndHookRemotes()
    local function ScanFolder(folder)
        for _, child in pairs(folder:GetDescendants()) do
            if child:IsA("RemoteEvent") and IsShootingRemote(child.Name) then
                HookRemoteFireServer(child)
            end
        end
    end
    
    pcall(function() ScanFolder(ReplicatedStorage) end)
    pcall(function() ScanFolder(Workspace) end)
    pcall(function() ScanFolder(game:GetService("StarterPlayer")) end)
end

ScanAndHookRemotes()

-- METHOD B: Hook shooting functions found in GC
pcall(function()
    if getgc then
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "function" then
                local ok, name = pcall(function()
                    return debug.info(v, "n")
                end)
                if ok and type(name) == "string" then
                    local lower = name:lower()
                    if lower:find("shoot") or lower:find("fire") 
                        or lower:find("attack") or lower:find("bullet") then
                        pcall(function()
                            local original = v
                            hookfunction(v, newcclosure(function(...)
                                local args = {...}
                                if Config.Silent.Enabled and Config.Silent.Active 
                                    and CurrentCATarget and CurrentCATarget.Parent then
                                    args = ModifyShootingArgs(args)
                                    return original(unpack(args))
                                end
                                return original(...)
                            end))
                            BypassResults.gcFunctionsHooked = BypassResults.gcFunctionsHooked + 1
                        end)
                    end
                end
            end
        end
    end
end)

-- METHOD C: Watch for new remotes being added
pcall(function()
    ReplicatedStorage.DescendantAdded:Connect(function(child)
        if child:IsA("RemoteEvent") and IsShootingRemote(child.Name) then
            task.wait(0.1)
            HookRemoteFireServer(child)
        end
    end)
end)

-- Determine which method is active
if BypassResults.remotesHooked > 0 then
    BypassResults.method = "RemoteHook"
elseif BypassResults.gcFunctionsHooked > 0 then
    BypassResults.method = "GCHook"
else
    BypassResults.method = "Scanning"
end

print("[AX] CA Phase 3 complete:")
print("  Remotes hooked: " .. BypassResults.remotesHooked)
print("  GC functions hooked: " .. BypassResults.gcFunctionsHooked)
print("  Method: " .. BypassResults.method)

-- ============================================
-- PHASE 4: FALLBACK - MOUSE TELEPORT METHOD
-- If no remotes/functions found, use mouse redirect
-- This works by moving the mouse to the target
-- when shooting, which is undetectable by BACS
-- ============================================

if BypassResults.remotesHooked == 0 and BypassResults.gcFunctionsHooked == 0 then
    print("[AX] CA: No remotes found - activating mouse redirect fallback")
    BypassResults.method = "MouseRedirect"
    
    local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end
    
    local function MouseRedirectLoop()
        if not Config.Silent.Enabled or not Config.Silent.Active then return end
        if not CurrentCATarget or not CurrentCATarget.Parent then return end
        if math.random(1, 100) > Config.Silent.HitChance then return end
        
        Camera = Workspace.CurrentCamera
        if not Camera then return end
        
        -- Only redirect when mouse button is pressed (shooting)
        if not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then return end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(CurrentCATarget.Position)
        if not onScreen then return end
        
        local mousePos = UserInputService:GetMouseLocation()
        local targetScreen = Vector2.new(screenPos.X, screenPos.Y)
        
        local deltaX = targetScreen.X - mousePos.X
        local deltaY = targetScreen.Y - mousePos.Y
        
        -- Instant snap when shooting
        if math.abs(deltaX) > 1 or math.abs(deltaY) > 1 then
            mousemoverel(deltaX, deltaY)
        end
    end
    
    RunService.RenderStepped:Connect(MouseRedirectLoop)
end

-- ============================================
-- PHASE 5: TARGET UPDATE LOOP
-- ============================================
local caTargetConnection = RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentCATarget = GetClosestCATarget()
    else
        CurrentCATarget = nil
    end
end)

-- ============================================
-- PHASE 6: CONTINUOUS PROTECTION MONITOR
-- ============================================
task.spawn(function()
    while task.wait(10) do
        pcall(function()
            -- Re-scan for new shooting remotes
            ScanAndHookRemotes()
            
            -- Re-clean GC signatures
            if getgc then
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            if rawget(obj, "__acsignature") then rawset(obj, "__acsignature", nil) end
                            if rawget(obj, "__checksum") then rawset(obj, "__checksum", nil) end
                        end)
                    end
                end
            end
            
            -- Re-disable error connections
            pcall(function()
                local ScriptContext = cloneref(game:GetService("ScriptContext"))
                if getconnections then
                    for _, conn in ipairs(getconnections(ScriptContext.Error)) do
                        pcall(function() conn:Disable() end)
                    end
                end
            end)
        end)
    end
end)

-- ============================================
-- CLEANUP ON RESPAWN
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentCATarget = nil
    hookedRemotes = {}
    
    -- Re-scan remotes after respawn
    task.wait(2)
    pcall(function() ScanAndHookRemotes() end)
end)

-- ============================================
-- SIGNAL: Module loaded
-- ============================================
getgenv().AX_CALoaded = true

print("  ✅ CA MODULE v3 - BACS-Safe (NO metamethods)")
print("  ✅ Method: " .. BypassResults.method)
print("  ✅ Remotes: " .. BypassResults.remotesHooked .. " | GC: " .. BypassResults.gcFunctionsHooked)
print("  ✅ AC neutralized: " .. BypassResults.acFunctionsNeutralized)
print("  ✅ Kick blocked: " .. tostring(BypassResults.kickBlocked))
print("  ✅ Errors blocked: " .. BypassResults.errorsBlocked)
