--[[
    ANNOMALY X - Combat Arena Module v9.1
    DIAGNÓSTICO + FIXES DE TARGET FINDING
    
    Cambios vs v9.0:
    ✅ pcall en FindTarget (si erroreaba silenciosamente, ahora lo ves)
    ✅ Diagnóstico automático a los 5 segundos (revisa F9)
    ✅ FindTarget usa Players:GetPlayers() directo (no cache, más confiable)
    ✅ Fallback de Config.FOV / Config.Silent si valores son nil
    ✅ Mouse position en vez de screen center para FOV
    ✅ Logs cada 3 segundos mostrando estado del target
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

-- ============================================
-- EXECUTOR FUNCTIONS
-- ============================================
local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function() end
local mousemoverel = mousemoverel
    or (Input and Input.MouseMove)
    or function() end

-- ============================================
-- SERVICES
-- ============================================
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- SAFE CONFIG ACCESS
-- Si algún valor de Config no existe, usa defaults
-- ============================================
local function GetSilentConfig(key, default)
    if Config.Silent and Config.Silent[key] ~= nil then
        return Config.Silent[key]
    end
    return default
end

local function GetFOVConfig(key, default)
    if Config.FOV and Config.FOV[key] ~= nil then
        return Config.FOV[key]
    end
    return default
end

local function GetESPConfig(key, default)
    if Config.ESP and Config.ESP[key] ~= nil then
        return Config.ESP[key]
    end
    return default
end

local function GetAimbotConfig(key, default)
    if Config.Aimbot and Config.Aimbot[key] ~= nil then
        return Config.Aimbot[key]
    end
    return default
end

-- ============================================
-- MOUSE BUTTON TRACKING
-- ============================================
local isMouseDown = false

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- TARGET UTILITIES
-- ============================================
local CurrentTargetPart = nil
local FrameCounter = 0
local TARGET_UPDATE_FRAMES = 2

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {
        "Head", "HumanoidRootPart",
        "UpperTorso", "Torso", "LowerTorso"
    }
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then
            return valid[math.random(1, #valid)]
        end
    end
    -- Intentar el setting pedido primero, luego fallbacks
    if setting and setting ~= "Random" then
        local p = character:FindFirstChild(setting)
        if p then return p end
    end
    -- Fallback chain
    for _, name in ipairs(parts) do
        local p = character:FindFirstChild(name)
        if p then return p end
    end
    return nil
end

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}

    local origin = cam.CFrame.Position
    local direction = (targetPart.Position - origin)
    local result = Workspace:Raycast(origin, direction, params)

    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function GetTargetPosition()
    if not CurrentTargetPart then return nil end
    local pos = CurrentTargetPart.Position
    local pred = GetSilentConfig("Prediction", 0)
    if pred > 0 then
        pcall(function()
            local vel = CurrentTargetPart.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * pred
            end
        end)
    end
    return pos
end

-- ============================================
-- FIND TARGET - VERSIÓN ROBUSTA
-- Usa Players:GetPlayers() directo (no cache)
-- Usa mouse position para FOV (no screen center)
-- pcall protegido en el caller
-- ============================================
local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end

    local fovEnabled = GetFOVConfig("Enabled", false)
    local fovRadius = GetFOVConfig("Radius", 500)
    local teamCheck = GetSilentConfig("TeamCheck", false)
    local targetPartSetting = GetSilentConfig("TargetPart", "Head")
    local visCheck = GetSilentConfig("VisibleCheck", true)

    local closest = nil
    local closestDist = fovEnabled and fovRadius or 99999
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        -- Team check
        if teamCheck then
            if player.Team and LocalPlayer.Team
                and player.Team == LocalPlayer.Team then
                continue
            end
        end

        -- Character check
        local character = player.Character
        if not character then continue end
        if not character.Parent then continue end

        -- Humanoid check
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        if humanoid.Health <= 0 then continue end

        -- ForceField check
        if character:FindFirstChildOfClass("ForceField") then
            continue
        end

        -- Target part
        local part = GetTargetPart(character, targetPartSetting)
        if not part then continue end

        -- Visibility check
        if visCheck and not IsVisible(part) then continue end

        -- Screen position check
        local screenPos, onScreen = cam:WorldToViewportPoint(
            part.Position
        )
        if not onScreen then continue end

        -- Distance from mouse to target on screen
        local dist = (
            Vector2.new(screenPos.X, screenPos.Y) - mousePos
        ).Magnitude

        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end

    return closest
end

-- ============================================
-- DIAGNÓSTICO AUTOMÁTICO
-- Se ejecuta 5 segundos después de cargar
-- Revisa F9 para ver los resultados
-- ============================================
task.delay(5, function()
    print("")
    print("╔═══════════════════════════════════════╗")
    print("║   ANNOMALY X - DIAGNÓSTICO v9.1       ║")
    print("╚═══════════════════════════════════════╝")
    print("")

    -- Check 1: Camera
    local cam = Workspace.CurrentCamera
    print("[1] Camera:", cam and "✅ OK" or "❌ NIL")

    -- Check 2: Config structure
    print("[2] Config.Silent:", Config.Silent and "✅ existe" or "❌ NIL")
    if Config.Silent then
        print("    .Enabled:", Config.Silent.Enabled)
        print("    .Active:", Config.Silent.Active)
        print("    .TargetPart:", Config.Silent.TargetPart)
        print("    .HitChance:", Config.Silent.HitChance)
        print("    .VisibleCheck:", Config.Silent.VisibleCheck)
        print("    .TeamCheck:", Config.Silent.TeamCheck)
        print("    .Prediction:", Config.Silent.Prediction)
    end

    print("[3] Config.FOV:", Config.FOV and "✅ existe" or "❌ NIL")
    if Config.FOV then
        print("    .Enabled:", Config.FOV.Enabled)
        print("    .Radius:", Config.FOV.Radius)
        print("    .Visible:", Config.FOV.Visible)
    end

    -- Check 3: Players
    local allPlayers = Players:GetPlayers()
    local enemyCount = 0
    print("[4] Total players:", #allPlayers)

    for _, player in ipairs(allPlayers) do
        if player == LocalPlayer then continue end
        enemyCount = enemyCount + 1
        local char = player.Character
        local charExists = char ~= nil
        local charParent = char and char.Parent ~= nil
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local humAlive = hum and hum.Health > 0
        local head = char and char:FindFirstChild("Head")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local ff = char and char:FindFirstChildOfClass("ForceField")

        print("")
        print("  Player:", player.Name)
        print("    Character:", charExists and "✅" or "❌ NO CHARACTER")
        if char then
            print("    Char.Parent:", charParent and "✅" or "❌ NOT IN WORKSPACE")
            print("    Humanoid:", hum and "✅" or "❌ NO HUMANOID")
            if hum then
                print("    Health:", hum.Health, humAlive and "✅" or "❌ DEAD")
            end
            print("    Head:", head and "✅" or "❌")
            print("    HRP:", hrp and "✅" or "❌")
            print("    ForceField:", ff and "⚠️ YES (spawning)" or "✅ No")
            print("    Team:", player.Team)

            -- Screen position test
            if cam and (head or hrp) then
                local testPart = head or hrp
                local sp, onScreen = cam:WorldToViewportPoint(
                    testPart.Position
                )
                print("    OnScreen:", onScreen and "✅" or "❌ OFF SCREEN")
                if onScreen then
                    local mp = UserInputService:GetMouseLocation()
                    local dist = (
                        Vector2.new(sp.X, sp.Y) - mp
                    ).Magnitude
                    print("    DistFromMouse:", math.floor(dist), "px")
                    local fovR = Config.FOV
                        and Config.FOV.Radius or 500
                    print("    FOV Radius:", fovR)
                    print("    Inside FOV:",
                        dist < fovR and "✅ YES" or "❌ NO")
                end
            end

            -- Visibility test
            if head or hrp then
                local testPart = head or hrp
                local vis = IsVisible(testPart)
                print("    Visible:", vis and "✅" or "❌ BLOCKED")
            end

            -- List all parts in character
            print("    All parts:")
            for _, child in ipairs(char:GetChildren()) do
                if child:IsA("BasePart") then
                    print("      -", child.Name, child.ClassName)
                end
            end
        end
    end

    print("")
    print("[5] Enemy count:", enemyCount)
    print("[6] LocalPlayer team:", LocalPlayer.Team)
    print("[7] Mouse position:", UserInputService:GetMouseLocation())

    -- Try FindTarget manually
    print("")
    print("[8] Testing FindTarget()...")
    local ok, result = pcall(FindTarget)
    if ok then
        print("    Result:",
            result and ("✅ FOUND: " .. result.Name
                .. " in " .. result.Parent.Name)
            or "❌ RETURNED NIL (no valid target)")
    else
        print("    ❌ ERROR:", result)
    end

    print("")
    print("═══════════════════════════════════════")
    print("COPIA TODO ESTO Y MÁNDAMELO")
    print("Con esto sé exactamente qué arreglar")
    print("═══════════════════════════════════════")
    print("")
end)

-- ============================================
-- SILENT AIM: getrawmetatable(Mouse).__index
-- Solo Mouse.Hit y Mouse.UnitRay
-- Solo cuando MouseButton1 presionado
-- ============================================
local SilentAimActive = false
local hitChancePass = false
local lastHitChanceFrame = -1

pcall(function()
    local mt = getrawmetatable(Mouse)
    if not mt then
        warn("[AX] getrawmetatable(Mouse) falló")
        warn("[AX] Silent Aim DESACTIVADO")
        return
    end

    local oldIndex = mt.__index
    if not oldIndex then
        warn("[AX] Mouse.__index no encontrado")
        warn("[AX] Silent Aim DESACTIVADO")
        return
    end

    setreadonly(mt, false)

    mt.__index = newcclosure(function(self, key)
        if self ~= Mouse then
            return oldIndex(self, key)
        end

        if isMouseDown
            and CurrentTargetPart
            and CurrentTargetPart.Parent
            and GetSilentConfig("Enabled", false)
            and GetSilentConfig("Active", false) then

            local currentFrame = FrameCounter
            if currentFrame ~= lastHitChanceFrame then
                lastHitChanceFrame = currentFrame
                hitChancePass = math.random(1, 100)
                    <= GetSilentConfig("HitChance", 100)
            end

            if hitChancePass then
                local cam = Workspace.CurrentCamera
                if cam then
                    local targetPos = GetTargetPosition()
                    if targetPos then
                        if key == "Hit" then
                            return CFrame.new(targetPos)
                        elseif key == "UnitRay" then
                            local origin = cam.CFrame.Position
                            local dir = (targetPos - origin).Unit
                            return Ray.new(origin, dir)
                        end
                    end
                end
            end
        end

        return oldIndex(self, key)
    end)

    setreadonly(mt, true)
    SilentAimActive = true
end)

-- ============================================
-- VISUAL INDICATORS
-- ============================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.Filled = false
FOVCircle.Transparency = 0.6
FOVCircle.Color = Color3.fromRGB(255, 255, 255)

local TargetDot = Drawing.new("Circle")
TargetDot.Thickness = 1
TargetDot.Filled = true
TargetDot.Transparency = 0.8
TargetDot.Color = Color3.fromRGB(0, 255, 0)
TargetDot.Radius = 5

-- ============================================
-- AIMBOT
-- ============================================
local AimTarget = nil
local AimLockedPlayer = nil

local function UpdateAimbot()
    if not GetAimbotConfig("Enabled", false)
        or not GetAimbotConfig("Active", false) then
        AimTarget = nil
        if not GetAimbotConfig("Active", false) then
            AimLockedPlayer = nil
        end
        return
    end

    local target = nil

    if GetAimbotConfig("Method", "Aimbot") == "Aimlock"
        and AimLockedPlayer
        and AimLockedPlayer.Character then
        local char = AimLockedPlayer.Character
        local part = GetTargetPart(
            char, GetAimbotConfig("TargetPart", "Head")
        )
        if part and (
            not GetAimbotConfig("VisibleCheck", true)
            or IsVisible(part)
        ) then
            target = part
        else
            AimLockedPlayer = nil
        end
    end

    if not target then
        local cam = Workspace.CurrentCamera
        if not cam then return end
        local closestDist = GetAimbotConfig("FOVRadius", 300)
        local refPoint = GetAimbotConfig("Method", "Aimbot") == "Aimbot"
            and cam.ViewportSize / 2
            or UserInputService:GetMouseLocation()

        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if GetAimbotConfig("TeamCheck", false)
                and player.Team == LocalPlayer.Team then
                continue
            end
            local char = player.Character
            if not char or not char.Parent then continue end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end
            if char:FindFirstChildOfClass("ForceField") then
                continue
            end

            local part = GetTargetPart(
                char, GetAimbotConfig("TargetPart", "Head")
            )
            if not part then continue end
            if GetAimbotConfig("VisibleCheck", true)
                and not IsVisible(part) then
                continue
            end

            local sp, onScreen = cam:WorldToViewportPoint(part.Position)
            if not onScreen then continue end

            local dist = (
                Vector2.new(sp.X, sp.Y) - refPoint
            ).Magnitude
            if dist < closestDist then
                closestDist = dist
                target = part
                if GetAimbotConfig("Method", "Aimbot") == "Aimlock" then
                    AimLockedPlayer = player
                end
            end
        end
    end

    AimTarget = target
    if not target then return end

    local pos = target.Position
    if GetAimbotConfig("Prediction", 0) > 0 then
        pcall(function()
            local vel = target.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * GetAimbotConfig("Prediction", 0)
            end
        end)
    end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    if GetAimbotConfig("Method", "Aimbot") == "Aimbot" then
        local cur = cam.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        local smooth = GetAimbotConfig("Smoothness", 1)
        cam.CFrame = smooth <= 1 and tgt
            or cur:Lerp(tgt, 1 / smooth)
    else
        local sp, on = cam:WorldToViewportPoint(pos)
        if not on then return end
        local mp = UserInputService:GetMouseLocation()
        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist < 2 then return end
        local smooth = GetAimbotConfig("Smoothness", 1)
        local spd = math.clamp(
            1 / math.max(smooth, 1), 0.05, 0.8
        )
        local mx = math.clamp(dx * spd, -150, 150)
        local my = math.clamp(dy * spd, -150, 150)
        if math.abs(mx) > 0.5 or math.abs(my) > 0.5 then
            mousemoverel(mx, my)
        end
    end
end

-- ============================================
-- ESP (CA-SPECIFIC)
-- ============================================
local CAESPObjects = {}
local LastCAESPUpdate = 0
local CA_ESP_INTERVAL = 0.12

local function CreateCAESP(player)
    if CAESPObjects[player] then return end
    CAESPObjects[player] = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    local e = CAESPObjects[player]
    e.Box.Thickness = 1
    e.Box.Filled = false
    e.Box.Color = Color3.fromRGB(255, 255, 255)
    e.Box.Visible = false
    e.Name.Size = 13
    e.Name.Center = true
    e.Name.Outline = true
    e.Name.Color = Color3.fromRGB(255, 255, 255)
    e.Name.Visible = false
    e.Distance.Size = 12
    e.Distance.Center = true
    e.Distance.Outline = true
    e.Distance.Color = Color3.fromRGB(200, 200, 200)
    e.Distance.Visible = false
end

local function RemoveCAESP(player)
    if CAESPObjects[player] then
        for _, d in pairs(CAESPObjects[player]) do
            pcall(function() d:Remove() end)
        end
        CAESPObjects[player] = nil
    end
end

local function HideCAESP(esp)
    esp.Box.Visible = false
    esp.Name.Visible = false
    esp.Distance.Visible = false
end

local function UpdateCAESP()
    if not GetESPConfig("Enabled", false)
        or not GetESPConfig("Active", false) then
        for _, esp in pairs(CAESPObjects) do
            HideCAESP(esp)
        end
        return
    end

    local t = tick()
    if t - LastCAESPUpdate < CA_ESP_INTERVAL then return end
    LastCAESPUpdate = t

    local cam = Workspace.CurrentCamera
    if not cam then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not CAESPObjects[player] then
            CreateCAESP(player)
        end

        local esp = CAESPObjects[player]
        if not esp then continue end

        local visible = false
        local char = player.Character

        if char and char.Parent then
            local hum = char:FindFirstChildOfClass("Humanoid")
            local rootPart = char:FindFirstChild("HumanoidRootPart")
                or char:FindFirstChild("Torso")
                or char:FindFirstChild("UpperTorso")

            if hum and hum.Health > 0 and rootPart
                and not char:FindFirstChildOfClass("ForceField") then

                local dist = (
                    cam.CFrame.Position - rootPart.Position
                ).Magnitude

                if dist <= GetESPConfig("MaxDistance", 1000) then
                    local sp, onScreen = cam:WorldToViewportPoint(
                        rootPart.Position
                    )

                    if onScreen then
                        visible = true
                        local bs = Vector2.new(
                            2000 / dist, 2500 / dist
                        )

                        esp.Box.Size = bs
                        esp.Box.Position = Vector2.new(
                            sp.X - bs.X / 2,
                            sp.Y - bs.Y / 2
                        )
                        local head = char:FindFirstChild("Head")
                            or rootPart
                        local isVis = IsVisible(head)
                        esp.Box.Color = isVis
                            and Color3.fromRGB(0, 255, 0)
                            or Color3.fromRGB(255, 0, 0)
                        esp.Box.Visible = GetESPConfig("Boxes", true)

                        esp.Name.Text = player.DisplayName
                            or player.Name
                        esp.Name.Position = Vector2.new(
                            sp.X, sp.Y - bs.Y / 2 - 15
                        )
                        esp.Name.Color = Color3.fromRGB(255, 255, 255)
                        esp.Name.Visible = GetESPConfig("Names", true)

                        esp.Distance.Text = math.floor(dist) .. "m"
                        esp.Distance.Position = Vector2.new(
                            sp.X, sp.Y + bs.Y / 2 + 5
                        )
                        esp.Distance.Visible = GetESPConfig(
                            "Distance", true
                        )
                    end
                end
            end
        end

        if not visible then
            HideCAESP(esp)
        end
    end
end

-- ============================================
-- SEÑALES
-- ============================================
getgenv().AX_CAHandlesAimbot = true
getgenv().AX_CAHandlesESP = true
getgenv().AX_PF_HandlesESP = true

-- ============================================
-- STATUS LOG (cada 3 segundos)
-- Para saber si FindTarget está encontrando algo
-- ============================================
local lastStatusLog = 0

-- ============================================
-- LOOP PRINCIPAL
-- ============================================
RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter = FrameCounter + 1

    -- Silent Aim target
    if SilentAimActive
        and GetSilentConfig("Enabled", false)
        and GetSilentConfig("Active", false) then
        if FrameCounter % TARGET_UPDATE_FRAMES == 0 then
            local ok, result = pcall(FindTarget)
            if ok then
                CurrentTargetPart = result
            else
                -- Si FindTarget da error, mostrarlo
                if FrameCounter % 180 == 0 then
                    warn("[AX] FindTarget ERROR:", result)
                end
                CurrentTargetPart = nil
            end
        end
    else
        CurrentTargetPart = nil
    end

    -- Status log cada 3 segundos
    local now = tick()
    if now - lastStatusLog > 3 then
        lastStatusLog = now
        if SilentAimActive
            and GetSilentConfig("Enabled", false)
            and GetSilentConfig("Active", false) then
            if CurrentTargetPart then
                print("[AX] Target:", CurrentTargetPart.Name,
                    "en", CurrentTargetPart.Parent.Name)
            else
                print("[AX] Sin target - Mouse apuntando lejos",
                    "o nadie visible")
            end
        end
    end

    -- FOV Circle
    if Config.FOV
        and GetFOVConfig("Enabled", false)
        and GetFOVConfig("Visible", false) then
        local mp = UserInputService:GetMouseLocation()
        FOVCircle.Position = mp
        FOVCircle.Radius = GetFOVConfig("Radius", 500)
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end

    -- Target dot
    if CurrentTargetPart
        and CurrentTargetPart.Parent
        and Camera then
        local sp, on = Camera:WorldToViewportPoint(
            CurrentTargetPart.Position
        )
        if on then
            TargetDot.Position = Vector2.new(sp.X, sp.Y)
            TargetDot.Visible = true
        else
            TargetDot.Visible = false
        end
    else
        TargetDot.Visible = false
    end

    -- Aimbot
    pcall(UpdateAimbot)

    -- ESP
    pcall(UpdateCAESP)
end)

-- ============================================
-- CLEANUP
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    Camera = Workspace.CurrentCamera
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
    isMouseDown = false
end)

Players.PlayerRemoving:Connect(function(player)
    RemoveCAESP(player)
end)

getgenv().AX_CALoaded = true

print("══════════════════════════════════════")
print("  ANNOMALY X - Combat Arena v9.1")
print("  VERSIÓN DIAGNÓSTICO")
print("══════════════════════════════════════")
print("  Silent Aim:", SilentAimActive
    and "✅ Hook aplicado" or "❌ Hook falló")
print("  Espera 5 segundos para diagnóstico...")
print("  Revisa F9 para ver resultados")
print("══════════════════════════════════════")
