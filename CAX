--[[
    ANNOMALY X - Combat Arena Module v8.1 (BYPASS BAC 2198)
    
    PROBLEMA IDENTIFICADO: BAC 2198 detecta hookmetamethod(__namecall/__index)
    via tostring trap + getfenv/getrenv inspection.
    
    SOLUCIÓN: Método getgc() + MagnetStrength (NO USA HOOKS DE METATABLE)
    Este es el método que usan los scripts funcionales de Combat Arena.
    
    IMPORTANTE: 
    - NO hookear __namecall ni __index (causa BAC 2198)
    - Usar modificación directa de tablas de armas via getgc()
    - Silent Aim via MagnetStrength (las balas van solas al target)
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- ============================================
-- SILENT AIM VIA MAGNETSTRENGTH (SIN HOOKS)
-- Este método NO es detectado por BAC 2198
-- ============================================
local MagnetEnabled = false
local LastMagnetUpdate = 0

local function ApplyMagnetStrength()
    if not Config.Silent or not Config.Silent.Enabled or not Config.Silent.Active then
        return
    end
    
    -- Solo actualizar cada 0.5 segundos para evitar lag
    local now = tick()
    if now - LastMagnetUpdate < 0.5 then return end
    LastMagnetUpdate = now
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" and rawget(v, "FireRate") then
                -- SILENT AIM: MagnetStrength hace que las balas vayan al target
                -- Valores: 0 = off, 100-500 = sutil, 1000+ = muy fuerte
                local magnetValue = Config.Silent.Active and 1000 or 0
                
                rawset(v, "MagnetStrength", magnetValue)
                
                -- Opcionales (descomenta si quieres):
                -- rawset(v, "Range", Vector2.new(99999, 99999))  -- Rango infinito
                -- rawset(v, "ReloadTime", 0)                     -- Recarga instantánea
                -- rawset(v, "AmmoCapacity", math.huge)           -- Munición infinita
                
                MagnetEnabled = true
            end
        end
    end)
end

local function DisableMagnetStrength()
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" and rawget(v, "FireRate") then
                rawset(v, "MagnetStrength", 0)
            end
        end
    end)
    MagnetEnabled = false
end

-- ============================================
-- TARGET FINDER (Para ESP y Aimbot visual)
-- ============================================
local CurrentTargetPart = nil
local FrameCounter = 0

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        return #valid > 0 and valid[math.random(#valid)] or nil
    end
    return character:FindFirstChild(setting) or character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart")
end

local function IsVisible(targetPart)
    if not targetPart then return false end
    local char = LocalPlayer.Character
    if not char then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {char, cam}
    
    local origin = cam.CFrame.Position
    local result = Workspace:Raycast(origin, (targetPart.Position - origin), params)
    return not result or result.Instance:IsDescendantOf(targetPart.Parent)
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end
    
    local closest, closestDist = nil, (Config.FOV and Config.FOV.Radius or 200)
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent and Config.Silent.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local char = player.Character
        if not char then continue end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end
        
        local part = GetTargetPart(char, Config.Silent and Config.Silent.TargetPart or "Head")
        if not part then continue end
        if Config.Silent and Config.Silent.VisibleCheck and not IsVisible(part) then continue end
        
        local sp, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end
    return closest
end

-- ============================================
-- AIMBOT (Visual - mueve la cámara)
-- ============================================
local AimTarget = nil
local AimLockedPlayer = nil
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

local function UpdateAimbot()
    if not Config.Aimbot or not Config.Aimbot.Enabled or not Config.Aimbot.Active then
        AimTarget = nil
        if Config.Aimbot and not Config.Aimbot.Active then AimLockedPlayer = nil end
        return
    end

    local target = nil
    local cam = Workspace.CurrentCamera
    if not cam then return end

    if Config.Aimbot.Method == "Aimlock" and AimLockedPlayer and AimLockedPlayer.Character then
        local char = AimLockedPlayer.Character
        local part = GetTargetPart(char, Config.Aimbot.TargetPart)
        if part and (not Config.Aimbot.VisibleCheck or IsVisible(part)) then
            target = part
        else
            AimLockedPlayer = nil
        end
    end

    if not target then
        local closestDist = Config.Aimbot.FOVRadius or 150
        local refPoint = Config.Aimbot.Method == "Aimbot" and cam.ViewportSize / 2 or UserInputService:GetMouseLocation()

        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if Config.Aimbot.TeamCheck and player.Team == LocalPlayer.Team then continue end
            local char = player.Character
            if not char then continue end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end
            if char:FindFirstChildOfClass("ForceField") then continue end

            local part = GetTargetPart(char, Config.Aimbot.TargetPart)
            if not part then continue end
            if Config.Aimbot.VisibleCheck and not IsVisible(part) then continue end

            local sp, onScreen = cam:WorldToViewportPoint(part.Position)
            if not onScreen then continue end

            local dist = (Vector2.new(sp.X, sp.Y) - refPoint).Magnitude
            if dist < closestDist then
                closestDist = dist
                target = part
                if Config.Aimbot.Method == "Aimlock" then
                    AimLockedPlayer = player
                end
            end
        end
    end

    AimTarget = target
    if not target then return end

    local pos = target.Position
    if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
        pcall(function()
            local vel = target.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Aimbot.Prediction
            end
        end)
    end

    if Config.Aimbot.Method == "Aimbot" then
        local cur = cam.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        cam.CFrame = (Config.Aimbot.Smoothness or 1) <= 1 and tgt or cur:Lerp(tgt, 1 / (Config.Aimbot.Smoothness or 1))
    else
        local sp, on = cam:WorldToViewportPoint(pos)
        if not on then return end
        local mp = UserInputService:GetMouseLocation()
        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist < 2 then return end
        local spd = math.clamp(1 / math.max(Config.Aimbot.Smoothness or 5, 1), 0.05, 0.8)
        mousemoverel(dx * spd, dy * spd)
    end
end

-- ============================================
-- ESP (Sin cambios - funciona)
-- ============================================
local ESPObjects = {}

local function UpdateESP()
    if not Config.ESP or not Config.ESP.Enabled or not Config.ESP.Active then
        for _, esp in pairs(ESPObjects) do
            if esp then
                if esp.Box then esp.Box.Visible = false end
                if esp.Name then esp.Name.Visible = false end
                if esp.Distance then esp.Distance.Visible = false end
            end
        end
        return
    end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not ESPObjects[player] then
            ESPObjects[player] = {
                Box = Drawing.new("Square"),
                Name = Drawing.new("Text"),
                Distance = Drawing.new("Text")
            }
            local e = ESPObjects[player]
            e.Box.Thickness = 1
            e.Box.Filled = false
            e.Name.Size = 13
            e.Name.Center = true
            e.Name.Outline = true
            e.Distance.Size = 12
            e.Distance.Center = true
            e.Distance.Outline = true
        end

        local esp = ESPObjects[player]
        local char = player.Character
        local root = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso"))

        if char and root and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").Health > 0 and not char:FindFirstChildOfClass("ForceField") then
            local dist = (cam.CFrame.Position - root.Position).Magnitude
            if dist <= (Config.ESP.MaxDistance or 1000) then
                local sp, onScreen = cam:WorldToViewportPoint(root.Position)
                if onScreen then
                    local size = Vector2.new(2000 / dist, 2500 / dist)
                    esp.Box.Size = size
                    esp.Box.Position = Vector2.new(sp.X - size.X / 2, sp.Y - size.Y / 2)
                    esp.Box.Color = IsVisible(root) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    esp.Box.Visible = Config.ESP.Boxes

                    esp.Name.Text = player.DisplayName or player.Name
                    esp.Name.Position = Vector2.new(sp.X, sp.Y - size.Y / 2 - 15)
                    esp.Name.Color = Color3.new(1, 1, 1)
                    esp.Name.Visible = Config.ESP.Names

                    esp.Distance.Text = math.floor(dist) .. "m"
                    esp.Distance.Position = Vector2.new(sp.X, sp.Y + size.Y / 2 + 5)
                    esp.Distance.Color = Color3.new(1, 1, 1)
                    esp.Distance.Visible = Config.ESP.Distance
                else
                    esp.Box.Visible, esp.Name.Visible, esp.Distance.Visible = false, false, false
                end
            else
                esp.Box.Visible, esp.Name.Visible, esp.Distance.Visible = false, false, false
            end
        else
            esp.Box.Visible, esp.Name.Visible, esp.Distance.Visible = false, false, false
        end
    end
end

Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        pcall(function()
            ESPObjects[player].Box:Remove()
            ESPObjects[player].Name:Remove()
            ESPObjects[player].Distance:Remove()
        end)
        ESPObjects[player] = nil
    end
end)

-- ============================================
-- INDICADORES VISUALES
-- ============================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.Filled = false
FOVCircle.Transparency = 0.6
FOVCircle.Color = Color3.fromRGB(255, 255, 255)

local TargetDot = Drawing.new("Circle")
TargetDot.Thickness = 1
TargetDot.Filled = true
TargetDot.Radius = 5
TargetDot.Color = Color3.fromRGB(0, 255, 0)

-- ============================================
-- LOOP PRINCIPAL
-- ============================================
getgenv().AX_CAHandlesAimbot = true
getgenv().AX_CAHandlesESP = true

RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter = FrameCounter + 1

    -- SILENT AIM: Aplicar MagnetStrength (sin hooks)
    if Config.Silent and Config.Silent.Enabled and Config.Silent.Active then
        ApplyMagnetStrength()
        
        -- Buscar target para indicador visual
        if FrameCounter % 3 == 0 then
            CurrentTargetPart = FindTarget()
        end
    else
        if MagnetEnabled then
            DisableMagnetStrength()
        end
        CurrentTargetPart = nil
    end

    -- FOV Circle
    if Config.FOV and Config.FOV.Enabled and Config.FOV.Visible then
        local mp = UserInputService:GetMouseLocation()
        FOVCircle.Position = mp
        FOVCircle.Radius = Config.FOV.Radius or 200
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end

    -- Target indicator
    if CurrentTargetPart and CurrentTargetPart.Parent and Camera then
        local sp, on = Camera:WorldToViewportPoint(CurrentTargetPart.Position)
        if on then
            TargetDot.Position = Vector2.new(sp.X, sp.Y)
            TargetDot.Visible = true
        else
            TargetDot.Visible = false
        end
    else
        TargetDot.Visible = false
    end

    UpdateAimbot()
    UpdateESP()
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
    -- Re-aplicar magnet después de respawn
    if Config.Silent and Config.Silent.Active then
        task.wait(1)
        ApplyMagnetStrength()
    end
end)

getgenv().AX_CALoaded = true

print([[
[ANNOMALY X v8.1] Combat Arena - BYPASS BAC 2198

MÉTODO: MagnetStrength via getgc() (SIN HOOKS DE METATABLE)
- Las balas van automáticamente hacia el enemigo más cercano
- NO usa hookmetamethod (evita detección BAC 2198)

CÓMO FUNCIONA:
- MagnetStrength = 1000 hace que las balas "magneticen" hacia targets
- Solo necesitas apuntar CERCA del enemigo, la bala corrige sola
- Es el mismo método que usan los scripts pagos de CA

Si quieres ajustar la fuerza del magnet, cambia el valor 1000:
- 500 = sutil (más legit)
- 1000 = fuerte (recomendado)
- 2000+ = muy obvio

¡Disfruta sin ban!
]])
