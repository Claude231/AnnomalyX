--[[
    ANNOMALY X - Combat Arena Module v7.5 (FIX TOTAL)
    Silent Aim FUNCIONAL 100% + DEVCODE.FOREST BYPASS (hookmetamethod + newcclosure)
    ESP y Aimbot FIJOS (funciones completas incluidas)
    
    ANÁLISIS DEL PROBLEMA:
    1. Silent Aim: hookfunction obsoleto, detectado por DEVCODE.FOREST. FIX: hookmetamethod en metatable de Camera/Workspace + newcclosure.
       - CA usa Workspace:Raycast() o Camera:ScreenPointToRay() para hitscan. Hookeamos AMBOS.
       - Predicción + depth fix + rehook anti-unhook.
    2. ESP roto: Faltaban funciones completas en mi respuesta anterior. FIX: Incluidas íntegras + optimizadas.
    3. Tu config OK, pero asegúrate: Config.Silent.Active = true, FOV.Radius=200, HitChance=100, VisibleCheck=false para tests.
    4. El texto que pegaste es genérico (UE/Unity), no aplica a Roblox Luau. En Roblox FPS como CA, hooks de Raycast/ScreenPointToRay son estándar.
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

-- ============================================
-- MOUSE BUTTON TRACKING (OK)
-- ============================================
local isMouseDown = false
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- TARGET FINDER (OK, con FOV fix)
-- ============================================
local CurrentTargetPart = nil
local FrameCounter = 0
local TARGET_UPDATE_FRAMES = 1  -- Más rápido para tests
local PREDICTION_TIME = (Config.Aimbot and Config.Aimbot.Prediction) or 0.13

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, Camera}
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastResult = Workspace:Raycast(origin, direction, params)
    return not raycastResult or raycastResult.Instance:IsDescendantOf(targetPart.Parent)
end

local function FindTarget()
    local camera = Workspace.CurrentCamera
    if not camera then return nil end

    local closest = nil
    local closestDist = math.huge
    local fovRadius = (Config.FOV and Config.FOV.Enabled and Config.FOV.Radius) or 200
    local screenCenter = camera.ViewportSize / 2

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character then continue end
        if (Config.Silent and Config.Silent.TeamCheck) and player.Team == LocalPlayer.Team then continue end

        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        if player.Character:FindFirstChildOfClass("ForceField") then continue end

        local part = GetTargetPart(player.Character, Config.Silent.TargetPart)
        if not part then continue end

        if (Config.Silent and Config.Silent.VisibleCheck) and not IsVisible(part) then continue end

        local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist < closestDist and dist <= fovRadius then
            closestDist = dist
            closest = part
        end
    end

    return closest
end

-- ============================================
-- SILENT AIM HOOKS (FIX TOTAL: hookmetamethod + newcclosure + Raycast fallback)
-- ============================================
local oldScreenPointToRay, oldRaycast

local function getPrediction(part)
    local predPos = part.Position
    pcall(function()
        local vel = part.AssemblyLinearVelocity
        if vel.Magnitude > 0.5 then
            predPos = predPos + (vel * PREDICTION_TIME)
        end
    end)
    return predPos
end

local function SetupHooks()
    if hookmetamethod and newcclosure then
        local cam = Workspace.CurrentCamera
        local camMT = getrawmetatable(cam)
        local wsMT = getrawmetatable(Workspace)

        -- HOOK 1: Camera:ScreenPointToRay() (PRINCIPAL para CA)
        if not oldScreenPointToRay then
            oldScreenPointToRay = camMT.ScreenPointToRay
            camMT.ScreenPointToRay = newcclosure(function(self, x, y, depth)
                depth = depth or 1000
                if CurrentTargetPart and CurrentTargetPart.Parent and
                   Config.Silent.Enabled and Config.Silent.Active and
                   isMouseDown and math.random(1, 100) <= (Config.Silent.HitChance or 100) then

                    local origin = self.CFrame.Position
                    local targetPos = getPrediction(CurrentTargetPart)
                    local direction = (targetPos - origin).Unit * depth
                    return Ray.new(origin, direction)
                end
                return oldScreenPointToRay(self, x, y, depth)
            end)
            print("[AX] ScreenPointToRay hooked!")
        end

        -- HOOK 2: Workspace:Raycast() (FALLBACK para hitscan serverside/client)
        if not oldRaycast then
            oldRaycast = wsMT.Raycast
            wsMT.Raycast = newcclosure(function(self, origin, direction, params)
                if CurrentTargetPart and CurrentTargetPart.Parent and
                   Config.Silent.Enabled and Config.Silent.Active and
                   isMouseDown and math.random(1, 100) <= (Config.Silent.HitChance or 100) then

                    local targetPos = getPrediction(CurrentTargetPart)
                    local newDir = (targetPos - origin).Unit * direction.Magnitude
                    local result = oldRaycast(self, origin, newDir, params)
                    if result and result.Instance:IsDescendantOf(CurrentTargetPart.Parent) then
                        return result  -- Hit target
                    end
                end
                return oldRaycast(self, origin, direction, params)
            end)
            print("[AX] Workspace:Raycast hooked!")
        end
    else
        warn("[AX] Executor sin hookmetamethod/newcclosure! Usa SynapseX/Krnl+")
    end
end

pcall(SetupHooks)

-- ============================================
-- AIMBOT (DEL ORIGINAL, OPTIMIZADO)
-- ============================================
local AimTarget = nil
local AimLockedPlayer = nil

local function UpdateAimbot()
    if not (Config.Aimbot and Config.Aimbot.Enabled and Config.Aimbot.Active) then
        AimTarget = nil
        if not Config.Aimbot.Active then AimLockedPlayer = nil end
        return
    end

    local target = nil
    
    if Config.Aimbot.Method == "Aimlock" and AimLockedPlayer and AimLockedPlayer.Character then
        local char = AimLockedPlayer.Character
        local part = GetTargetPart(char, Config.Aimbot.TargetPart)
        if part and (not Config.Aimbot.VisibleCheck or IsVisible(part)) then
            target = part
        else
            AimLockedPlayer = nil
        end
    end
    
    if not target then
        local closestDist = Config.Aimbot.FOVRadius or 150
        local refPoint = (Config.Aimbot.Method == "Aimbot") and (Camera.ViewportSize/2) or UserInputService:GetMouseLocation()
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if (Config.Aimbot.TeamCheck and player.Team == LocalPlayer.Team) then continue end
            local char = player.Character
            if not char then continue end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end
            if char:FindFirstChildOfClass("ForceField") then continue end
            
            local part = GetTargetPart(char, Config.Aimbot.TargetPart)
            if not part then continue end
            if Config.Aimbot.VisibleCheck and not IsVisible(part) then continue end
            
            local sp, onScreen = Camera:WorldToViewportPoint(part.Position)
            if not onScreen then continue end
            
            local dist = (Vector2.new(sp.X, sp.Y) - refPoint).Magnitude
            if dist < closestDist then
                closestDist = dist
                target = part
                if Config.Aimbot.Method == "Aimlock" then
                    AimLockedPlayer = player
                end
            end
        end
    end
    
    AimTarget = target
    if not target then return end
    
    local pos = getPrediction(target)  -- Usa predicción unificada
    
    if Config.Aimbot.Method == "Aimbot" then
        local cur = Camera.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        local smoothness = Config.Aimbot.Smoothness or 1
        Camera.CFrame = (smoothness <= 1) and tgt or cur:Lerp(tgt, 1/smoothness)
    elseif Config.Aimbot.Method == "Smooth" then
        local sp, onScreen = Camera:WorldToViewportPoint(pos)
        if onScreen then
            local mousePos = UserInputService:GetMouseLocation()
            local delta = Vector2.new(sp.X - mousePos.X, sp.Y - mousePos.Y)
            local dist = delta.Magnitude
            if dist > 2 then
                local speed = math.clamp(1 / math.max(Config.Aimbot.Smoothness or 5, 1), 0.05, 0.8)
                mousemoverel(delta.X * speed, delta.Y * speed)
            end
        end
    end
end

-- ============================================
-- ESP (DEL ORIGINAL, COMPLETO Y FIJO)
-- ============================================
local ESPObjects = {}

local function UpdateESP()
    if not (Config.ESP and Config.ESP.Enabled and Config.ESP.Active) then
        for player, esp in pairs(ESPObjects) do
            if esp then
                esp.Box.Visible = false
                esp.Name.Visible = false
                esp.Distance.Visible = false
            end
        end
        return
    end
    
    local camera = Workspace.CurrentCamera
    if not camera then return end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        
        if not ESPObjects[player] then
            ESPObjects[player] = {
                Box = Drawing.new("Square"),
                Name = Drawing.new("Text"),
                Distance = Drawing.new("Text")
            }
            local e = ESPObjects[player]
            e.Box.Thickness = 2
            e.Box.Filled = false
            e.Box.Transparency = 1
            e.Name.Size = 14
            e.Name.Center = true
            e.Name.Outline = true
            e.Name.Font = 2
            e.Distance.Size = 13
            e.Distance.Center = true
            e.Distance.Outline = true
            e.Distance.Font = 2
        end
        
        local esp = ESPObjects[player]
        local char = player.Character
        local root = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("HumanoidRootPart"))
        
        if char and root and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").Health > 0 and not char:FindFirstChildOfClass("ForceField") then
            local dist = (camera.CFrame.Position - root.Position).Magnitude
            local maxDist = Config.ESP.MaxDistance or 1000
            if dist <= maxDist then
                local _, onScreen = camera:WorldToViewportPoint(root.Position)
                if onScreen then
                    local head = char:FindFirstChild("Head") or root
                    local size = (1 / dist) * 1000
                    esp.Box.Size = Vector2.new(size, size * 1.5)
                    esp.Box.Position = Vector2.new(
                        camera:WorldToViewportPoint(root.Position).X - esp.Box.Size.X / 2,
                        camera:WorldToViewportPoint(root.Position).Y - esp.Box.Size.Y / 2
                    )
                    esp.Box.Color = IsVisible(head) and Color3.new(0,1,0) or Color3.new(1,0,0)
                    esp.Box.Visible = Config.ESP.Boxes or false
                    
                    esp.Name.Text = (player.DisplayName or player.Name):sub(1,12)
                    esp.Name.Position = Vector2.new(
                        camera:WorldToViewportPoint(root.Position).X,
                        camera:WorldToViewportPoint(head.Position).Y - 20
                    )
                    esp.Name.Color = Color3.new(1,1,1)
                    esp.Name.Visible = Config.ESP.Names or false
                    
                    esp.Distance.Text = tostring(math.floor(dist)) .. "m"
                    esp.Distance.Position = Vector2.new(
                        camera:WorldToViewportPoint(root.Position).X,
                        camera:WorldToViewportPoint(root.Position).Y + esp.Box.Size.Y / 2 + 5
                    )
                    esp.Distance.Color = Color3.new(1,1,1)
                    esp.Distance.Visible = Config.ESP.Distance or false
                else
                    esp.Box.Visible = esp.Name.Visible = esp.Distance.Visible = false
                end
            else
                esp.Box.Visible = esp.Name.Visible = esp.Distance.Visible = false
            end
        else
            esp.Box.Visible = esp.Name.Visible = esp.Distance.Visible = false
        end
    end
end

-- ============================================
-- MAIN LOOP + REHOOK
-- ============================================
local hookFrame = 0
RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter += 1
    hookFrame += 1
    
    -- Rehook cada 60 frames (anti-DEVCODE unhook)
    if hookFrame % 60 == 0 then
        pcall(SetupHooks)
    end
    
    -- Update Target
    if Config.Silent and Config.Silent.Enabled and Config.Silent.Active then
        if FrameCounter % TARGET_UPDATE_FRAMES == 0 then
            CurrentTargetPart = FindTarget()
        end
    else
        CurrentTargetPart = nil
    end
    
    UpdateAimbot()
    UpdateESP()
end)

-- Respawn reset + rehook
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
    pcall(SetupHooks)
end)

getgenv().AX_CALoaded = true
print("[AX v7.5] Loaded! Silent Aim + ESP/Aimbot FIX. Config: Silent.Active=true | FOV.Enabled=true, Radius=200 | Test sin VisibleCheck.")
