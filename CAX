--[[
    ANNOMALY X - Combat Arena Module v9.0 FINAL
    
    M√âTODO: getrawmetatable(Mouse).__index (EL QUE FUNCIONABA)
    
    Qu√© se ELIMIN√ì vs v8.x (todo esto causaba detecci√≥n):
    ‚ùå hookmetamethod(game, "__index")    ‚Üí BAD 2198
    ‚ùå hookmetamethod(game, "__namecall") ‚Üí BAC 6191
    ‚ùå Anti-kick (hookfunction Kick)      ‚Üí BAN
    ‚ùå ScriptContext/LogService hooks     ‚Üí Detectable
    ‚ùå getgc AC scanning                  ‚Üí Detectable
    
    Qu√© se USA (probado funcional en v6.1):
    ‚úÖ getrawmetatable(Mouse).__index
    ‚úÖ Solo Mouse.Hit y Mouse.UnitRay
    ‚úÖ Solo cuando MouseButton1 presionado
    ‚úÖ Mouse.Target/X/Y NO se tocan (causaban weapon swap)
    ‚úÖ cloneref en servicios
    ‚úÖ Cached players + characters
    ‚úÖ ESP propio del m√≥dulo CA
    ‚úÖ Aimbot completo
    
    Si el hook no puede aplicarse ‚Üí Silent Aim se desactiva
    autom√°ticamente, ESP y Aimbot siguen funcionando.
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

-- ============================================
-- EXECUTOR FUNCTIONS
-- ============================================
local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function() end
local mousemoverel = mousemoverel
    or (Input and Input.MouseMove)
    or function() end

-- ============================================
-- SERVICES (cloneref para aislar referencias)
-- ============================================
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- NO HAY ANTI-KICK (causa BAN en CA)
-- NO HAY AC NEUTRALIZATION (causa detecci√≥n)
-- Estrategia: ser invisible, no bloquear
-- ============================================

-- ============================================
-- MOUSE BUTTON TRACKING
-- Solo redirige cuando realmente se dispara
-- Previene interferencia con weapon swap/reload
-- ============================================
local isMouseDown = false

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- CACHED PLAYER LIST
-- Evita llamar GetPlayers() cada frame
-- ============================================
local CachedPlayers = {}
local CachedCharacters = {}

local function RefreshPlayerList()
    CachedPlayers = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(CachedPlayers, player)
        end
    end
end

RefreshPlayerList()

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        table.insert(CachedPlayers, player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    for i, p in ipairs(CachedPlayers) do
        if p == player then
            table.remove(CachedPlayers, i)
            break
        end
    end
    CachedCharacters[player] = nil
end)

-- ============================================
-- CHARACTER CACHE
-- Cachea character/humanoid/rootPart por jugador
-- Se refresca solo cuando el character cambia
-- ============================================
local function GetCachedCharacterData(player)
    if not player or not player.Parent then return nil end

    local cached = CachedCharacters[player]
    if cached then
        local char = cached.char
        local hum = cached.humanoid
        if char and char.Parent
            and hum and hum.Parent
            and hum.Health > 0 then
            return cached
        end
    end

    local character = player.Character
    if not character then
        CachedCharacters[player] = nil
        return nil
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        CachedCharacters[player] = nil
        return nil
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("Torso")
        or character:FindFirstChild("UpperTorso")

    local data = {
        char = character,
        humanoid = humanoid,
        rootPart = rootPart
    }

    CachedCharacters[player] = data
    return data
end

-- ============================================
-- TARGET UTILITIES
-- ============================================
local CurrentTargetPart = nil
local FrameCounter = 0
local TARGET_UPDATE_FRAMES = 2

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {
        "Head", "HumanoidRootPart",
        "UpperTorso", "Torso", "LowerTorso"
    }
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then
            return valid[math.random(1, #valid)]
        end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    Camera = Workspace.CurrentCamera
    if not Camera then return true end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, Camera}

    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local result = Workspace:Raycast(origin, direction, params)

    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function GetTargetPosition()
    if not CurrentTargetPart then return nil end
    local pos = CurrentTargetPart.Position

    if Config.Silent.Prediction
        and Config.Silent.Prediction > 0 then
        pcall(function()
            local vel = CurrentTargetPart.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Silent.Prediction
            end
        end)
    end

    return pos
end

local function FindTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end

    local closest = nil
    local closestDist = Config.FOV.Enabled
        and Config.FOV.Radius or math.huge
    local screenCenter = Camera.ViewportSize / 2

    for _, player in ipairs(CachedPlayers) do
        if not player or not player.Parent then continue end
        if Config.Silent.TeamCheck
            and player.Team and LocalPlayer.Team
            and player.Team == LocalPlayer.Team then
            continue
        end

        local data = GetCachedCharacterData(player)
        if not data then continue end
        if data.char:FindFirstChildOfClass("ForceField") then
            continue
        end

        local part = GetTargetPart(data.char, Config.Silent.TargetPart)
        if not part then continue end
        if Config.Silent.VisibleCheck and not IsVisible(part) then
            continue
        end

        local screenPos, onScreen = Camera:WorldToViewportPoint(
            part.Position
        )
        if not onScreen then continue end

        local dist = (
            Vector2.new(screenPos.X, screenPos.Y) - screenCenter
        ).Magnitude

        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end

    return closest
end

-- ============================================
-- SILENT AIM: getrawmetatable(Mouse).__index
-- 
-- ESTE ES EL M√âTODO QUE FUNCIONABA EN v6.1
-- 
-- Solo hookea Mouse.Hit y Mouse.UnitRay
-- NO toca Mouse.Target (causa weapon swap)
-- NO toca Mouse.X / Mouse.Y (causa bugs de UI)
-- Solo se activa cuando MouseButton1 est√° held
-- 
-- NO usa hookmetamethod(game, ...) en NING√öN lado
-- Eso es lo que detectaba DEVCODE.FOREST
-- ============================================

local SilentAimActive = false
local hitChancePass = false
local lastHitChanceFrame = -1

pcall(function()
    local mt = getrawmetatable(Mouse)
    if not mt then
        warn("[ANNOMALY X] getrawmetatable(Mouse) fall√≥")
        warn("[ANNOMALY X] Silent Aim DESACTIVADO para este juego")
        return
    end

    local oldIndex = mt.__index
    if not oldIndex then
        warn("[ANNOMALY X] Mouse.__index no encontrado")
        warn("[ANNOMALY X] Silent Aim DESACTIVADO para este juego")
        return
    end

    setreadonly(mt, false)

    mt.__index = newcclosure(function(self, key)
        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        -- FAST EXIT: 99.99% de __index calls NO son Mouse
        -- Esta l√≠nea es CR√çTICA para rendimiento
        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if self ~= Mouse then
            return oldIndex(self, key)
        end

        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        -- Solo redirigir durante disparo real
        -- Todas las condiciones deben cumplirse
        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if isMouseDown
            and CurrentTargetPart
            and CurrentTargetPart.Parent
            and Config.Silent.Enabled
            and Config.Silent.Active then

            -- Hit chance: calcular UNA VEZ por frame
            -- para que Mouse.Hit y Mouse.UnitRay sean
            -- consistentes en el mismo frame
            local currentFrame = FrameCounter
            if currentFrame ~= lastHitChanceFrame then
                lastHitChanceFrame = currentFrame
                hitChancePass = math.random(1, 100)
                    <= Config.Silent.HitChance
            end

            if hitChancePass then
                Camera = Workspace.CurrentCamera

                if Camera then
                    local targetPos = GetTargetPosition()

                    if targetPos then
                        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        -- SOLO estos dos se redirigen
                        -- Son los que el gun framework
                        -- usa para calcular la bala
                        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        if key == "Hit" then
                            return CFrame.new(targetPos)
                        elseif key == "UnitRay" then
                            local origin = Camera.CFrame.Position
                            local dir = (targetPos - origin).Unit
                            return Ray.new(origin, dir)
                        end

                        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        -- Mouse.Target ‚Üí NO SE TOCA
                        -- (causa weapon swap/pickup)
                        -- Mouse.X / Mouse.Y ‚Üí NO SE TOCA
                        -- (causa bugs de UI/cursor)
                        -- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    end
                end
            end
        end

        return oldIndex(self, key)
    end)

    setreadonly(mt, true)
    SilentAimActive = true
end)

-- ============================================
-- VISUAL INDICATORS
-- ============================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.Filled = false
FOVCircle.Transparency = 0.6
FOVCircle.Color = Color3.fromRGB(255, 255, 255)

local TargetDot = Drawing.new("Circle")
TargetDot.Thickness = 1
TargetDot.Filled = true
TargetDot.Transparency = 0.8
TargetDot.Color = Color3.fromRGB(0, 255, 0)
TargetDot.Radius = 5

-- ============================================
-- AIMBOT
-- ============================================
local AimTarget = nil
local AimLockedPlayer = nil

local function UpdateAimbot()
    if not Config.Aimbot.Enabled or not Config.Aimbot.Active then
        AimTarget = nil
        if not Config.Aimbot.Active then
            AimLockedPlayer = nil
        end
        return
    end

    local target = nil

    -- Aimlock: mantener target existente
    if Config.Aimbot.Method == "Aimlock"
        and AimLockedPlayer
        and AimLockedPlayer.Character then
        local char = AimLockedPlayer.Character
        local part = GetTargetPart(char, Config.Aimbot.TargetPart)
        if part and (not Config.Aimbot.VisibleCheck or IsVisible(part)) then
            target = part
        else
            AimLockedPlayer = nil
        end
    end

    -- Buscar nuevo target
    if not target then
        local cam = Workspace.CurrentCamera
        if not cam then return end
        local closestDist = Config.Aimbot.FOVRadius
        local refPoint = Config.Aimbot.Method == "Aimbot"
            and cam.ViewportSize / 2
            or UserInputService:GetMouseLocation()

        for _, player in ipairs(CachedPlayers) do
            if not player or not player.Parent then continue end
            if Config.Aimbot.TeamCheck
                and player.Team == LocalPlayer.Team then
                continue
            end

            local data = GetCachedCharacterData(player)
            if not data then continue end
            if data.char:FindFirstChildOfClass("ForceField") then
                continue
            end

            local part = GetTargetPart(data.char, Config.Aimbot.TargetPart)
            if not part then continue end
            if Config.Aimbot.VisibleCheck
                and not IsVisible(part) then
                continue
            end

            local sp, onScreen = cam:WorldToViewportPoint(part.Position)
            if not onScreen then continue end

            local dist = (
                Vector2.new(sp.X, sp.Y) - refPoint
            ).Magnitude

            if dist < closestDist then
                closestDist = dist
                target = part
                if Config.Aimbot.Method == "Aimlock" then
                    AimLockedPlayer = player
                end
            end
        end
    end

    AimTarget = target
    if not target then return end

    -- Posici√≥n con predicci√≥n
    local pos = target.Position
    if Config.Aimbot.Prediction > 0 then
        pcall(function()
            local vel = target.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Aimbot.Prediction
            end
        end)
    end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    -- Aplicar aim
    if Config.Aimbot.Method == "Aimbot" then
        local cur = cam.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        cam.CFrame = Config.Aimbot.Smoothness <= 1
            and tgt
            or cur:Lerp(tgt, 1 / Config.Aimbot.Smoothness)
    else
        local sp, on = cam:WorldToViewportPoint(pos)
        if not on then return end
        local mp = UserInputService:GetMouseLocation()
        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist < 2 then return end
        local spd = math.clamp(
            1 / math.max(Config.Aimbot.Smoothness, 1),
            0.05, 0.8
        )
        local mx = math.clamp(dx * spd, -150, 150)
        local my = math.clamp(dy * spd, -150, 150)
        if math.abs(mx) > 0.5 or math.abs(my) > 0.5 then
            mousemoverel(mx, my)
        end
    end
end

-- ============================================
-- ESP (CA-SPECIFIC)
-- El ESP del main script no encuentra los
-- characters de CA correctamente.
-- Este m√≥dulo lo maneja directamente.
-- ============================================
local CAESPObjects = {}
local LastCAESPUpdate = 0
local CA_ESP_INTERVAL = 0.12

local function CreateCAESP(player)
    if CAESPObjects[player] then return end
    CAESPObjects[player] = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }
    local e = CAESPObjects[player]
    e.Box.Thickness = 1
    e.Box.Filled = false
    e.Box.Color = Color3.fromRGB(255, 255, 255)
    e.Box.Visible = false

    e.Name.Size = 13
    e.Name.Center = true
    e.Name.Outline = true
    e.Name.Color = Color3.fromRGB(255, 255, 255)
    e.Name.Visible = false

    e.Distance.Size = 12
    e.Distance.Center = true
    e.Distance.Outline = true
    e.Distance.Color = Color3.fromRGB(200, 200, 200)
    e.Distance.Visible = false
end

local function RemoveCAESP(player)
    if CAESPObjects[player] then
        for _, d in pairs(CAESPObjects[player]) do
            pcall(function() d:Remove() end)
        end
        CAESPObjects[player] = nil
    end
end

local function HideCAESP(esp)
    esp.Box.Visible = false
    esp.Name.Visible = false
    esp.Distance.Visible = false
end

local function UpdateCAESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for _, esp in pairs(CAESPObjects) do
            HideCAESP(esp)
        end
        return
    end

    local t = tick()
    if t - LastCAESPUpdate < CA_ESP_INTERVAL then return end
    LastCAESPUpdate = t

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    for _, player in ipairs(CachedPlayers) do
        if not player or not player.Parent then continue end

        if not CAESPObjects[player] then
            CreateCAESP(player)
        end

        local esp = CAESPObjects[player]
        if not esp then continue end

        -- Team check
        if Config.ESP.TeamCheck
            and player.Team and LocalPlayer.Team
            and player.Team == LocalPlayer.Team then
            HideCAESP(esp)
            continue
        end

        local visible = false
        local data = GetCachedCharacterData(player)

        if data and data.rootPart
            and not data.char:FindFirstChildOfClass("ForceField") then

            local dist = (
                Camera.CFrame.Position - data.rootPart.Position
            ).Magnitude

            if dist <= Config.ESP.MaxDistance then
                local screenPos, onScreen = Camera:WorldToViewportPoint(
                    data.rootPart.Position
                )

                if onScreen then
                    visible = true
                    local bs = Vector2.new(2000 / dist, 2500 / dist)

                    esp.Box.Size = bs
                    esp.Box.Position = Vector2.new(
                        screenPos.X - bs.X / 2,
                        screenPos.Y - bs.Y / 2
                    )

                    -- Color por visibilidad
                    local head = data.char:FindFirstChild("Head")
                        or data.rootPart
                    local isVis = IsVisible(head)
                    esp.Box.Color = isVis
                        and Color3.fromRGB(0, 255, 0)
                        or Color3.fromRGB(255, 0, 0)
                    esp.Box.Visible = Config.ESP.Boxes

                    esp.Name.Text = player.DisplayName or player.Name
                    esp.Name.Position = Vector2.new(
                        screenPos.X,
                        screenPos.Y - bs.Y / 2 - 15
                    )
                    esp.Name.Color = Color3.fromRGB(255, 255, 255)
                    esp.Name.Visible = Config.ESP.Names

                    esp.Distance.Text = math.floor(dist) .. "m"
                    esp.Distance.Position = Vector2.new(
                        screenPos.X,
                        screenPos.Y + bs.Y / 2 + 5
                    )
                    esp.Distance.Color = Color3.fromRGB(200, 200, 200)
                    esp.Distance.Visible = Config.ESP.Distance
                end
            end
        end

        if not visible then
            HideCAESP(esp)
        end
    end
end

-- ============================================
-- SE√ëALES (le dice al main script que este
-- m√≥dulo maneja ESP y Aimbot)
-- ============================================
getgenv().AX_CAHandlesAimbot = true
getgenv().AX_CAHandlesESP = true
getgenv().AX_PF_HandlesESP = true

-- ============================================
-- LOOP PRINCIPAL
-- ============================================
RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter = FrameCounter + 1

    -- Silent Aim target (solo si el hook est√° activo)
    if SilentAimActive
        and Config.Silent.Enabled
        and Config.Silent.Active then
        if FrameCounter % TARGET_UPDATE_FRAMES == 0 then
            CurrentTargetPart = FindTarget()
        end
    else
        CurrentTargetPart = nil
    end

    -- FOV Circle
    if Config.FOV and Config.FOV.Enabled and Config.FOV.Visible then
        local mp = UserInputService:GetMouseLocation()
        FOVCircle.Position = mp
        FOVCircle.Radius = Config.FOV.Radius
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end

    -- Target dot (verde = tiene objetivo)
    if SilentAimActive
        and CurrentTargetPart
        and CurrentTargetPart.Parent
        and Camera then
        local sp, on = Camera:WorldToViewportPoint(
            CurrentTargetPart.Position
        )
        if on then
            TargetDot.Position = Vector2.new(sp.X, sp.Y)
            TargetDot.Visible = Config.Silent.Enabled
                and Config.Silent.Active
        else
            TargetDot.Visible = false
        end
    else
        TargetDot.Visible = false
    end

    -- Aimbot
    UpdateAimbot()

    -- ESP
    UpdateCAESP()
end)

-- ============================================
-- CLEANUP
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    Camera = Workspace.CurrentCamera
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
    isMouseDown = false
    CachedCharacters = {}
end)

Players.PlayerRemoving:Connect(function(player)
    RemoveCAESP(player)
    CachedCharacters[player] = nil
end)

-- ============================================
-- LOADED
-- ============================================
getgenv().AX_CALoaded = true

print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  ANNOMALY X - Combat Arena v9.0")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
print("  Silent Aim: " .. (SilentAimActive
    and "‚úÖ ACTIVO (Mouse.Hit + Mouse.UnitRay)"
    or "‚ùå DESACTIVADO (hook no disponible)"))
print("  Aimbot:     ‚úÖ ACTIVO")
print("  ESP:        ‚úÖ ACTIVO (CA-specific)")
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
if SilentAimActive then
    print("  üü¢ Punto verde = target detectado")
    print("  Solo redirige al disparar (MB1 held)")
    print("  Mouse.Target/X/Y NO se tocan")
end
print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
