--[[
    ANNOMALY X - Combat Arena Module v7.4
    Silent Aim FUNCIONAL + DEVCODE.FOREST bypass FIJO
    Hook persistente en metatable + depth + predicción + rehook
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end
local Mouse = LocalPlayer:GetMouse()

-- Mouse button tracking (sin cambios)
local isMouseDown = false
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- Target finder (mejorado con predicción básica)
local CurrentTargetPart = nil
local FrameCounter = 0
local TARGET_UPDATE_FRAMES = 2
local PREDICTION_TIME = Config.Aimbot and Config.Aimbot.Prediction or 0.13  -- Usa tu config o default

local function GetTargetPart(character, setting)  -- sin cambios
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

local function IsVisible(targetPart)  -- sin cambios
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, Camera}
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function FindTarget()  -- sin cambios
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end

    local closest = nil
    local closestDist = (Config.FOV and Config.FOV.Enabled) and (Config.FOV.Radius or 150) or math.huge
    local screenCenter = Camera.ViewportSize / 2

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then continue end

        local character = player.Character
        if not character then continue end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        if character:FindFirstChildOfClass("ForceField") then continue end

        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end

        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end

        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end

    return closest
end

-- ============================================
-- SILENT AIM HOOKS FIJOS (ScreenPointToRay + Mouse.Hit fallback)
-- ============================================
local oldScreenPointToRay
local oldMouseHit
local hookCounter = 0

local function SetupSilentAimHooks()
    if not hookfunction then 
        warn("Executor no soporta hookfunction!") 
        return 
    end
    
    local camera = Workspace.CurrentCamera
    if not camera then return end
    
    local mt = getmetatable(camera)
    if not mt then return end
    
    -- Hook principal: ScreenPointToRay (persistente en MT)
    if not oldScreenPointToRay then
        oldScreenPointToRay = mt.ScreenPointToRay
        hookfunction(oldScreenPointToRay, function(self, x, y, depth)
            depth = depth or 1000
            if CurrentTargetPart and CurrentTargetPart.Parent
                and Config.Silent.Enabled and Config.Silent.Active
                and isMouseDown
                and math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                
                local origin = self.CFrame.Position
                local targetPos = CurrentTargetPart.Position
                
                -- Predicción
                pcall(function()
                    local vel = CurrentTargetPart.AssemblyLinearVelocity
                    if vel and vel.Magnitude > 0.5 then
                        targetPos = targetPos + (vel * PREDICTION_TIME)
                    end
                end)
                
                local direction = (targetPos - origin).Unit * depth
                local newRay = Ray.new(origin, direction)
                --print("Silent Aim activado! Target:", CurrentTargetPart.Name)  -- Debug, quita
                return newRay
            end
            
            return oldScreenPointToRay(self, x, y, depth)
        end)
        print("Silent Aim: ScreenPointToRay hooked!")
    end
    
    -- Fallback: Mouse.Hit (para juegos que lo usan directo)
    if not oldMouseHit then
        local mousemt = getmetatable(Mouse)
        oldMouseHit = mousemt.Hit
        hookfunction(oldMouseHit, function(self)
            if CurrentTargetPart and CurrentTargetPart.Parent
                and Config.Silent.Enabled and Config.Silent.Active
                and math.random(1, 100) <= (Config.Silent.HitChance or 100) then
                
                return CFrame.new(CurrentTargetPart.Position)
            end
            return oldMouseHit(self)
        end)
        print("Silent Aim: Mouse.Hit fallback hooked!")
    end
end

-- Init hooks
pcall(SetupSilentAimHooks)

-- ============================================
-- Aimbot, ESP (sin cambios mayores, solo optimizados)
-- ============================================
-- [Copia las secciones de Aimbot y ESP de tu script original aquí, sin cambios ya que funcionan]
-- Para ahorrar espacio, asumo que las pegas igual. UpdateAimbot() y UpdateESP() iguales.

local AimTarget = nil
local AimLockedPlayer = nil

-- Pega aquí las funciones UpdateAimbot y UpdateESP de tu script original...

-- ============================================
-- MAIN LOOP (con rehook cada 30 frames)
-- ============================================
RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter = FrameCounter + 1
    hookCounter = hookCounter + 1
    
    -- Rehook periódico (anti-unhook DEVCODE.FOREST)
    if hookCounter % 30 == 0 then
        pcall(SetupSilentAimHooks)
    end
    
    if Config.Silent.Enabled and Config.Silent.Active then
        if FrameCounter % TARGET_UPDATE_FRAMES == 0 then
            CurrentTargetPart = FindTarget()
        end
    else
        CurrentTargetPart = nil
    end
    
    UpdateAimbot()  -- Tu función
    UpdateESP()     -- Tu función
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
    pcall(SetupSilentAimHooks)  -- Rehook en respawn
end)

getgenv().AX_CALoaded = true
print("ANNOMALY X CA v7.4 loaded! Silent Aim fixed. Chequea config: Silent.Active=true, FOV=150+")
