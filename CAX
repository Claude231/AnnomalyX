--[[
    ANNOMALY X - Combat Arena Module v7
    Method: Indirect ray redirection (no metatable hooks)
    Anti-DEVCODE.FOREST bypass
]]

-- Wait for main config silently
local _c
repeat _c = (getgenv or rawget)(_G, "AX_Config") or (getgenv and getgenv().AX_Config) task.wait(0.08) until _c
local Config = _c

-- Minimal safe refs
local _cr = cloneref or function(o) return o end
local _nc = newcclosure or function(f) return f end

local _P = _cr(game:GetService("Players"))
local _RS = _cr(game:GetService("RunService"))
local _WS = _cr(game:GetService("Workspace"))
local _UIS = _cr(game:GetService("UserInputService"))

local _LP = _P.LocalPlayer
local _Cam = _WS.CurrentCamera

-- ============================================
-- NO AGGRESSIVE AC NEUTRALIZATION
-- DEVCODE.FOREST detects:
--   - hookfunction on Kick
--   - getconnections + Disable
--   - getgc scanning for AC functions
--   - debug.info usage
--   - getrawmetatable on Mouse
-- 
-- Strategy: AVOID all of these entirely
-- Use only passive methods
-- ============================================

-- ============================================
-- SAFE PLAYER CACHE (no getgc, no debug)
-- ============================================

local _players = {}
local _charCache = {}

local function _refreshPlayers()
    _players = {}
    for _, p in ipairs(_P:GetPlayers()) do
        if p ~= _LP then
            _players[#_players + 1] = p
        end
    end
end

_refreshPlayers()

_P.PlayerAdded:Connect(function(p)
    if p ~= _LP then
        _players[#_players + 1] = p
    end
end)

_P.PlayerRemoving:Connect(function(p)
    for i = #_players, 1, -1 do
        if _players[i] == p then
            table.remove(_players, i)
            break
        end
    end
    _charCache[p] = nil
end)

-- ============================================
-- CHARACTER DATA (safe, no debug calls)
-- ============================================

local function _getCharData(player)
    if not player or not player.Parent then return nil end

    local cd = _charCache[player]
    if cd then
        local ch = cd[1]
        local hm = cd[2]
        if ch and ch.Parent and hm and hm.Parent and hm.Health > 0 then
            return cd
        end
    end

    local character = player.Character
    if not character then
        _charCache[player] = nil
        return nil
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        _charCache[player] = nil
        return nil
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("Torso")
        or character:FindFirstChild("UpperTorso")

    local d = {character, humanoid, rootPart}
    _charCache[player] = d
    return d
end

-- ============================================
-- VISIBILITY CHECK (safe raycast)
-- ============================================

local _rayParams = RaycastParams.new()
_rayParams.FilterType = Enum.RaycastFilterType.Blacklist

local function _isVisible(targetPart)
    if not targetPart then return false end
    local myChar = _LP.Character
    if not myChar then return true end
    _Cam = _WS.CurrentCamera
    if not _Cam then return true end

    _rayParams.FilterDescendantsInstances = {myChar, _Cam}
    local origin = _Cam.CFrame.Position
    local dir = targetPart.Position - origin
    local hit = _WS:Raycast(origin, dir, _rayParams)
    if hit then
        return hit.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

-- ============================================
-- TARGET PART SELECTION
-- ============================================

local _lastRndPart = "Head"
local _lastRndTime = 0

local function _getTargetPart(character, setting)
    if not character then return nil end
    local names = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}

    if setting == "Random" then
        local now = tick()
        if now - _lastRndTime > 0.5 then
            local valid = {}
            for _, n in ipairs(names) do
                if character:FindFirstChild(n) then
                    valid[#valid + 1] = n
                end
            end
            if #valid > 0 then
                _lastRndPart = valid[math.random(1, #valid)]
            end
            _lastRndTime = now
        end
        return character:FindFirstChild(_lastRndPart)
            or character:FindFirstChild("Head")
            or character:FindFirstChild("HumanoidRootPart")
    end

    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

-- ============================================
-- TARGET FINDER
-- ============================================

local _currentTarget = nil
local _frameCount = 0
local _TARGET_INTERVAL = 2

local function _findTarget()
    _Cam = _WS.CurrentCamera
    if not _Cam then return nil end

    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or 9999
    local vpSize = _Cam.ViewportSize
    local center = Vector2.new(vpSize.X * 0.5, vpSize.Y * 0.5)

    for i = 1, #_players do
        local player = _players[i]
        if not player or not player.Parent then continue end

        if Config.Silent.TeamCheck then
            local ok, same = pcall(function()
                return player.Team and _LP.Team and player.Team == _LP.Team
            end)
            if ok and same then continue end
        end

        local data = _getCharData(player)
        if not data then continue end

        local character = data[1]
        if character:FindFirstChildOfClass("ForceField") then continue end

        local part = _getTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end

        if Config.Silent.VisibleCheck and not _isVisible(part) then continue end

        local screenPos, onScreen = _Cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end

    return closest
end

-- ============================================
-- MOUSE TRACKING (passive, no hooks)
-- ============================================

local _mb1Down = false

_UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        _mb1Down = true
    end
end)

_UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        _mb1Down = false
    end
end)

-- ============================================
-- SILENT AIM: SAFE APPROACH
-- Instead of hooking Mouse metatable (detected),
-- we use Workspace:Raycast hookless redirection
-- via __namecall on workspace only when shooting
--
-- CA's DEVCODE.FOREST checks:
--   ❌ getrawmetatable(Mouse)
--   ❌ hookfunction on Player methods
--   ❌ getgc scanning
--   ❌ debug.info
--   ✅ __namecall on game (already used by main script)
--
-- Since main script sets NO_METAMETHOD = true for CA,
-- we handle silent aim via a different vector:
-- Remote interception at the network level
-- ============================================

-- Method: Hook Workspace raycast methods via hookfunction
-- This is safer than Mouse metatable for CA

local _silentActive = false

local function _shouldRedirect()
    return _silentActive
        and _currentTarget
        and _currentTarget.Parent
        and _mb1Down
        and math.random(1, 100) <= Config.Silent.HitChance
end

-- Safe workspace raycast hook (CA doesn't monitor this)
pcall(function()
    local _hf = hookfunction or replaceclosure
    if not _hf then return end

    local oldRaycast = _WS.Raycast
    if typeof(oldRaycast) ~= "function" then return end

    -- Track call depth to avoid infinite recursion
    local _inHook = false

    _hf(oldRaycast, _nc(function(self, origin, direction, ...)
        if _inHook then
            return oldRaycast(self, origin, direction, ...)
        end

        if self == _WS or self == workspace then
            if _shouldRedirect() then
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                    local targetPos = _currentTarget.Position
                    local newDir = (targetPos - origin).Unit * direction.Magnitude
                    _inHook = true
                    local result = oldRaycast(self, origin, newDir, ...)
                    _inHook = false
                    return result
                end
            end
        end

        return oldRaycast(self, origin, direction, ...)
    end))
end)

-- Also hook FindPartOnRay variants (some CA weapons use these)
pcall(function()
    local _hf = hookfunction or replaceclosure
    if not _hf then return end

    for _, methodName in ipairs({"FindPartOnRay", "FindPartOnRayWithIgnoreList", "FindPartOnRayWithWhitelist"}) do
        pcall(function()
            local oldMethod = _WS[methodName]
            if typeof(oldMethod) ~= "function" then return end

            local _inThis = false

            _hf(oldMethod, _nc(function(self, ray, ...)
                if _inThis then
                    return oldMethod(self, ray, ...)
                end

                if (self == _WS or self == workspace) and _shouldRedirect() then
                    if typeof(ray) == "Ray" then
                        local targetPos = _currentTarget.Position
                        local newRay = Ray.new(
                            ray.Origin,
                            (targetPos - ray.Origin).Unit * ray.Direction.Magnitude
                        )
                        _inThis = true
                        local result = {oldMethod(self, newRay, ...)}
                        _inThis = false
                        return unpack(result)
                    end
                end

                return oldMethod(self, ray, ...)
            end))
        end)
    end
end)

-- ============================================
-- AIMBOT (CA-specific, safe mousemoverel)
-- ============================================

local _aimTarget = nil
local _aimLocked = nil
local _aimRndPart = "Head"
local _aimRndTime = 0

local function _getAimPart(character)
    if not character then return nil end

    if Config.Aimbot.TargetPart == "Random" then
        local now = tick()
        if now - _aimRndTime >= (Config.Aimbot.RandomInterval or 0.5) then
            local opts = {}
            for _, n in ipairs({"Head", "HumanoidRootPart", "UpperTorso", "Torso"}) do
                if character:FindFirstChild(n) then
                    opts[#opts + 1] = n
                end
            end
            if #opts > 0 then
                _aimRndPart = opts[math.random(1, #opts)]
            end
            _aimRndTime = now
        end
        return character:FindFirstChild(_aimRndPart)
            or character:FindFirstChild("Head")
            or character:FindFirstChild("HumanoidRootPart")
    end

    return character:FindFirstChild(Config.Aimbot.TargetPart)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

local function _isValidAimTarget(player)
    if not player or not player.Parent then return false end
    if player == _LP then return false end

    if Config.Aimbot.TeamCheck then
        local ok, same = pcall(function()
            return player.Team and _LP.Team and player.Team == _LP.Team
        end)
        if ok and same then return false end
    end

    local c = player.Character
    if not c then return false end
    if c:FindFirstChildOfClass("ForceField") then return false end
    local h = c:FindFirstChildOfClass("Humanoid")
    return h and h.Health > 0
end

local function _getAimTarget()
    _Cam = _WS.CurrentCamera
    if not _Cam then return nil end

    local method = Config.Aimbot.Method

    if method == "Aimlock" then
        if _aimLocked and _isValidAimTarget(_aimLocked) then
            local tp = _getAimPart(_aimLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or _isVisible(tp)) then
                local sp, on = _Cam:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
            _aimLocked = nil
        end
    end

    local mousePos = _UIS:GetMouseLocation()
    local useCenter = (method == "Aimbot")
    local refPoint
    if useCenter then
        local vp = _Cam.ViewportSize
        refPoint = Vector2.new(vp.X * 0.5, vp.Y * 0.5)
    else
        refPoint = mousePos
    end

    local closestPart, closestDist, closestPlayer = nil, Config.Aimbot.FOVRadius, nil

    for i = 1, #_players do
        local player = _players[i]
        if not _isValidAimTarget(player) then continue end

        local tp = _getAimPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not _isVisible(tp) then continue end

        local sp, on = _Cam:WorldToViewportPoint(tp.Position)
        if not on then continue end

        local d = (refPoint - Vector2.new(sp.X, sp.Y)).Magnitude
        if d < closestDist then
            closestDist = d
            closestPart = tp
            closestPlayer = player
        end
    end

    if method == "Aimlock" and closestPlayer then
        _aimLocked = closestPlayer
    end

    return closestPart
end

local _mmr = mousemoverel or (Input and Input.MouseMove) or function() end

local function _updateAimbot()
    if not Config.Aimbot.Enabled or not Config.Aimbot.Active then
        _aimTarget = nil
        if not Config.Aimbot.Active then _aimLocked = nil end
        return
    end

    local tp = _getAimTarget()
    _aimTarget = tp
    if not tp then return end

    local pos = tp.Position

    if (Config.Aimbot.Prediction or 0) > 0 then
        pcall(function()
            local vel = tp.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Aimbot.Prediction
            end
        end)
    end

    _Cam = _WS.CurrentCamera
    if not _Cam then return end

    local sm = Config.Aimbot.Smoothness or 5

    if Config.Aimbot.Method == "Aimbot" then
        local cur = _Cam.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        _Cam.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
    elseif Config.Aimbot.Method == "Aimlock" then
        local sp, on = _Cam:WorldToViewportPoint(pos)
        if not on then return end
        local mp = _UIS:GetMouseLocation()
        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist < 2 then return end
        local spd = math.clamp(1 / math.max(sm, 1), 0.05, 0.8)
        local mx = math.clamp(dx * spd, -150, 150)
        local my = math.clamp(dy * spd, -150, 150)
        if math.abs(mx) > 0.5 or math.abs(my) > 0.5 then
            _mmr(mx, my)
        end
    end
end

-- ============================================
-- ESP (CA-specific, Drawing API only)
-- ============================================

local _espObjs = {}
local _lastEspUpdate = 0
local _ESP_INTERVAL = 0.12

local function _createEsp(player)
    if _espObjs[player] then return end
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = Color3.fromRGB(255, 255, 255)
    box.Visible = false

    local name = Drawing.new("Text")
    name.Size = 13
    name.Center = true
    name.Outline = true
    name.Color = Color3.fromRGB(255, 255, 255)
    name.Visible = false

    local dist = Drawing.new("Text")
    dist.Size = 12
    dist.Center = true
    dist.Outline = true
    dist.Color = Color3.fromRGB(200, 200, 200)
    dist.Visible = false

    _espObjs[player] = {box, name, dist}
end

local function _removeEsp(player)
    local e = _espObjs[player]
    if e then
        for i = 1, 3 do
            pcall(function() e[i]:Remove() end)
        end
        _espObjs[player] = nil
    end
end

local function _hideEsp(e)
    e[1].Visible = false
    e[2].Visible = false
    e[3].Visible = false
end

local function _updateEsp()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for _, e in pairs(_espObjs) do
            _hideEsp(e)
        end
        return
    end

    local now = tick()
    if now - _lastEspUpdate < _ESP_INTERVAL then return end
    _lastEspUpdate = now

    _Cam = _WS.CurrentCamera
    if not _Cam then return end

    for i = 1, #_players do
        local player = _players[i]
        if not player or not player.Parent then continue end

        if not _espObjs[player] then
            _createEsp(player)
        end

        local e = _espObjs[player]
        if not e then continue end

        if Config.ESP.TeamCheck then
            local ok, same = pcall(function()
                return player.Team and _LP.Team and player.Team == _LP.Team
            end)
            if ok and same then
                _hideEsp(e)
                continue
            end
        end

        local visible = false
        local data = _getCharData(player)

        if data and data[3] and not data[1]:FindFirstChildOfClass("ForceField") then
            local d = (_Cam.CFrame.Position - data[3].Position).Magnitude

            if d <= Config.ESP.MaxDistance then
                local sp, on = _Cam:WorldToViewportPoint(data[3].Position)

                if on then
                    visible = true
                    local bx = 2000 / d
                    local by = 2500 / d

                    e[1].Size = Vector2.new(bx, by)
                    e[1].Position = Vector2.new(sp.X - bx * 0.5, sp.Y - by * 0.5)
                    e[1].Visible = Config.ESP.Boxes

                    e[2].Text = player.Name
                    e[2].Position = Vector2.new(sp.X, sp.Y - by * 0.5 - 15)
                    e[2].Visible = Config.ESP.Names

                    e[3].Text = math.floor(d) .. "m"
                    e[3].Position = Vector2.new(sp.X, sp.Y + by * 0.5 + 5)
                    e[3].Visible = Config.ESP.Distance
                end
            end
        end

        if not visible then
            _hideEsp(e)
        end
    end
end

-- ============================================
-- SIGNALS (use obscured names)
-- ============================================

-- Tell main script this module handles aimbot + ESP
getgenv().AX_CAHandlesAimbot = true
getgenv().AX_CAHandlesESP = true
-- Reuse PF ESP flag to prevent generic ESP creation
getgenv().AX_PF_HandlesESP = true

-- ============================================
-- MAIN LOOP
-- ============================================

_RS.Heartbeat:Connect(function()
    _Cam = _WS.CurrentCamera
    _frameCount = _frameCount + 1

    -- Update silent aim active state
    _silentActive = Config.Silent.Enabled and Config.Silent.Active

    -- Find target for silent
    if _silentActive then
        if _frameCount % _TARGET_INTERVAL == 0 then
            _currentTarget = _findTarget()
        end
    else
        _currentTarget = nil
    end

    -- Aimbot
    _updateAimbot()

    -- ESP
    _updateEsp()
end)

-- ============================================
-- CLEANUP ON RESPAWN
-- ============================================

_LP.CharacterAdded:Connect(function()
    task.wait(0.5)
    _Cam = _WS.CurrentCamera
    _currentTarget = nil
    _mb1Down = false
    _aimTarget = nil
    _aimLocked = nil
    _charCache = {}
end)

_P.PlayerRemoving:Connect(function(player)
    _removeEsp(player)
    _charCache[player] = nil
    if _aimLocked == player then _aimLocked = nil end
end)

-- Signal loaded (no prints - CA monitors console output)
getgenv().AX_CALoaded = true
