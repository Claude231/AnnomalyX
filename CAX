--[[
    ANNOMALY X - Combat Arena Module v8.0
    SILENT AIM DEFINITIVO - Hookea los 4 métodos posibles
    
    ✓ Mouse.Hit / Mouse.Target / Mouse.UnitRay  (Método 1)
    ✓ Camera:ViewportPointToRay / ScreenPointToRay (Método 2)
    ✓ RemoteEvent/RemoteFunction argumentos       (Método 3)
    ✓ workspace:Raycast redirección               (Método 4)
    
    Sin importar cuál use Combat Arena, FUNCIONA.
    Incluye herramienta de debug para diagnosticar.
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

-- ============================================
-- SERVICIOS Y VARIABLES GLOBALES
-- ============================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

local checkcaller = checkcaller or function() return true end
local newcclosure = newcclosure or function(f) return f end
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

-- Flag para proteger nuestras propias llamadas
local AX_INTERNAL_CALL = false

-- ============================================
-- MOUSE TRACKING
-- ============================================
local isMouseDown = false

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- UTILIDADES DE TARGETING
-- ============================================
local CurrentTargetPart = nil
local FrameCounter = 0
local TARGET_UPDATE_FRAMES = 2

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end

    AX_INTERNAL_CALL = true

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character, cam}

    local origin = cam.CFrame.Position
    local direction = (targetPart.Position - origin)
    local result = Workspace:Raycast(origin, direction, params)

    AX_INTERNAL_CALL = false

    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end

    AX_INTERNAL_CALL = true

    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or 500
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team
            and player.Team == LocalPlayer.Team then continue end

        local character = player.Character
        if not character then continue end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        if character:FindFirstChildOfClass("ForceField") then continue end

        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end
        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end

        local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end

        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end

    AX_INTERNAL_CALL = false
    return closest
end

-- ============================================
-- SILENT AIM - SISTEMA DE CONTROL
-- ============================================
local hitChanceResult = false
local lastHitChanceCalc = 0

local function ShouldRedirect()
    if AX_INTERNAL_CALL then return false end
    if not Config.Silent.Enabled then return false end
    if not Config.Silent.Active then return false end
    if not isMouseDown then return false end
    if not CurrentTargetPart then return false end
    if not CurrentTargetPart.Parent then return false end

    -- Calcular hit chance una vez por ventana de tiempo
    local now = tick()
    if now - lastHitChanceCalc > 0.08 then
        lastHitChanceCalc = now
        hitChanceResult = math.random(1, 100) <= Config.Silent.HitChance
    end

    return hitChanceResult
end

local function GetTargetPosition()
    if not CurrentTargetPart then return nil end
    local pos = CurrentTargetPart.Position

    -- Predicción de movimiento
    if Config.Silent.Prediction and Config.Silent.Prediction > 0 then
        pcall(function()
            local vel = CurrentTargetPart.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Silent.Prediction
            end
        end)
    end

    return pos
end

local function GetRedirectedDirection(origin)
    local targetPos = GetTargetPosition()
    if not targetPos then return nil end
    return (targetPos - origin).Unit
end

-- ============================================
-- HOOK 1: Mouse.__index
-- Spoofea Mouse.Hit, Mouse.Target, Mouse.UnitRay, Mouse.X, Mouse.Y
-- Este es el método más universal para Roblox FPS
-- ============================================
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if not checkcaller() and not AX_INTERNAL_CALL and self == Mouse and ShouldRedirect() then
        local cam = Workspace.CurrentCamera
        local targetPos = GetTargetPosition()

        if cam and targetPos then
            if key == "Hit" then
                return CFrame.new(targetPos)
            elseif key == "Target" then
                return CurrentTargetPart
            elseif key == "UnitRay" then
                local origin = cam.CFrame.Position
                return Ray.new(origin, (targetPos - origin).Unit)
            elseif key == "X" then
                local pos = cam:WorldToViewportPoint(targetPos)
                return pos.X
            elseif key == "Y" then
                local pos = cam:WorldToViewportPoint(targetPos)
                return pos.Y
            end
        end
    end
    return oldIndex(self, key)
end))

-- ============================================
-- HOOK 2: __namecall
-- Cubre Camera methods + RemoteEvents + Raycast
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()

    if checkcaller() or AX_INTERNAL_CALL then
        return oldNamecall(self, ...)
    end

    if not ShouldRedirect() then
        return oldNamecall(self, ...)
    end

    local cam = Workspace.CurrentCamera
    local targetPos = GetTargetPosition()
    if not cam or not targetPos then
        return oldNamecall(self, ...)
    end

    local origin = cam.CFrame.Position
    local dir = (targetPos - origin).Unit

    -- ---- Camera:ViewportPointToRay / Camera:ScreenPointToRay ----
    if self == cam then
        if method == "ViewportPointToRay" or method == "ScreenPointToRay" then
            return Ray.new(origin, dir)
        end
    end

    -- ---- workspace:Raycast ----
    if self == Workspace and method == "Raycast" then
        local args = {...}
        local rayOrigin = args[1]
        if typeof(rayOrigin) == "Vector3" then
            local distFromCam = (rayOrigin - origin).Magnitude
            if distFromCam < 15 then
                local rayDir = args[2]
                if typeof(rayDir) == "Vector3" then
                    args[2] = (targetPos - rayOrigin).Unit * rayDir.Magnitude
                    return oldNamecall(self, unpack(args))
                end
            end
        end
    end

    -- ---- workspace:FindPartOnRay (legacy) ----
    if self == Workspace and (method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist") then
        local args = {...}
        local ray = args[1]
        if typeof(ray) == "Ray" then
            local distFromCam = (ray.Origin - origin).Magnitude
            if distFromCam < 15 then
                local newRay = Ray.new(ray.Origin, (targetPos - ray.Origin).Unit * ray.Direction.Magnitude)
                args[1] = newRay
                return oldNamecall(self, unpack(args))
            end
        end
    end

    -- ---- RemoteEvent:FireServer ----
    if method == "FireServer" and typeof(self) == "Instance" and self:IsA("RemoteEvent") then
        local args = {...}
        local modified = false

        for i, arg in ipairs(args) do
            if typeof(arg) == "Vector3" then
                local mag = arg.Magnitude
                if mag > 0.5 and mag < 1.5 then
                    args[i] = dir
                    modified = true
                elseif mag > 50 then
                    args[i] = targetPos
                    modified = true
                end
            elseif typeof(arg) == "CFrame" then
                args[i] = CFrame.lookAt(origin, targetPos)
                modified = true
            elseif typeof(arg) == "table" then
                for k, v in pairs(arg) do
                    if typeof(v) == "Vector3" then
                        local lk = string.lower(tostring(k))
                        if lk:find("dir") or lk:find("aim") or lk:find("look")
                            or lk:find("fire") or lk:find("ray") or lk:find("cast") then
                            arg[k] = dir
                            modified = true
                        elseif lk:find("pos") or lk:find("hit") or lk:find("point")
                            or lk:find("target") or lk:find("end") then
                            arg[k] = targetPos
                            modified = true
                        end
                    elseif typeof(v) == "CFrame" then
                        local lk = string.lower(tostring(k))
                        if lk:find("cam") or lk:find("aim") or lk:find("look") or lk:find("cf") then
                            arg[k] = CFrame.lookAt(origin, targetPos)
                            modified = true
                        end
                    end
                end
            end
        end

        if modified then
            return oldNamecall(self, unpack(args))
        end
    end

    -- ---- RemoteFunction:InvokeServer ----
    if method == "InvokeServer" and typeof(self) == "Instance" and self:IsA("RemoteFunction") then
        local args = {...}
        local modified = false

        for i, arg in ipairs(args) do
            if typeof(arg) == "Vector3" then
                local mag = arg.Magnitude
                if mag > 0.5 and mag < 1.5 then
                    args[i] = dir
                    modified = true
                end
            elseif typeof(arg) == "table" then
                for k, v in pairs(arg) do
                    if typeof(v) == "Vector3" then
                        local lk = string.lower(tostring(k))
                        if lk:find("dir") or lk:find("aim") or lk:find("look")
                            or lk:find("fire") or lk:find("ray") then
                            arg[k] = dir
                            modified = true
                        end
                    end
                end
            end
        end

        if modified then
            return oldNamecall(self, unpack(args))
        end
    end

    return oldNamecall(self, ...)
end))

-- ============================================
-- INDICADOR VISUAL DE TARGET (Circle en pantalla)
-- Confirma visualmente que el Silent Aim detecta enemigos
-- ============================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.Filled = false
FOVCircle.Transparency = 0.6
FOVCircle.Color = Color3.fromRGB(255, 255, 255)

local TargetDot = Drawing.new("Circle")
TargetDot.Thickness = 1
TargetDot.Filled = true
TargetDot.Transparency = 0.8
TargetDot.Color = Color3.fromRGB(0, 255, 0)
TargetDot.Radius = 5

-- ============================================
-- AIMBOT
-- ============================================
local AimTarget = nil
local AimLockedPlayer = nil

local function UpdateAimbot()
    if not Config.Aimbot.Enabled or not Config.Aimbot.Active then
        AimTarget = nil
        if not Config.Aimbot.Active then AimLockedPlayer = nil end
        return
    end

    local target = nil

    if Config.Aimbot.Method == "Aimlock" and AimLockedPlayer and AimLockedPlayer.Character then
        local char = AimLockedPlayer.Character
        local part = GetTargetPart(char, Config.Aimbot.TargetPart)
        if part and (not Config.Aimbot.VisibleCheck or IsVisible(part)) then
            target = part
        else
            AimLockedPlayer = nil
        end
    end

    if not target then
        local cam = Workspace.CurrentCamera
        if not cam then return end
        local closestDist = Config.Aimbot.FOVRadius
        local refPoint = Config.Aimbot.Method == "Aimbot"
            and cam.ViewportSize / 2
            or UserInputService:GetMouseLocation()

        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if Config.Aimbot.TeamCheck and player.Team == LocalPlayer.Team then continue end
            local char = player.Character
            if not char then continue end
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end
            if char:FindFirstChildOfClass("ForceField") then continue end

            local part = GetTargetPart(char, Config.Aimbot.TargetPart)
            if not part then continue end
            if Config.Aimbot.VisibleCheck and not IsVisible(part) then continue end

            AX_INTERNAL_CALL = true
            local sp, onScreen = cam:WorldToViewportPoint(part.Position)
            AX_INTERNAL_CALL = false
            if not onScreen then continue end

            local dist = (Vector2.new(sp.X, sp.Y) - refPoint).Magnitude
            if dist < closestDist then
                closestDist = dist
                target = part
                if Config.Aimbot.Method == "Aimlock" then
                    AimLockedPlayer = player
                end
            end
        end
    end

    AimTarget = target
    if not target then return end

    local pos = target.Position

    if Config.Aimbot.Prediction > 0 then
        pcall(function()
            local vel = target.AssemblyLinearVelocity
            if vel and vel.Magnitude > 0.5 then
                pos = pos + vel * Config.Aimbot.Prediction
            end
        end)
    end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    if Config.Aimbot.Method == "Aimbot" then
        local cur = cam.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        cam.CFrame = Config.Aimbot.Smoothness <= 1 and tgt
            or cur:Lerp(tgt, 1 / Config.Aimbot.Smoothness)
    else
        AX_INTERNAL_CALL = true
        local sp, on = cam:WorldToViewportPoint(pos)
        AX_INTERNAL_CALL = false
        if not on then return end
        local mp = UserInputService:GetMouseLocation()
        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist < 2 then return end
        local spd = math.clamp(1 / math.max(Config.Aimbot.Smoothness, 1), 0.05, 0.8)
        local mx = math.clamp(dx * spd, -150, 150)
        local my = math.clamp(dy * spd, -150, 150)
        if math.abs(mx) > 0.5 or math.abs(my) > 0.5 then
            mousemoverel(mx, my)
        end
    end
end

-- ============================================
-- ESP
-- ============================================
local ESPObjects = {}

local function UpdateESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for _, esp in pairs(ESPObjects) do
            if esp then
                if esp.Box then esp.Box.Visible = false end
                if esp.Name then esp.Name.Visible = false end
                if esp.Distance then esp.Distance.Visible = false end
            end
        end
        return
    end

    local cam = Workspace.CurrentCamera
    if not cam then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        if not ESPObjects[player] then
            ESPObjects[player] = {
                Box = Drawing.new("Square"),
                Name = Drawing.new("Text"),
                Distance = Drawing.new("Text")
            }
            local e = ESPObjects[player]
            e.Box.Thickness = 1
            e.Box.Filled = false
            e.Name.Size = 13
            e.Name.Center = true
            e.Name.Outline = true
            e.Distance.Size = 12
            e.Distance.Center = true
            e.Distance.Outline = true
        end

        local esp = ESPObjects[player]
        local char = player.Character
        local root = char and (char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso"))

        if char and root
            and char:FindFirstChildOfClass("Humanoid")
            and char:FindFirstChildOfClass("Humanoid").Health > 0
            and not char:FindFirstChildOfClass("ForceField") then

            local dist = (cam.CFrame.Position - root.Position).Magnitude
            if dist <= Config.ESP.MaxDistance then
                AX_INTERNAL_CALL = true
                local sp, onScreen = cam:WorldToViewportPoint(root.Position)
                AX_INTERNAL_CALL = false

                if onScreen then
                    local size = Vector2.new(2000 / dist, 2500 / dist)
                    esp.Box.Size = size
                    esp.Box.Position = Vector2.new(sp.X - size.X / 2, sp.Y - size.Y / 2)
                    local head = char:FindFirstChild("Head") or root
                    local visible = IsVisible(head)
                    esp.Box.Color = visible and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    esp.Box.Visible = Config.ESP.Boxes

                    esp.Name.Text = player.DisplayName or player.Name
                    esp.Name.Position = Vector2.new(sp.X, sp.Y - size.Y / 2 - 15)
                    esp.Name.Color = Color3.fromRGB(255, 255, 255)
                    esp.Name.Visible = Config.ESP.Names

                    esp.Distance.Text = math.floor(dist) .. "m"
                    esp.Distance.Position = Vector2.new(sp.X, sp.Y + size.Y / 2 + 5)
                    esp.Distance.Color = Color3.fromRGB(255, 255, 255)
                    esp.Distance.Visible = Config.ESP.Distance
                else
                    esp.Box.Visible = false
                    esp.Name.Visible = false
                    esp.Distance.Visible = false
                end
            else
                esp.Box.Visible = false
                esp.Name.Visible = false
                esp.Distance.Visible = false
            end
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.Distance.Visible = false
        end
    end
end

Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        pcall(function()
            ESPObjects[player].Box:Remove()
            ESPObjects[player].Name:Remove()
            ESPObjects[player].Distance:Remove()
        end)
        ESPObjects[player] = nil
    end
end)

-- ============================================
-- SEÑALES
-- ============================================
getgenv().AX_CAHandlesAimbot = true
getgenv().AX_CAHandlesESP = true
getgenv().AX_PF_HandlesESP = true

-- ============================================
-- LOOP PRINCIPAL
-- ============================================
RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    FrameCounter = FrameCounter + 1

    -- Actualizar target para Silent Aim
    if Config.Silent.Enabled and Config.Silent.Active then
        if FrameCounter % TARGET_UPDATE_FRAMES == 0 then
            CurrentTargetPart = FindTarget()
        end
    else
        CurrentTargetPart = nil
    end

    -- FOV Circle visual
    if Config.FOV and Config.FOV.Enabled and Config.FOV.Visible then
        local mp = UserInputService:GetMouseLocation()
        FOVCircle.Position = mp
        FOVCircle.Radius = Config.FOV.Radius
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end

    -- Target indicator
    if CurrentTargetPart and CurrentTargetPart.Parent and Camera then
        AX_INTERNAL_CALL = true
        local sp, on = Camera:WorldToViewportPoint(CurrentTargetPart.Position)
        AX_INTERNAL_CALL = false
        if on then
            TargetDot.Position = Vector2.new(sp.X, sp.Y)
            TargetDot.Visible = Config.Silent.Enabled and Config.Silent.Active
            TargetDot.Color = Color3.fromRGB(0, 255, 0)
        else
            TargetDot.Visible = false
        end
    else
        TargetDot.Visible = false
    end

    UpdateAimbot()
    UpdateESP()
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    CurrentTargetPart = nil
    AimTarget = nil
    AimLockedPlayer = nil
end)

getgenv().AX_CALoaded = true
print("[ANNOMALY X] Combat Arena v8.0 DEFINITIVO cargado")
print("[ANNOMALY X] Silent Aim: 4 métodos hookeados simultáneamente")
print("[ANNOMALY X] Si ves un punto VERDE sobre enemigos = target detectado")

-- ============================================
-- HERRAMIENTA DE DEBUG (IMPORTANTE)
-- Si el Silent Aim no pega, DESCOMENTA esto,
-- dispara en el juego, y mira la consola F9
-- para ver exactamente qué Remotes usa CA
-- ============================================
--[[
getgenv().AX_DEBUG_REMOTES = true
local debugOldNamecall
debugOldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if getgenv().AX_DEBUG_REMOTES then
        local method = getnamecallmethod()
        if (method == "FireServer" or method == "InvokeServer") and isMouseDown then
            if typeof(self) == "Instance" and (self:IsA("RemoteEvent") or self:IsA("RemoteFunction")) then
                print("====== REMOTE AL DISPARAR ======")
                print("Nombre:", self.Name)
                print("Ruta:", self:GetFullName())
                print("Método:", method)
                local args = {...}
                for i, arg in ipairs(args) do
                    print("  Arg[" .. i .. "]:", typeof(arg), tostring(arg))
                    if typeof(arg) == "table" then
                        for k, v in pairs(arg) do
                            print("    ." .. tostring(k) .. ":", typeof(v), tostring(v))
                        end
                    end
                end
                print("================================")
            end
        end
    end
    return debugOldNamecall(self, ...)
end))
print("[DEBUG] Herramienta de espionaje de Remotes ACTIVA - Dispara y mira F9")
]]
