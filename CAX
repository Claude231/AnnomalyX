--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║        ANNOMALY X - Combat Arena Module v2                ║
    ║        Advanced BAC-7198 Bypass + Selective Silent Aim    ║
    ║        Integrated Bypassel techniques (safe ones only)    ║
    ║        Creator: ElSacaLeche                               ║
    ╚═══════════════════════════════════════════════════════════╝
    
    BAC-7198 ANALYSIS:
    This error triggers when Combat Arena detects:
    1. Global __namecall hook intercepting AC verification raycasts
    2. Modified raycast results that don't match camera direction
    3. Hook detection via integrity checks
    4. Memory signature scanning finding exploit traces
    
    SOLUTION (Multi-layer):
    Layer 1: Bypassel techniques (handshake, memory, integrity, hooks)
    Layer 2: Selective __namecall (ONLY RemoteEvent FireServer)
    Layer 3: Workspace:Raycast passes through UNMODIFIED
    Layer 4: Continuous AC monitoring and neutralization
    Layer 5: Kick protection + error suppression
    
    WHAT WE DO NOT TOUCH:
    - Workspace:Raycast (this triggers BAC instantly)
    - Workspace:FindPartOnRay (same reason)
    - debug.info globally (breaks executor)
    - detour_function (breaks executor)
]]

-- Wait for Config
if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getconnections = getconnections
local getgc = getgc
local getscripts = getscripts
local setreadonly = setreadonly or function() end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local LogService = cloneref(game:GetService("LogService"))
local ScriptContext = cloneref(game:GetService("ScriptContext"))
local HttpService = cloneref(game:GetService("HttpService"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer

-- Results tracking
local BypassResults = {
    handshakes = 0,
    hookChecks = 0,
    memoryPatches = 0,
    integrityBypasses = 0,
    signaturesCleaned = 0,
    acFunctions = 0,
    acRemotes = 0,
    acScripts = 0,
    acConnections = 0,
    kickBlocked = false,
    errorsBlocked = 0
}

-- ============================================
-- LAYER 1A: HANDSHAKE BYPASS
-- Blocks validation/verification remotes
-- ============================================
local function BypassHandshakes()
    pcall(function()
        local function ScanRemotes(parent)
            for _, remote in pairs(parent:GetDescendants()) do
                if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
                    local name = remote.Name:lower()
                    if name:find("handshake") or name:find("validate") 
                        or name:find("verify") or name:find("heartbeat_check")
                        or name:find("ping_check") or name:find("auth") then
                        
                        if remote:IsA("RemoteEvent") then
                            -- Don't block FireServer entirely, just make it return safely
                            pcall(function()
                                if remote.OnClientEvent then
                                    for _, conn in pairs(getconnections(remote.OnClientEvent)) do
                                        pcall(function() conn:Disable() end)
                                        BypassResults.handshakes = BypassResults.handshakes + 1
                                    end
                                end
                            end)
                        elseif remote:IsA("RemoteFunction") then
                            pcall(function()
                                if remote.OnClientInvoke then
                                    remote.OnClientInvoke = function()
                                        return true
                                    end
                                    BypassResults.handshakes = BypassResults.handshakes + 1
                                end
                            end)
                        end
                    end
                end
            end
        end
        
        ScanRemotes(ReplicatedStorage)
        pcall(function() ScanRemotes(game:GetService("StarterPlayer")) end)
    end)
end

-- ============================================
-- LAYER 1B: HOOK CHECK BYPASS
-- Prevents detection of our hooks
-- ============================================
local function BypassHookChecks()
    pcall(function()
        -- Disable ScriptContext.Error connections (prevents error-based detection)
        if getconnections then
            for _, conn in ipairs(getconnections(ScriptContext.Error)) do
                pcall(function()
                    conn:Disable()
                    BypassResults.hookChecks = BypassResults.hookChecks + 1
                end)
            end
            
            -- Prevent new error connections
            pcall(function()
                hookfunction(ScriptContext.Error.Connect, newcclosure(function(...)
                    return nil
                end))
                BypassResults.hookChecks = BypassResults.hookChecks + 1
            end)
        end
    end)
end

-- ============================================
-- LAYER 1C: MEMORY CHECK BYPASS
-- Cleans exploit signatures from memory
-- ============================================
local function BypassMemoryChecks()
    pcall(function()
        -- Remove AC signatures from GC tables
        if getgc then
            for _, obj in ipairs(getgc(true)) do
                if type(obj) == "table" then
                    pcall(function()
                        -- Clean known AC signature keys
                        local acKeys = {
                            "__acsignature", "__checksum", "__hash",
                            "__integrity", "__validation", "__exploit_flag",
                            "_ac_token", "_security_hash", "_verified"
                        }
                        for _, key in ipairs(acKeys) do
                            if rawget(obj, key) then
                                rawset(obj, key, nil)
                                BypassResults.memoryPatches = BypassResults.memoryPatches + 1
                            end
                        end
                    end)
                end
            end
        end
        
        -- Make registry writable (safe version)
        if setreadonly then
            pcall(function() setreadonly(getrenv(), false) end)
            BypassResults.memoryPatches = BypassResults.memoryPatches + 1
        end
    end)
end

-- ============================================
-- LAYER 1D: INTEGRITY CHECK BYPASS
-- Disables script monitoring connections
-- ============================================
local function BypassIntegrityChecks()
    pcall(function()
        if getconnections then
            -- Disable ScriptAdded monitoring
            pcall(function()
                for _, conn in ipairs(getconnections(ScriptContext.ScriptAdded)) do
                    pcall(function()
                        conn:Disable()
                        BypassResults.integrityBypasses = BypassResults.integrityBypasses + 1
                    end)
                end
            end)
            
            -- Disable ScriptRemoved monitoring
            pcall(function()
                for _, conn in ipairs(getconnections(ScriptContext.ScriptRemoved)) do
                    pcall(function()
                        conn:Disable()
                        BypassResults.integrityBypasses = BypassResults.integrityBypasses + 1
                    end)
                end
            end)
        end
    end)
end

-- ============================================
-- LAYER 1E: SIGNATURE CLEANUP
-- Removes exploit traces from global tables
-- ============================================
local function CleanSignatures()
    pcall(function()
        local signatureKeys = {"signature", "checksum", "hash", "exploit", "cheat", "hack"}
        
        -- Clean _G
        pcall(function()
            for key, _ in pairs(_G) do
                local keyStr = tostring(key):lower()
                for _, sigKey in ipairs(signatureKeys) do
                    if keyStr:find(sigKey) then
                        _G[key] = nil
                        BypassResults.signaturesCleaned = BypassResults.signaturesCleaned + 1
                        break
                    end
                end
            end
        end)
        
        -- Clean shared
        pcall(function()
            for key, _ in pairs(shared) do
                local keyStr = tostring(key):lower()
                for _, sigKey in ipairs(signatureKeys) do
                    if keyStr:find(sigKey) then
                        shared[key] = nil
                        BypassResults.signaturesCleaned = BypassResults.signaturesCleaned + 1
                        break
                    end
                end
            end
        end)
    end)
end

-- ============================================
-- LAYER 2: AC FUNCTION SCANNER
-- Finds and neutralizes anticheat functions in GC
-- ============================================
local function NeutralizeACFunctions()
    pcall(function()
        for _, v in pairs(getgc(true)) do
            -- Hook AC functions found by source name
            if typeof(v) == "function" then
                local ok, src = pcall(function()
                    return debug.info(v, "s")
                end)
                if ok and type(src) == "string" then
                    local acSources = {
                        "AntiCheat", "anticheat", "AntiExploit", "antiexploit",
                        "Integrity", "Validation", "Detection", "Security",
                        "BAC", "Checker", "Monitor", "Verify", "Guard",
                        "Sentinel", "Shield", "Protect", "Enforce"
                    }
                    for _, keyword in ipairs(acSources) do
                        if src:find(keyword) then
                            pcall(function()
                                hookfunction(v, newcclosure(function(...)
                                    return nil
                                end))
                                BypassResults.acFunctions = BypassResults.acFunctions + 1
                            end)
                            break
                        end
                    end
                end
            end
            
            -- Neutralize AC tables with detect/ban/report functions
            if typeof(v) == "table" then
                pcall(function()
                    local acTableKeys = {
                        "Detect", "detect", "Detected", "detected",
                        "Ban", "ban", "Kick", "kick",
                        "Report", "report", "Flag", "flag",
                        "Punish", "punish", "Violation", "violation"
                    }
                    for _, key in ipairs(acTableKeys) do
                        local func = rawget(v, key)
                        if typeof(func) == "function" then
                            hookfunction(func, newcclosure(function(...)
                                return nil
                            end))
                            BypassResults.acFunctions = BypassResults.acFunctions + 1
                        end
                    end
                end)
            end
        end
    end)
end

-- ============================================
-- LAYER 3: AC REMOTE BLOCKER
-- Blocks anticheat reporting remotes
-- ============================================
local function BlockACRemotes()
    pcall(function()
        local function ScanAndBlock(parent)
            for _, child in pairs(parent:GetDescendants()) do
                if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                    local name = child.Name:lower()
                    local acRemoteNames = {
                        "anticheat", "anti_cheat", "ac_", "integrity",
                        "validation", "security", "detect", "report",
                        "flag", "violation", "ban", "kick",
                        "verify", "check", "monitor", "bac",
                        "sentinel", "shield", "guard", "enforce",
                        "suspicious", "exploit", "cheat", "hack"
                    }
                    for _, acName in ipairs(acRemoteNames) do
                        if name:find(acName) then
                            if child:IsA("RemoteEvent") and child.OnClientEvent then
                                pcall(function()
                                    for _, conn in pairs(getconnections(child.OnClientEvent)) do
                                        pcall(function() conn:Disable() end)
                                    end
                                end)
                            end
                            BypassResults.acRemotes = BypassResults.acRemotes + 1
                            break
                        end
                    end
                end
            end
        end
        
        ScanAndBlock(ReplicatedStorage)
        pcall(function() ScanAndBlock(Workspace) end)
    end)
end

-- ============================================
-- LAYER 4: AC SCRIPT DISABLER
-- Disables client-side anticheat scripts
-- ============================================
local function DisableACScripts()
    pcall(function()
        local function ScanScripts(parent)
            for _, child in pairs(parent:GetDescendants()) do
                if child:IsA("LocalScript") then
                    local name = child.Name:lower()
                    local acScriptNames = {
                        "anticheat", "anti_cheat", "ac", "integrity",
                        "validation", "security", "detection", "monitor",
                        "verify", "checker", "bac", "guard",
                        "sentinel", "shield", "protect", "enforce"
                    }
                    for _, acName in ipairs(acScriptNames) do
                        if name:find(acName) then
                            pcall(function()
                                child.Disabled = true
                                BypassResults.acScripts = BypassResults.acScripts + 1
                            end)
                            break
                        end
                    end
                end
            end
        end
        
        pcall(function() ScanScripts(LocalPlayer.PlayerScripts) end)
        pcall(function() ScanScripts(game:GetService("StarterPlayer")) end)
        pcall(function() ScanScripts(ReplicatedStorage) end)
    end)
end

-- ============================================
-- LAYER 5: KICK PROTECTION
-- ============================================
local function ProtectFromKick()
    pcall(function()
        local kickNames = {"Kick", "kick"}
        for _, name in ipairs(kickNames) do
            local fn = LocalPlayer[name]
            if type(fn) == "function" then
                local oldKick
                oldKick = hookfunction(fn, newcclosure(function(self, ...)
                    if self == LocalPlayer then
                        warn("[ANNOMALY X] Blocked kick: " .. tostring((...)))
                        return
                    end
                    return oldKick(self, ...)
                end))
                BypassResults.kickBlocked = true
            end
        end
    end)
end

-- ============================================
-- LAYER 6: ERROR SUPPRESSION
-- ============================================
local function SuppressErrors()
    pcall(function()
        -- Block LogService.MessageOut
        if getconnections then
            for _, conn in pairs(getconnections(LogService.MessageOut)) do
                pcall(function()
                    hookfunction(conn.Function, newcclosure(function(...) end))
                    BypassResults.errorsBlocked = BypassResults.errorsBlocked + 1
                end)
            end
        end
    end)
end

-- ============================================
-- EXECUTE ALL BYPASS LAYERS (in order)
-- ============================================
print("[ANNOMALY X] Combat Arena: Executing multi-layer bypass...")

-- Phase 1: Bypassel techniques
BypassHandshakes()
task.wait(0.1)
BypassHookChecks()
task.wait(0.1)
BypassMemoryChecks()
task.wait(0.1)
BypassIntegrityChecks()
task.wait(0.1)
CleanSignatures()
task.wait(0.1)

-- Phase 2: AC-specific neutralization
NeutralizeACFunctions()
task.wait(0.1)
BlockACRemotes()
task.wait(0.1)
DisableACScripts()
task.wait(0.1)

-- Phase 3: Protection
ProtectFromKick()
task.wait(0.1)
SuppressErrors()

-- Wait for everything to settle
task.wait(0.5)

-- Print results
print("  ✅ BYPASS RESULTS:")
print("    Handshakes blocked: " .. BypassResults.handshakes)
print("    Hook checks bypassed: " .. BypassResults.hookChecks)
print("    Memory patches: " .. BypassResults.memoryPatches)
print("    Integrity bypasses: " .. BypassResults.integrityBypasses)
print("    Signatures cleaned: " .. BypassResults.signaturesCleaned)
print("    AC functions neutralized: " .. BypassResults.acFunctions)
print("    AC remotes blocked: " .. BypassResults.acRemotes)
print("    AC scripts disabled: " .. BypassResults.acScripts)
print("    Errors blocked: " .. BypassResults.errorsBlocked)
print("    Kick protected: " .. tostring(BypassResults.kickBlocked))

-- ============================================
-- PHASE 7: CONTINUOUS AC MONITOR
-- Re-scans periodically for new AC elements
-- ============================================
task.spawn(function()
    while task.wait(8) do
        pcall(function()
            -- Re-block any new AC remotes
            BlockACRemotes()
            
            -- Re-clean memory signatures
            if getgc then
                for _, obj in ipairs(getgc(true)) do
                    if type(obj) == "table" then
                        pcall(function()
                            if rawget(obj, "__acsignature") then
                                rawset(obj, "__acsignature", nil)
                            end
                            if rawget(obj, "__checksum") then
                                rawset(obj, "__checksum", nil)
                            end
                        end)
                    end
                end
            end
            
            -- Re-disable error connections
            pcall(function()
                for _, conn in ipairs(getconnections(ScriptContext.Error)) do
                    pcall(function() conn:Disable() end)
                end
            end)
        end)
    end
end)

-- ============================================
-- PHASE 8: SILENT AIM (SELECTIVE METHOD)
-- ONLY intercepts RemoteEvent:FireServer
-- NEVER touches Workspace:Raycast
-- ============================================

local CurrentCATarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, Camera}
    local origin = Camera.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, targetPartSetting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if targetPartSetting == "Random" then
        local validParts = {}
        for _, partName in ipairs(parts) do
            local part = character:FindFirstChild(partName)
            if part then table.insert(validParts, part) end
        end
        if #validParts > 0 then return validParts[math.random(1, #validParts)] end
    end
    return character:FindFirstChild(targetPartSetting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function GetClosestCATarget()
    Camera = Workspace.CurrentCamera
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local screenCenter = Camera.ViewportSize / 2
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local targetPart = GetTargetPart(character, Config.Silent.TargetPart)
        if not targetPart then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(targetPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
        if screenDist < closestDist then
            closestDist = screenDist
            closest = targetPart
        end
    end
    
    return closest
end

-- ============================================
-- SELECTIVE __NAMECALL HOOK
-- CRITICAL: Only intercepts RemoteEvent/RemoteFunction
-- NEVER intercepts Workspace methods
-- ============================================
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if checkcaller() then
        return oldNamecall(self, ...)
    end
    
    -- SAFETY CHECK: NEVER intercept Workspace methods
    -- This is what causes BAC-7198
    if self == Workspace or self == workspace then
        return oldNamecall(self, ...)
    end
    
    -- Only process when silent aim is active
    if not Config.Silent.Enabled or not Config.Silent.Active then
        return oldNamecall(self, ...)
    end
    
    if not CurrentCATarget or not CurrentCATarget.Parent then
        return oldNamecall(self, ...)
    end
    
    -- Hit chance check
    if math.random(1, 100) > Config.Silent.HitChance then
        return oldNamecall(self, ...)
    end
    
    -- INTERCEPT: RemoteEvent:FireServer (shooting remotes only)
    if method == "FireServer" and self:IsA("RemoteEvent") then
        local remoteName = self.Name:lower()
        
        local isShootRemote = false
        local shootKeywords = {
            "shoot", "fire", "bullet", "gun", "weapon", 
            "attack", "cast", "projectile", "damage",
            "swing", "slash", "strike", "combat"
        }
        for _, keyword in ipairs(shootKeywords) do
            if remoteName:find(keyword) then
                isShootRemote = true
                break
            end
        end
        
        -- Skip AC remotes
        local acKeywords = {
            "anticheat", "anti_cheat", "ac_", "integrity",
            "validation", "security", "detect", "report",
            "flag", "violation", "verify", "check", "monitor"
        }
        for _, keyword in ipairs(acKeywords) do
            if remoteName:find(keyword) then
                isShootRemote = false
                break
            end
        end
        
        if isShootRemote then
            for i, arg in ipairs(args) do
                if typeof(arg) == "Vector3" then
                    local mag = arg.Magnitude
                    if mag > 0.1 and mag < 5 then
                        local origin = Camera.CFrame.Position
                        args[i] = (CurrentCATarget.Position - origin).Unit * mag
                    end
                elseif typeof(arg) == "CFrame" then
                    args[i] = CFrame.new(arg.Position, CurrentCATarget.Position)
                elseif typeof(arg) == "Ray" then
                    local newDir = (CurrentCATarget.Position - arg.Origin).Unit * arg.Direction.Magnitude
                    args[i] = Ray.new(arg.Origin, newDir)
                elseif typeof(arg) == "table" then
                    pcall(function()
                        for key, value in pairs(arg) do
                            local keyLower = tostring(key):lower()
                            if typeof(value) == "Vector3" then
                                if keyLower:find("dir") or keyLower:find("direction") 
                                    or keyLower:find("look") or keyLower:find("aim") then
                                    local origin = Camera.CFrame.Position
                                    arg[key] = (CurrentCATarget.Position - origin).Unit
                                elseif keyLower:find("target") or keyLower:find("hit") 
                                    or keyLower:find("point") or keyLower:find("end") then
                                    arg[key] = CurrentCATarget.Position
                                end
                            elseif typeof(value) == "CFrame" then
                                if keyLower:find("aim") or keyLower:find("camera") 
                                    or keyLower:find("look") or keyLower:find("cf") then
                                    arg[key] = CFrame.new(value.Position, CurrentCATarget.Position)
                                end
                            elseif typeof(value) == "Instance" then
                                if keyLower:find("target") or keyLower:find("hit") 
                                    or keyLower:find("victim") or keyLower:find("enemy") then
                                    -- Replace target instance with our target's parent (character)
                                    if CurrentCATarget.Parent then
                                        arg[key] = CurrentCATarget
                                    end
                                end
                            end
                        end
                    end)
                end
            end
            return oldNamecall(self, unpack(args))
        end
    end
    
    -- INTERCEPT: RemoteFunction:InvokeServer (some games use this)
    if method == "InvokeServer" and self:IsA("RemoteFunction") then
        local remoteName = self.Name:lower()
        local isShootRemote = false
        local shootKeywords = {"shoot", "fire", "bullet", "gun", "weapon", "attack", "cast", "combat"}
        for _, keyword in ipairs(shootKeywords) do
            if remoteName:find(keyword) then
                isShootRemote = true
                break
            end
        end
        
        if isShootRemote then
            for i, arg in ipairs(args) do
                if typeof(arg) == "Vector3" then
                    local mag = arg.Magnitude
                    if mag > 0.1 and mag < 5 then
                        local origin = Camera.CFrame.Position
                        args[i] = (CurrentCATarget.Position - origin).Unit * mag
                    end
                elseif typeof(arg) == "CFrame" then
                    args[i] = CFrame.new(arg.Position, CurrentCATarget.Position)
                end
            end
            return oldNamecall(self, unpack(args))
        end
    end
    
    return oldNamecall(self, ...)
end))

-- ============================================
-- TARGET UPDATE LOOP
-- ============================================
local caTargetConnection = RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentCATarget = GetClosestCATarget()
    else
        CurrentCATarget = nil
    end
end)

-- ============================================
-- CLEANUP ON CHARACTER RESPAWN
-- ============================================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentCATarget = nil
    
    -- Re-apply bypasses after respawn
    task.wait(2)
    pcall(function()
        BypassHandshakes()
        BypassHookChecks()
        BypassMemoryChecks()
        BlockACRemotes()
        DisableACScripts()
    end)
end)

-- ============================================
-- SIGNAL: Module loaded
-- ============================================
getgenv().AX_CALoaded = true

print("  ✅ CA MODULE v2 - Multi-layer BAC-7198 bypass active")
print("  ✅ CA MODULE v2 - Bypassel techniques integrated")
print("  ✅ CA MODULE v2 - Selective __namecall (RemoteEvent only)")
print("  ✅ CA MODULE v2 - Workspace:Raycast UNTOUCHED")
print("  ✅ CA MODULE v2 - Continuous AC monitor running")
print("  ✅ CA MODULE v2 - Kick protection enabled")
