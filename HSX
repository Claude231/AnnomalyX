--[[
    ANNOMALY X - HyperShot Module (Frosted Studio)
    PlaceId: 17516596118
    
    Investigación aplicada:
    - El sistema de disparo de HyperShot es CLIENTE-SIDE con raycasts locales
    - Las armas usan tablas con: Spread, BaseSpread, MinCamRecoil, MaxCamRecoil,
      MinRotRecoil, MaxRotRecoil, MinTransRecoil, MaxTransRecoil, ScopeSpeed
    - Silent Aim funciona via Workspace:Raycast namecall hook
    - Personajes: R15 estándar (Head, HumanoidRootPart, UpperTorso, LowerTorso)
    - Teams: TeamDeathmatch usa player.Team estándar de Roblox
    - NO usa metamethod protección especial (hook directo funciona)
    - El raycast origin viene desde Camera.CFrame.Position (viewport ray)
    - Tiene anticheat básico: kick hook necesario
]]

-- ======= ESPERAR CONFIG PRINCIPAL =======
if not getgenv().AX_Config then
    local _t = tick()
    repeat task.wait(0.1) until getgenv().AX_Config or tick() - _t > 30
    if not getgenv().AX_Config then return end
end
local Config = getgenv().AX_Config

-- ======= FUNCIONES BASE =======
local hookfunction      = hookfunction      or replaceclosure
local hookmetamethod    = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller       = checkcaller       or function() return false end
local newcclosure       = newcclosure       or function(f) return f end
local mousemoverel      = mousemoverel      or function() end
local getconnections    = getconnections

if not hookfunction or not hookmetamethod or not getnamecallmethod then return end

-- ======= SERVICIOS =======
local Players          = game:GetService("Players")
local RunService       = game:GetService("RunService")
local Workspace        = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Camera           = Workspace.CurrentCamera
local LocalPlayer      = Players.LocalPlayer

-- ======= CONSTANTES HYPERSHOT =======
-- El raycast en HyperShot viene desde muy cerca de la cámara
-- Ángulo máximo seguro para no activar anti-cheat del servidor
local HS_MAX_ANGLE    = 25    -- grados, más permisivo que Rivals por ser menos competitivo
local HS_HITBOX_SCALE = 0.25  -- offset random en hitbox para parecer natural
local HS_MIN_INTERVAL = 0.05  -- mínimo entre shots modificados
local _lastShot       = 0

-- Partes de personaje en HyperShot (R15 estándar)
local HS_PARTS = {
    "Head",
    "UpperTorso",
    "LowerTorso",
    "HumanoidRootPart",
    "RightUpperArm",
    "LeftUpperArm"
}

-- ======= RAYCAST PARAMS CACHEADOS =======
local _visParams = RaycastParams.new()
_visParams.FilterType    = Enum.RaycastFilterType.Exclude
_visParams.IgnoreWater   = true

local function UpdateVisFilter()
    local char = LocalPlayer.Character
    local list  = {Camera}
    if char then table.insert(list, char) end
    _visParams.FilterDescendantsInstances = list
end
UpdateVisFilter()

-- ======= CACHE DE JUGADORES =======
local _cachedPlayers    = {}
local _lastPlayerCache  = 0
local function GetCachedPlayers()
    local now = tick()
    if now - _lastPlayerCache > 2 then
        _cachedPlayers   = Players:GetPlayers()
        _lastPlayerCache = now
    end
    return _cachedPlayers
end

-- ======= TEAM CHECK HYPERSHOT =======
-- HyperShot usa player.Team estándar de Roblox para TDM
local function IsHSTeammate(player)
    if not player or player == LocalPlayer then return false end
    local ok, result = pcall(function()
        return player.Team
            and LocalPlayer.Team
            and player.Team == LocalPlayer.Team
    end)
    return ok and result
end

local function ShouldSkip(player, teamCheck)
    if not player or player == LocalPlayer then return true end
    if teamCheck and IsHSTeammate(player) then return true end
    return false
end

-- ======= VISIBILIDAD =======
local function IsHSVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local dir    = part.Position - origin
    local dist   = dir.Magnitude
    if dist < 2 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.4), _visParams)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(part.Parent)
end

-- ======= SELECCIÓN DE PARTE =======
local _hsRandPart   = "Head"
local _hsRandSwitch = 0

local function GetHSPart(character, setting)
    if not character then return nil end
    if setting == "Random" then
        local now = tick()
        if now - _hsRandSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(HS_PARTS) do
                if character:FindFirstChild(n) then
                    table.insert(valid, n)
                end
            end
            if #valid > 0 then
                _hsRandPart = valid[math.random(#valid)]
            end
            _hsRandSwitch = now
        end
        return character:FindFirstChild(_hsRandPart)
            or character:FindFirstChild("Head")
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

-- ======= GUN MOD — ELIMINAR SPREAD Y RECOIL =======
-- HyperShot guarda config de armas en tablas de GC con campo "Spread"
-- Esto hace que los disparos sean perfectamente precisos cliente-side
local _gunModApplied = false
local function ApplyHSGunMod()
    if _gunModApplied or not getgc then return end
    pcall(function()
        local gc = getgc(true)
        local count = 0
        for _, v in next, gc do
            if typeof(v) == "table" and rawget(v, "Spread") ~= nil then
                pcall(function()
                    rawset(v, "Spread",         0)
                    rawset(v, "BaseSpread",      0)
                    rawset(v, "MinCamRecoil",    Vector3.new())
                    rawset(v, "MaxCamRecoil",    Vector3.new())
                    rawset(v, "MinRotRecoil",    Vector3.new())
                    rawset(v, "MaxRotRecoil",    Vector3.new())
                    rawset(v, "MinTransRecoil",  Vector3.new())
                    rawset(v, "MaxTransRecoil",  Vector3.new())
                    rawset(v, "ScopeSpeed",      100)
                end)
                count = count + 1
            end
        end
    end)
    _gunModApplied = true
end

-- Aplicar gun mod al inicio y cuando cambia arma
task.delay(3, function()
    ApplyHSGunMod()
    -- Re-aplicar cada vez que el jugador equipa un arma nueva
    if LocalPlayer.Character then
        LocalPlayer.Character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                task.wait(0.3)
                _gunModApplied = false
                ApplyHSGunMod()
            end
        end)
    end
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        _gunModApplied = false
        ApplyHSGunMod()
        char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                task.wait(0.3)
                _gunModApplied = false
                ApplyHSGunMod()
            end
        end)
    end)
end)

-- ======= SILENT TARGET =======
local CurrentTarget     = nil
local CurrentTargetPos  = nil
local CurrentTargetPart = nil
local _lastSilentUpdate = 0

local function UpdateSilentTarget()
    local now = tick()
    if now - _lastSilentUpdate < 0.05 then return end -- throttle 20fps
    _lastSilentUpdate = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    if not (Config.Silent.Enabled and Config.Silent.Active) then
        CurrentTarget, CurrentTargetPos, CurrentTargetPart = nil, nil, nil
        return
    end

    local bestDist = Config.FOV.Enabled and Config.FOV.Radius or 9e9
    local closest, bestPos, bestPart = nil, nil, nil
    local mouse = UserInputService:GetMouseLocation()

    for _, player in ipairs(GetCachedPlayers()) do
        if ShouldSkip(player, Config.Silent.TeamCheck) then continue end
        local char = player.Character
        if not char then continue end
        local hum  = char:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end

        local tp = GetHSPart(char, Config.Silent.TargetPart)
        if not tp then continue end
        if Config.Silent.VisibleCheck and not IsHSVisible(tp) then continue end

        -- Predicción de movimiento
        local predicted = tp.Position
        pcall(function()
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                local vel = tp.AssemblyLinearVelocity
                if vel and vel.Magnitude > 0.5 then
                    predicted = predicted + vel * Config.Aimbot.Prediction
                end
            end
        end)

        -- Verificar ángulo desde cámara (no pasar si está fuera del FOV angular)
        local camPos = Camera.CFrame.Position
        local look   = Camera.CFrame.LookVector
        local toT    = predicted - camPos
        local toTMag = toT.Magnitude
        if toTMag < 0.01 then continue end
        local cosA = look.X*(toT.X/toTMag)
                   + look.Y*(toT.Y/toTMag)
                   + look.Z*(toT.Z/toTMag)
        local angle = math.deg(math.acos(math.clamp(cosA, -1, 1)))
        if angle > HS_MAX_ANGLE then continue end

        local screen, onScreen = Camera:WorldToViewportPoint(predicted)
        if not onScreen then continue end
        local sd = (Vector2.new(screen.X, screen.Y) - mouse).Magnitude
        if sd < bestDist then
            bestDist  = sd
            closest   = player
            bestPos   = predicted
            bestPart  = tp
        end
    end

    CurrentTarget     = closest
    CurrentTargetPos  = bestPos
    CurrentTargetPart = bestPart
end

-- ======= AIMBOT =======
local _hsLocked      = nil
local _hsAimRand     = "Head"
local _hsAimSwitch   = 0

local function IsHSValid(player)
    if not player or not player.Parent or player == LocalPlayer then return false end
    if ShouldSkip(player, Config.Aimbot.TeamCheck) then return false end
    local c = player.Character
    if not c or c:FindFirstChildOfClass("ForceField") then return false end
    local h = c:FindFirstChildOfClass("Humanoid")
    return h and h.Health > 0
end

local function GetHSAimbotPart(char)
    if not char then return nil end
    local s = Config.Aimbot.TargetPart
    if s == "Random" then
        local now = tick()
        if now - _hsAimSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(HS_PARTS) do
                if char:FindFirstChild(n) then table.insert(valid, n) end
            end
            if #valid > 0 then _hsAimRand = valid[math.random(#valid)] end
            _hsAimSwitch = now
        end
        return char:FindFirstChild(_hsAimRand) or char:FindFirstChild("Head")
    end
    return char:FindFirstChild(s)
        or char:FindFirstChild("Head")
        or char:FindFirstChild("HumanoidRootPart")
end

local function GetHSAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    local fov    = Config.Aimbot.FOVRadius or 150
    local vp     = Camera.ViewportSize
    local center = Vector2.new(vp.X/2, vp.Y/2)
    local mouse  = UserInputService:GetMouseLocation()
    local ref    = Config.Aimbot.Method == "Aimbot" and center or mouse

    -- Aimlock: mantener target bloqueado
    if Config.Aimbot.Method == "Aimlock" and _hsLocked then
        if IsHSValid(_hsLocked) then
            local tp = GetHSAimbotPart(_hsLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsHSVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        _hsLocked = nil
    end

    local best, bestDist, bestPlayer = nil, fov, nil
    for _, player in ipairs(GetCachedPlayers()) do
        if not IsHSValid(player) then continue end
        local tp = GetHSAimbotPart(player.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsHSVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then
            bestDist   = d
            best       = tp
            bestPlayer = player
        end
    end
    if Config.Aimbot.Method == "Aimlock" and bestPlayer then
        _hsLocked = bestPlayer
    end
    return best
end

-- ======= ESP HYPERSHOT =======
-- ESP con health bar, outline y color según visibilidad (igual que Rivals)
local HSESP    = {}
local _lastESP = 0

local function CreateHSESP(player)
    if HSESP[player] then return end
    local e = {}

    e.Box         = Drawing.new("Square")
    e.Box.Thickness = 1  e.Box.Filled = false
    e.Box.Color   = Color3.fromRGB(255,255,255)  e.Box.Visible = false

    e.Outline     = Drawing.new("Square")
    e.Outline.Thickness = 3  e.Outline.Filled = false
    e.Outline.Color = Color3.fromRGB(0,0,0)
    e.Outline.Transparency = 0.5  e.Outline.Visible = false

    e.Name        = Drawing.new("Text")
    e.Name.Size   = 13  e.Name.Center = true  e.Name.Outline = true
    e.Name.Color  = Color3.fromRGB(255,255,255)  e.Name.Visible = false

    e.Distance    = Drawing.new("Text")
    e.Distance.Size = 12  e.Distance.Center = true  e.Distance.Outline = true
    e.Distance.Color = Color3.fromRGB(200,200,200)  e.Distance.Visible = false

    e.HealthBG    = Drawing.new("Square")
    e.HealthBG.Filled = true  e.HealthBG.Thickness = 1
    e.HealthBG.Color  = Color3.fromRGB(0,0,0)
    e.HealthBG.Transparency = 0.5  e.HealthBG.Visible = false

    e.HealthBar   = Drawing.new("Square")
    e.HealthBar.Filled = true  e.HealthBar.Thickness = 1
    e.HealthBar.Color  = Color3.fromRGB(0,255,0)  e.HealthBar.Visible = false

    HSESP[player] = e
end

local function HideHSESP(player)
    local e = HSESP[player]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function RemoveHSESP(player)
    local e = HSESP[player]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    HSESP[player] = nil
end

local function UpdateHSESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(HSESP) do HideHSESP(p) end
        return
    end
    local now = tick()
    if now - _lastESP < 0.08 then return end
    _lastESP = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    local active = {}
    for _, player in ipairs(GetCachedPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true

        local isTm = IsHSTeammate(player)
        if Config.ESP.TeamCheck and isTm then HideHSESP(player) continue end

        if not HSESP[player] then
            pcall(function() CreateHSESP(player) end)
        end
        local esp = HSESP[player]
        if not esp then continue end

        local char = player.Character
        local hum  = char and char:FindFirstChildOfClass("Humanoid")
        local root = char and (
            char:FindFirstChild("HumanoidRootPart")
            or char:FindFirstChild("UpperTorso")
            or char:FindFirstChild("Torso")
        )
        local head = char and char:FindFirstChild("Head")

        if not char or not hum or not root or hum.Health <= 0
        or char:FindFirstChildOfClass("ForceField") then
            HideHSESP(player) continue
        end

        local dist = (Camera.CFrame.Position - root.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideHSESP(player) continue end

        local sp, on = Camera:WorldToViewportPoint(root.Position)
        if not on then HideHSESP(player) continue end

        -- Calcular tamaño de caja desde head hasta pies
        local topSP   = head and select(1, Camera:WorldToViewportPoint(
            head.Position + Vector3.new(0, 0.6, 0)
        )) or sp
        local botSP   = select(1, Camera:WorldToViewportPoint(
            root.Position - Vector3.new(0, 3.2, 0)
        ))

        local height  = math.max(math.abs(topSP.Y - botSP.Y), 10)
        local width   = height * 0.5
        local minX    = sp.X - width/2
        local minY    = topSP.Y

        -- Color: azul=team, verde=visible, rojo=no visible
        local col = isTm
            and Color3.fromRGB(80, 150, 255)
            or (head and IsHSVisible(head)
                and Color3.fromRGB(50, 255, 50)
                or  Color3.fromRGB(255, 50, 50))

        if Config.ESP.Boxes then
            esp.Outline.Size     = Vector2.new(width+2, height+2)
            esp.Outline.Position = Vector2.new(minX-1, minY-1)
            esp.Outline.Visible  = true

            esp.Box.Size         = Vector2.new(width, height)
            esp.Box.Position     = Vector2.new(minX, minY)
            esp.Box.Color        = col
            esp.Box.Visible      = true
        else
            esp.Box.Visible     = false
            esp.Outline.Visible = false
        end

        if Config.ESP.Names then
            esp.Name.Text     = player.DisplayName or player.Name
            esp.Name.Position = Vector2.new(minX + width/2, minY - 16)
            esp.Name.Color    = col
            esp.Name.Visible  = true
        else
            esp.Name.Visible  = false
        end

        if Config.ESP.Distance then
            esp.Distance.Text     = math.floor(dist).."m"
            esp.Distance.Position = Vector2.new(minX + width/2, minY + height + 3)
            esp.Distance.Visible  = true
        else
            esp.Distance.Visible  = false
        end

        -- Barra de vida
        if Config.ESP.Boxes and hum then
            local pct = math.clamp(hum.Health / math.max(hum.MaxHealth, 1), 0, 1)
            local bh  = height * pct
            local hc  = pct > 0.5
                and Color3.fromRGB(math.floor(255*(1-pct)*2), 255, 0)
                or  Color3.fromRGB(255, math.floor(255*pct*2), 0)

            esp.HealthBG.Size     = Vector2.new(4, height)
            esp.HealthBG.Position = Vector2.new(minX - 7, minY)
            esp.HealthBG.Visible  = true

            esp.HealthBar.Size     = Vector2.new(4, bh)
            esp.HealthBar.Position = Vector2.new(minX - 7, minY + (height - bh))
            esp.HealthBar.Color    = hc
            esp.HealthBar.Visible  = true
        else
            esp.HealthBG.Visible  = false
            esp.HealthBar.Visible = false
        end
    end

    -- Limpiar jugadores que salieron
    for p in pairs(HSESP) do
        if not active[p] then
            if not p.Parent then RemoveHSESP(p)
            else HideHSESP(p) end
        end
    end
end

-- ======= AC BYPASS / ANTI-KICK =======
local function HSACBypass()
    -- Bloquear kick del anticheat del servidor
    if not getgenv()._AX_KickHooked then
        pcall(function()
            for _, name in ipairs({"Kick", "kick"}) do
                local fn = LocalPlayer[name]
                if typeof(fn) == "function" then
                    local old = fn
                    hookfunction(fn, newcclosure(function(self, ...)
                        if self == LocalPlayer then return end
                        return old(self, ...)
                    end))
                end
            end
            getgenv()._AX_KickHooked = true
        end)
    end
    -- Deshabilitar error handlers de ScriptContext
    pcall(function()
        local SC = game:GetService("ScriptContext")
        if getconnections then
            for _, c in ipairs(getconnections(SC.Error)) do
                pcall(function() c:Disable() end)
            end
        end
    end)
end
task.delay(2, HSACBypass)

-- ======= NAMECALL HOOK — SILENT AIM =======
-- HyperShot usa Workspace:Raycast para detección de impactos cliente-side
-- El hook redirige la dirección del ray hacia el target seleccionado
task.delay(5, function()
    -- Esperar a que el personaje esté listo
    if not LocalPlayer.Character then
        local t = tick()
        repeat task.wait(0.5) until LocalPlayer.Character or tick() - t > 15
    end

    local _inHook = false
    local oldNC
    oldNC = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        -- Guard anti-recursión y anti-checkcaller
        if _inHook or checkcaller() then return oldNC(self, ...) end

        local method = getnamecallmethod()

        -- Solo nos interesan raycasts de Workspace
        local isRaycast = method == "Raycast"
            or method == "FindPartOnRay"
            or method == "FindPartOnRayWithIgnoreList"
            or method == "FindPartOnRayWithWhitelist"

        if not isRaycast then return oldNC(self, ...) end

        -- Solo interceptar si es Workspace
        if self ~= Workspace and self ~= workspace then
            return oldNC(self, ...)
        end

        -- Solo si silent está activo y tenemos target
        if not (Config.Silent.Enabled and Config.Silent.Active) then
            return oldNC(self, ...)
        end
        if not CurrentTargetPos or not CurrentTargetPart then
            return oldNC(self, ...)
        end

        -- Hit chance
        if math.random(100) > Config.Silent.HitChance then
            return oldNC(self, ...)
        end

        -- Cooldown entre shots modificados
        local now = tick()
        if now - _lastShot < HS_MIN_INTERVAL then return oldNC(self, ...) end

        _inHook = true
        local args = {...}

        if method == "Raycast" then
            local origin    = args[1]
            local direction = args[2]
            if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                -- Verificar que el raycast viene desde cerca de la cámara
                -- (así filtramos raycasts de física o animaciones)
                local cp   = Camera.CFrame.Position
                local dist = (origin - cp).Magnitude
                if dist <= 12 then
                    local tp     = CurrentTargetPos
                    local toT    = tp - origin
                    local toTMag = toT.Magnitude
                    local dMag   = direction.Magnitude
                    if toTMag > 0 and dMag > 0 then
                        -- Verificar ángulo entre dirección real y dirección al target
                        local dirN = direction / dMag
                        local toTN = toT / toTMag
                        local dot  = dirN.X*toTN.X + dirN.Y*toTN.Y + dirN.Z*toTN.Z
                        local ang  = math.deg(math.acos(math.clamp(dot, -1, 1)))
                        if ang <= HS_MAX_ANGLE then
                            -- Añadir offset aleatorio natural
                            local size = CurrentTargetPart.Size
                            local off  = Vector3.new(
                                (math.random()-0.5) * size.X * HS_HITBOX_SCALE,
                                (math.random()-0.5) * size.Y * HS_HITBOX_SCALE,
                                (math.random()-0.5) * size.Z * HS_HITBOX_SCALE
                            )
                            local finalTarget = tp + off
                            local newDir = finalTarget - origin
                            local newMag = newDir.Magnitude
                            if newMag > 0 then
                                -- Mantener la misma magnitud del ray original
                                args[2] = (newDir / newMag) * dMag
                                _lastShot = now
                                _inHook   = false
                                return oldNC(self, unpack(args))
                            end
                        end
                    end
                end
            end

        elseif method == "FindPartOnRay"
            or method == "FindPartOnRayWithIgnoreList"
            or method == "FindPartOnRayWithWhitelist"
        then
            local ray = args[1]
            if typeof(ray) == "Ray" then
                local origin    = ray.Origin
                local direction = ray.Direction
                local cp        = Camera.CFrame.Position
                local dist      = (origin - cp).Magnitude
                if dist <= 12 then
                    local tp     = CurrentTargetPos
                    local toT    = tp - origin
                    local toTMag = toT.Magnitude
                    local dMag   = direction.Magnitude
                    if toTMag > 0 and dMag > 0 then
                        local dirN = direction / dMag
                        local toTN = toT / toTMag
                        local dot  = dirN.X*toTN.X + dirN.Y*toTN.Y + dirN.Z*toTN.Z
                        local ang  = math.deg(math.acos(math.clamp(dot, -1, 1)))
                        if ang <= HS_MAX_ANGLE then
                            local size = CurrentTargetPart.Size
                            local off  = Vector3.new(
                                (math.random()-0.5) * size.X * HS_HITBOX_SCALE,
                                (math.random()-0.5) * size.Y * HS_HITBOX_SCALE,
                                (math.random()-0.5) * size.Z * HS_HITBOX_SCALE
                            )
                            local ft   = tp + off
                            local nDir = ft - origin
                            local nMag = nDir.Magnitude
                            if nMag > 0 then
                                args[1] = Ray.new(origin, (nDir/nMag) * dMag)
                                _lastShot = now
                                _inHook   = false
                                return oldNC(self, unpack(args))
                            end
                        end
                    end
                end
            end
        end

        _inHook = false
        return oldNC(self, ...)
    end))
end)

-- ======= LOOP PRINCIPAL =======
task.delay(3, function()
    RunService.RenderStepped:Connect(function()
        Camera = Workspace.CurrentCamera

        -- Silent target update (20fps)
        UpdateSilentTarget()

        -- Aimbot
        if Config.Aimbot.Enabled and Config.Aimbot.Active then
            local tp = GetHSAimbotTarget()
            if tp then
                local pos = tp.Position
                pcall(function()
                    if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                        local vel = tp.AssemblyLinearVelocity
                        if vel and vel.Magnitude > 0.5 then
                            pos = pos + vel * Config.Aimbot.Prediction
                        end
                    end
                end)
                local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
                if Config.Aimbot.Method == "Aimbot" then
                    local cur = Camera.CFrame
                    local tgt = CFrame.lookAt(cur.Position, pos)
                    Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1/sm)
                elseif Config.Aimbot.Method == "Aimlock" then
                    local sp, on = Camera:WorldToViewportPoint(pos)
                    if on then
                        local mp = UserInputService:GetMouseLocation()
                        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                        local d = math.sqrt(dx*dx + dy*dy)
                        if d > 1 then
                            local spd = math.clamp(1/sm, 0.05, 0.8)
                            local mx  = math.clamp(dx*spd, -150, 150)
                            local my  = math.clamp(dy*spd, -150, 150)
                            if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then
                                mousemoverel(mx, my)
                            end
                        end
                    end
                end
            else
                if not Config.Aimbot.Active then _hsLocked = nil end
            end
        else
            if not Config.Aimbot.Active then _hsLocked = nil end
        end
    end)
end)

task.delay(4, function()
    RunService.Heartbeat:Connect(function()
        UpdateHSESP()
    end)
end)

-- ======= EVENTOS DE JUGADORES =======
task.delay(2, function()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            pcall(function() CreateHSESP(p) end)
        end
    end
end)

Players.PlayerAdded:Connect(function(p)
    task.delay(2, function()
        pcall(function() CreateHSESP(p) end)
    end)
end)

Players.PlayerRemoving:Connect(function(p)
    if _hsLocked == p then _hsLocked = nil end
    RemoveHSESP(p)
    -- Limpiar cache
    for i, v in ipairs(_cachedPlayers) do
        if v == p then table.remove(_cachedPlayers, i) break end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    Camera           = Workspace.CurrentCamera
    CurrentTarget    = nil
    CurrentTargetPos  = nil
    CurrentTargetPart = nil
    _hsLocked        = nil
    _gunModApplied   = false
    UpdateVisFilter()
    task.wait(0.5)
    ApplyHSGunMod()
    task.wait(3)
    pcall(HSACBypass)
end)

-- ======= FLAGS PARA SCRIPT PRINCIPAL =======
-- Le dicen al script base que este módulo maneja todo
getgenv().AX_HSLoaded          = true
getgenv().AX_HSHandlesAimbot   = true
getgenv().AX_HSHandlesESP      = true
getgenv().AX_HSHandlesSilent   = true

-- Registrar en el sistema de ModuleHandles del script principal
getgenv().AX_RivalsHandlesAimbot = true  -- reutilizar flags existentes
getgenv().AX_RivalsHandlesESP    = true

task.delay(2, function()
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title   = "⚡ AX — HyperShot",
            Text    = "Módulo cargado | Silent+ESP+Aimbot+GunMod ✅",
            Duration = 5
        })
    end)
end)
