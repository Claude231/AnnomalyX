--[[
    ANNOMALY X - HSX Module v2.0
    Fix REAL: Hook __index en Mouse.Hit/Mouse.Target
    Hypershot usa Mouse.Hit para la direccion de disparos
    Metodo descubierto analizando scripts universales que funcionan
]]

if not getgenv().AX_Config then
    local t = tick()
    repeat task.wait() until getgenv().AX_Config or tick()-t > 30
end
local Config = getgenv().AX_Config

local hookmetamethod    = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller       = checkcaller or function() return false end
local newcclosure       = newcclosure or function(f) return f end
local mousemoverel      = mousemoverel or function() end

if not hookmetamethod or not getnamecallmethod then return end

local Players          = game:GetService("Players")
local RunService       = game:GetService("RunService")
local Workspace        = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Camera           = Workspace.CurrentCamera
local LocalPlayer      = Players.LocalPlayer
local Mouse            = LocalPlayer:GetMouse()

local MAX_ANGLE  = 45
local MIN_INTERV = 0.05
local _lastShot  = 0

-- ===== RAYCASTPARAMS CACHEADOS =====
local _visParams = RaycastParams.new()
_visParams.FilterType = Enum.RaycastFilterType.Exclude
_visParams.IgnoreWater = true

local function UpdateFilter()
    local char = LocalPlayer.Character
    local t = {Camera}
    if char then table.insert(t, char) end
    _visParams.FilterDescendantsInstances = t
end
UpdateFilter()

-- ===== CACHE DE JUGADORES =====
local _cachedPlayers = {}
local _lastCache     = 0
local function GetCachedPlayers()
    local t = tick()
    if t - _lastCache > 2 then
        _cachedPlayers = Players:GetPlayers()
        _lastCache = t
    end
    return _cachedPlayers
end

-- ===== TEAM CHECK =====
local function IsTeammate(p)
    if not p or p == LocalPlayer then return false end
    local ok, r = pcall(function()
        return p.Team and LocalPlayer.Team and p.Team == LocalPlayer.Team
    end)
    return ok and r
end

-- ===== VISIBILITY =====
local function IsVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local dir    = part.Position - origin
    local dist   = dir.Magnitude
    if dist < 2 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), _visParams)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(part.Parent)
end

-- ===== TARGET PARTS =====
-- Hypershot usa partes estandar de Roblox
local HS_PARTS = {"Head", "HumanoidRootPart", "UpperTorso"}

local _silentRandom = "Head"
local _silentSwitch = 0

local function GetHSTargetPart(char, setting)
    if not char then return nil end
    if setting == "Random" then
        if tick() - _silentSwitch > 0.5 then
            local valid = {}
            for _, n in ipairs(HS_PARTS) do
                if char:FindFirstChild(n) then table.insert(valid, n) end
            end
            if #valid > 0 then _silentRandom = valid[math.random(#valid)] end
            _silentSwitch = tick()
        end
        return char:FindFirstChild(_silentRandom) or char:FindFirstChild("Head")
    end
    return char:FindFirstChild(setting)
        or char:FindFirstChild("Head")
        or char:FindFirstChild("HumanoidRootPart")
end

-- ===== SILENT TARGET =====
-- _curTarget: BasePart para raycast hook
-- _curTargetCF: CFrame para Mouse.Hit hook
local _curTarget     = nil
local _curTargetCF   = nil
local _lastTargetUpd = 0

local function UpdateTarget()
    local now = tick()
    if now - _lastTargetUpd < 0.05 then return end
    _lastTargetUpd = now

    Camera = Workspace.CurrentCamera
    if not Camera then return end

    if not (Config.Silent.Enabled and Config.Silent.Active) then
        _curTarget   = nil
        _curTargetCF = nil
        return
    end

    local bestDist = Config.FOV.Enabled and Config.FOV.Radius or 9e9
    local bestPart = nil
    local mouse    = UserInputService:GetMouseLocation()

    for _, plr in ipairs(GetCachedPlayers()) do
        if plr == LocalPlayer then continue end
        if Config.Silent.TeamCheck and IsTeammate(plr) then continue end
        local char = plr.Character if not char then continue end
        local hum  = char:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end

        local tp = GetHSTargetPart(char, Config.Silent.TargetPart)
        if not tp then continue end
        if Config.Silent.VisibleCheck and not IsVisible(tp) then continue end

        -- Prediccion de movimiento
        local predicted = tp.Position
        pcall(function()
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                local vel = tp.AssemblyLinearVelocity
                if vel and vel.Magnitude > 0.5 then
                    predicted = predicted + vel * Config.Aimbot.Prediction
                end
            end
        end)

        local sp, on = Camera:WorldToViewportPoint(predicted)
        if not on then continue end
        local sd = (Vector2.new(sp.X, sp.Y) - mouse).Magnitude
        if sd < bestDist then
            bestDist = sd
            bestPart = tp
        end
    end

    _curTarget = bestPart
    -- CFrame apuntando al target, con prediccion incluida
    -- Esto es lo que devuelve el hook de Mouse.Hit
    if bestPart then
        local predicted = bestPart.Position
        pcall(function()
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                local vel = bestPart.AssemblyLinearVelocity
                if vel and vel.Magnitude > 0.5 then
                    predicted = predicted + vel * Config.Aimbot.Prediction
                end
            end
        end)
        _curTargetCF = CFrame.new(predicted)
    else
        _curTargetCF = nil
    end
end

-- ===== AIMBOT =====
local _aimbotLocked = nil
local _aimbotRandom = "Head"
local _aimbotSwitch = 0

local function IsPlayerValid(p)
    if not p or not p.Parent or p == LocalPlayer then return false end
    if Config.Aimbot.TeamCheck and IsTeammate(p) then return false end
    local c = p.Character
    if not c or c:FindFirstChildOfClass("ForceField") then return false end
    local h = c:FindFirstChildOfClass("Humanoid")
    return h and h.Health > 0
end

local function GetAimbotPart(char)
    if not char then return nil end
    local s = Config.Aimbot.TargetPart
    if s == "Random" then
        local t = tick()
        if t - _aimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(HS_PARTS) do
                if char:FindFirstChild(n) then table.insert(valid, n) end
            end
            if #valid > 0 then _aimbotRandom = valid[math.random(#valid)] end
            _aimbotSwitch = t
        end
        return char:FindFirstChild(_aimbotRandom) or char:FindFirstChild("Head")
    end
    return char:FindFirstChild(s)
        or char:FindFirstChild("Head")
        or char:FindFirstChild("HumanoidRootPart")
end

local function GetAimbotTarget()
    Camera = Workspace.CurrentCamera if not Camera then return nil end
    local fov    = Config.Aimbot.FOVRadius or 150
    local vp     = Camera.ViewportSize
    local center = Vector2.new(vp.X/2, vp.Y/2)
    local mp     = UserInputService:GetMouseLocation()
    local ref    = Config.Aimbot.Method == "Aimbot" and center or mp

    if Config.Aimbot.Method == "Aimlock" and _aimbotLocked then
        if IsPlayerValid(_aimbotLocked) then
            local tp = GetAimbotPart(_aimbotLocked.Character)
            if tp and (not Config.Aimbot.VisibleCheck or IsVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        _aimbotLocked = nil
    end

    local best, bestD, bestP = nil, fov, nil
    for _, plr in ipairs(GetCachedPlayers()) do
        if not IsPlayerValid(plr) then continue end
        local tp = GetAimbotPart(plr.Character)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestD then bestD = d best = tp bestP = plr end
    end
    if Config.Aimbot.Method == "Aimlock" and bestP then _aimbotLocked = bestP end
    return best
end

-- ===== HITBOX EXPANDER =====
-- Hypershot usa HumanoidRootPart y Head estandar
local _originalSizes         = {}
local _originalTransparencies = {}
local _originalCanCollide    = {}
local _originalMassless      = {}
local _expandedPlayers       = {}
local _lastHitboxUpdate      = 0

local function SaveHitboxProps(player, partName, part)
    if not _originalSizes[player]          then _originalSizes[player]          = {} end
    if not _originalTransparencies[player] then _originalTransparencies[player] = {} end
    if not _originalCanCollide[player]     then _originalCanCollide[player]     = {} end
    if not _originalMassless[player]       then _originalMassless[player]       = {} end
    if not _originalSizes[player][partName] then
        _originalSizes[player][partName]          = part.Size
        _originalTransparencies[player][partName] = part.Transparency
        _originalCanCollide[player][partName]     = part.CanCollide
        _originalMassless[player][partName]       = part.Massless
    end
end

local function RestoreHitbox(player)
    if not player then return end
    local ok, char = pcall(function() return player.Character end)
    if not ok or not char then return end
    if _originalSizes[player] then
        for pn, os in pairs(_originalSizes[player]) do
            local p = char:FindFirstChild(pn)
            if p then pcall(function()
                p.Size         = os
                p.Transparency = _originalTransparencies[player][pn]
                p.Massless     = _originalMassless[player][pn]
                p.CanCollide   = _originalCanCollide[player][pn]
            end) end
        end
    end
    _expandedPlayers[player] = nil
end

local function CleanupAllHitboxes()
    for player in pairs(_expandedPlayers) do RestoreHitbox(player) end
    _originalSizes={} _originalTransparencies={}
    _originalCanCollide={} _originalMassless={}
    _expandedPlayers={}
end

local function ExpandHitbox(player, size)
    local char = player.Character if not char then return end
    -- Partes a expandir en Hypershot
    local parts = {"Head", "HumanoidRootPart", "UpperTorso"}
    for _, pn in ipairs(parts) do
        local part = char:FindFirstChild(pn)
        if part and part:IsA("BasePart") then
            SaveHitboxProps(player, pn, part)
            pcall(function()
                part.CanCollide   = false
                part.Massless     = true
                part.Size         = Vector3.new(size, size, size)
                part.Transparency = Config.Hitbox.Transparency
            end)
        end
    end
    _expandedPlayers[player] = true
end

local function UpdateHitboxes()
    if not Config.Hitbox.Enabled or not Config.Hitbox.Active then
        CleanupAllHitboxes() return
    end
    local t = tick()
    if t - _lastHitboxUpdate < 0.05 then return end
    _lastHitboxUpdate = t

    local mouse    = UserInputService:GetMouseLocation()
    local shouldEx = {}
    local fr       = Config.Hitbox.FOVEnabled and Config.Hitbox.FOVRadius or Config.FOV.Radius

    for _, plr in ipairs(GetCachedPlayers()) do
        if plr == LocalPlayer or not plr.Parent then continue end
        if Config.Hitbox.TeamCheck and IsTeammate(plr) then continue end
        local c = plr.Character if not c then continue end
        local h = c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 or c:FindFirstChildOfClass("ForceField") then continue end

        local size = Config.Hitbox.MaxSize

        if Config.Hitbox.Method == "DHE (Dynamic)" then
            local cp = c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Head")
            if not cp then continue end
            local sp, on = Camera:WorldToViewportPoint(cp.Position)
            if not on then continue end
            local sd = (mouse - Vector2.new(sp.X, sp.Y)).Magnitude
            if sd > fr then continue end
            local pf = 1 - (sd/fr)
            size = 1 + (Config.Hitbox.MaxSize - 1) * pf
        end

        shouldEx[plr] = size
    end

    for plr in pairs(_expandedPlayers) do
        if not shouldEx[plr] then RestoreHitbox(plr) end
    end
    for plr, sz in pairs(shouldEx) do
        ExpandHitbox(plr, sz)
    end
end

-- ===== ESP =====
local HSESP    = {}
local _lastESP = 0

local function CreateESP(p)
    if HSESP[p] then return end
    local e = {}
    e.Box      = Drawing.new("Square")
    e.Box.Thickness=1 e.Box.Filled=false
    e.Box.Color=Color3.fromRGB(255,255,255) e.Box.Visible=false

    e.Outline   = Drawing.new("Square")
    e.Outline.Thickness=3 e.Outline.Filled=false
    e.Outline.Color=Color3.fromRGB(0,0,0)
    e.Outline.Transparency=0.5 e.Outline.Visible=false

    e.Name      = Drawing.new("Text")
    e.Name.Size=13 e.Name.Center=true e.Name.Outline=true
    e.Name.Color=Color3.fromRGB(255,255,255) e.Name.Visible=false

    e.Distance  = Drawing.new("Text")
    e.Distance.Size=12 e.Distance.Center=true e.Distance.Outline=true
    e.Distance.Color=Color3.fromRGB(200,200,200) e.Distance.Visible=false

    e.HealthBG  = Drawing.new("Square")
    e.HealthBG.Thickness=1 e.HealthBG.Filled=true
    e.HealthBG.Color=Color3.fromRGB(0,0,0)
    e.HealthBG.Transparency=0.5 e.HealthBG.Visible=false

    e.HealthBar = Drawing.new("Square")
    e.HealthBar.Thickness=1 e.HealthBar.Filled=true
    e.HealthBar.Color=Color3.fromRGB(0,255,0) e.HealthBar.Visible=false

    HSESP[p] = e
end

local function RemoveESP(p)
    local e = HSESP[p] if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    HSESP[p] = nil
end

local function HideESP(p)
    local e = HSESP[p] if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function UpdateESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(HSESP) do HideESP(p) end return
    end
    local now = tick()
    if now - _lastESP < 0.08 then return end
    _lastESP = now
    Camera = Workspace.CurrentCamera if not Camera then return end

    local active = {}
    for _, plr in ipairs(GetCachedPlayers()) do
        if plr == LocalPlayer then continue end
        active[plr] = true

        local isTm = IsTeammate(plr)
        if Config.ESP.TeamCheck and isTm then HideESP(plr) continue end

        if not HSESP[plr] then pcall(function() CreateESP(plr) end) end
        local esp = HSESP[plr] if not esp then continue end

        local c    = plr.Character
        local h    = c and c:FindFirstChildOfClass("Humanoid")
        local rp   = c and (c:FindFirstChild("HumanoidRootPart")
                       or c:FindFirstChild("UpperTorso")
                       or c:FindFirstChild("Torso"))
        local head = c and c:FindFirstChild("Head")

        if not c or not h or not rp or h.Health <= 0
            or c:FindFirstChildOfClass("ForceField") then
            HideESP(plr) continue
        end

        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideESP(plr) continue end

        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideESP(plr) continue end

        local hSP = head
            and select(1, Camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0)))
            or sp
        local fSP = select(1, Camera:WorldToViewportPoint(rp.Position - Vector3.new(0,3,0)))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width  = height / 2
        local minX   = sp.X - width/2
        local minY   = hSP.Y

        local col
        if isTm then
            col = Color3.fromRGB(80,150,255)
        else
            local vis = head and IsVisible(head) or false
            col = vis and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,50,50)
        end

        if Config.ESP.Boxes then
            esp.Outline.Size     = Vector2.new(width+2, height+2)
            esp.Outline.Position = Vector2.new(minX-1, minY-1)
            esp.Outline.Visible  = true
            esp.Box.Size         = Vector2.new(width, height)
            esp.Box.Position     = Vector2.new(minX, minY)
            esp.Box.Color        = col
            esp.Box.Visible      = true
        else
            esp.Box.Visible     = false
            esp.Outline.Visible = false
        end

        if Config.ESP.Names then
            esp.Name.Text     = plr.DisplayName or plr.Name
            esp.Name.Position = Vector2.new(minX+width/2, minY-16)
            esp.Name.Color    = col
            esp.Name.Visible  = true
        else esp.Name.Visible = false end

        if Config.ESP.Distance then
            esp.Distance.Text     = math.floor(dist).."m"
            esp.Distance.Position = Vector2.new(minX+width/2, minY+height+2)
            esp.Distance.Visible  = true
        else esp.Distance.Visible = false end

        if Config.ESP.Boxes and h then
            local pct = math.clamp(h.Health/math.max(h.MaxHealth,1), 0, 1)
            local bh  = height * pct
            local hc  = pct > 0.5
                and Color3.fromRGB(math.floor(255*(1-pct)*2), 255, 0)
                or  Color3.fromRGB(255, math.floor(255*pct*2), 0)
            esp.HealthBG.Size      = Vector2.new(3, height)
            esp.HealthBG.Position  = Vector2.new(minX-6, minY)
            esp.HealthBG.Visible   = true
            esp.HealthBar.Size     = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX-6, minY+(height-bh))
            esp.HealthBar.Color    = hc
            esp.HealthBar.Visible  = true
        else
            esp.HealthBG.Visible  = false
            esp.HealthBar.Visible = false
        end
    end

    for p in pairs(HSESP) do
        if not active[p] then
            if not p.Parent then RemoveESP(p) else HideESP(p) end
        end
    end
end

-- ===== HOOK 1: __namecall — Raycast / FindPartOnRay =====
-- Para juegos que usan Workspace:Raycast() para detectar impactos
task.delay(2, function()
    if not LocalPlayer.Character then
        local t = tick()
        repeat task.wait(0.5) until LocalPlayer.Character or tick()-t > 15
    end

    local _inHook = false
    local oldNC
    oldNC = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        if _inHook or checkcaller() then return oldNC(self, ...) end

        local method = getnamecallmethod()
        local isRaycast = method == "Raycast"
            or method == "FindPartOnRay"
            or method == "FindPartOnRayWithIgnoreList"
            or method == "FindPartOnRayWithWhitelist"

        -- Early exit sin activar guard
        if not isRaycast then return oldNC(self, ...) end
        if not (Config.Silent.Enabled and Config.Silent.Active
            and _curTarget and _curTarget.Parent) then
            return oldNC(self, ...)
        end
        if math.random(100) > Config.Silent.HitChance then return oldNC(self, ...) end
        if tick() - _lastShot < MIN_INTERV then return oldNC(self, ...) end

        -- Activar guard
        _inHook = true
        local args = {...}
        local targetPos = _curTarget.Position

        if self == Workspace or self == workspace then
            if method == "Raycast" then
                local o, d = args[1], args[2]
                if typeof(o) == "Vector3" and typeof(d) == "Vector3" then
                    local tx,ty,tz = targetPos.X-o.X, targetPos.Y-o.Y, targetPos.Z-o.Z
                    local tM = math.sqrt(tx*tx+ty*ty+tz*tz)
                    local dM = math.sqrt(d.X*d.X+d.Y*d.Y+d.Z*d.Z)
                    if tM > 0 and dM > 0 then
                        local dot = (d.X/dM)*(tx/tM)+(d.Y/dM)*(ty/tM)+(d.Z/dM)*(tz/tM)
                        if math.deg(math.acos(math.clamp(dot,-1,1))) <= MAX_ANGLE then
                            args[2] = Vector3.new(tx/tM*dM, ty/tM*dM, tz/tM*dM)
                            _lastShot = tick()
                            _inHook = false
                            return oldNC(self, unpack(args))
                        end
                    end
                end

            elseif method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList"
                or method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local o, d = ray.Origin, ray.Direction
                    local tx,ty,tz = targetPos.X-o.X, targetPos.Y-o.Y, targetPos.Z-o.Z
                    local tM = math.sqrt(tx*tx+ty*ty+tz*tz)
                    local dM = math.sqrt(d.X*d.X+d.Y*d.Y+d.Z*d.Z)
                    if tM > 0 and dM > 0 then
                        local dot = (d.X/dM)*(tx/tM)+(d.Y/dM)*(ty/tM)+(d.Z/dM)*(tz/tM)
                        if math.deg(math.acos(math.clamp(dot,-1,1))) <= MAX_ANGLE then
                            args[1] = Ray.new(o, Vector3.new(tx/tM*dM,ty/tM*dM,tz/tM*dM))
                            _lastShot = tick()
                            _inHook = false
                            return oldNC(self, unpack(args))
                        end
                    end
                end
            end
        end

        _inHook = false
        return oldNC(self, ...)
    end))
end)

-- ===== HOOK 2: __index — Mouse.Hit / Mouse.Target =====
-- ESTE ES EL HOOK CRITICO para Hypershot
-- Hypershot lee Mouse.Hit para saber donde apunta el jugador
-- Al interceptar Mouse.Hit devolvemos CFrame apuntando al target
-- Esto es lo que hace funcionar el Silent Aim en este juego
task.delay(2, function()
    if not LocalPlayer.Character then
        local t = tick()
        repeat task.wait(0.5) until LocalPlayer.Character or tick()-t > 15
    end

    local oldIndex
    oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, index)
        -- Solo interceptar Mouse.Hit y Mouse.Target
        if self == Mouse and (index == "Hit" or index == "Target") then
            if Config.Silent.Enabled and Config.Silent.Active
                and _curTargetCF and not checkcaller() then
                -- Hit chance
                if math.random(100) <= Config.Silent.HitChance then
                    if index == "Hit" then
                        -- Mouse.Hit: devolver CFrame en posicion del target
                        return _curTargetCF
                    elseif index == "Target" then
                        -- Mouse.Target: devolver la BasePart del target
                        return _curTarget
                    end
                end
            end
        end
        return oldIndex(self, index)
    end))
end)

-- ===== LOOPS =====
task.delay(2, function()
    RunService.RenderStepped:Connect(function()
        Camera = Workspace.CurrentCamera

        -- Actualizar target (throttled a 20fps)
        UpdateTarget()

        -- Aimbot
        if Config.Aimbot.Enabled and Config.Aimbot.Active then
            local t = GetAimbotTarget()
            if t then
                local pos = t.Position
                pcall(function()
                    if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                        local v = t.AssemblyLinearVelocity
                        if v and v.Magnitude > 0.5 then
                            pos = pos + v * Config.Aimbot.Prediction
                        end
                    end
                end)
                local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
                if Config.Aimbot.Method == "Aimbot" then
                    local cur = Camera.CFrame
                    local tgt = CFrame.lookAt(cur.Position, pos)
                    Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1/sm)
                else
                    local sp, on = Camera:WorldToViewportPoint(pos)
                    if on then
                        local mp = UserInputService:GetMouseLocation()
                        local dx, dy = sp.X-mp.X, sp.Y-mp.Y
                        local d = math.sqrt(dx*dx+dy*dy)
                        if d > 1 then
                            local spd = math.clamp(1/sm, 0.05, 0.8)
                            local mx  = math.clamp(dx*spd,-150,150)
                            local my  = math.clamp(dy*spd,-150,150)
                            if math.abs(mx)>0.3 or math.abs(my)>0.3 then
                                mousemoverel(mx,my)
                            end
                        end
                    end
                end
            else
                if not Config.Aimbot.Active then _aimbotLocked = nil end
            end
        else
            if not Config.Aimbot.Active then _aimbotLocked = nil end
        end
    end)
end)

task.delay(3, function()
    RunService.Heartbeat:Connect(function()
        UpdateESP()
        UpdateHitboxes()
    end)
end)

-- ===== FLAGS =====
getgenv().AX_HyperShotLoaded        = true
getgenv().AX_HyperShotHandlesAimbot  = true
getgenv().AX_HyperShotHandlesESP     = true
getgenv().AX_HyperShotHandlesSilent  = true

-- ===== INIT JUGADORES =====
task.delay(1, function()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then pcall(function() CreateESP(p) end) end
    end
end)

Players.PlayerAdded:Connect(function(p)
    task.delay(2, function() pcall(function() CreateESP(p) end) end)
end)

Players.PlayerRemoving:Connect(function(p)
    if _aimbotLocked == p then _aimbotLocked = nil end
    RemoveESP(p)
    RestoreHitbox(p)
    _originalSizes[p]=nil _originalTransparencies[p]=nil
    _originalCanCollide[p]=nil _originalMassless[p]=nil
    for i,v in ipairs(_cachedPlayers) do
        if v == p then table.remove(_cachedPlayers,i) break end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera        = Workspace.CurrentCamera
    _curTarget    = nil
    _curTargetCF  = nil
    _aimbotLocked = nil
    CleanupAllHitboxes()
    UpdateFilter()
end)
