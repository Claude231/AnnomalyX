--[[
    ANNOMALY X - HyperShot Module v1.0
    Módulo específico para HyperShot (Frosted Studio)
    Silent Aim + Aimbot + ESP con detección de personajes custom
]]

if not getgenv().AX_Config then
    local t = tick()
    repeat task.wait() until getgenv().AX_Config or tick() - t > 30
end
local Config = getgenv().AX_Config

local hookfunction      = hookfunction or replaceclosure or detour_function
local hookmetamethod    = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller       = checkcaller or function() return false end
local getconnections    = getconnections
local mousemoverel      = mousemoverel or function() end
local newcclosure       = newcclosure or function(f) return f end

if not hookfunction or not hookmetamethod or not getnamecallmethod then return end

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local Workspace         = game:GetService("Workspace")
local UserInputService  = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera            = Workspace.CurrentCamera
local LocalPlayer       = Players.LocalPlayer

local MAX_SILENT_ANGLE_DEG = 20
local HITBOX_OFFSET_SCALE  = 0.25
local MIN_SHOT_INTERVAL    = 0.05
local _lastShotModified    = 0

-- RaycastParams cacheados
local _visParams = RaycastParams.new()
_visParams.FilterType = Enum.RaycastFilterType.Exclude
_visParams.IgnoreWater = true

local function UpdateVisFilter()
    local char = LocalPlayer.Character
    local t = {Camera}
    if char then table.insert(t, char) end
    _visParams.FilterDescendantsInstances = t
end
UpdateVisFilter()

-- Cache de jugadores
local _cachedPlayers   = {}
local _lastPlayerCache = 0
local function GetCachedPlayers()
    local t = tick()
    if t - _lastPlayerCache > 2 then
        _cachedPlayers = Players:GetPlayers()
        _lastPlayerCache = t
    end
    return _cachedPlayers
end

-- ================== HYPERSHOT CHARACTER DETECTION ==================
-- HyperShot usa una estructura de personajes diferente
-- Los personajes pueden estar en Workspace directamente o en carpetas específicas

local function FindHyperShotCharactersFolder()
    -- Buscar carpetas comunes donde HyperShot almacena personajes
    for _, name in ipairs({"Characters", "PlayerCharacters", "GameCharacters", "Chars"}) do
        local folder = Workspace:FindFirstChild(name)
        if folder then return folder end
    end
    return nil
end

local function GetHyperShotCharacter(player)
    if not player then return nil end
    
    -- Método 1: Character estándar
    local char = player.Character
    if char and char.Parent and char:FindFirstChildOfClass("Humanoid") then
        return char
    end
    
    -- Método 2: Buscar en carpeta de personajes del juego
    local charsFolder = FindHyperShotCharactersFolder()
    if charsFolder then
        for _, child in ipairs(charsFolder:GetChildren()) do
            if child.Name == player.Name or child.Name == tostring(player.UserId) then
                if child:FindFirstChildOfClass("Humanoid") then
                    return child
                end
            end
        end
    end
    
    -- Método 3: Buscar modelo con nombre del jugador en Workspace
    local model = Workspace:FindFirstChild(player.Name)
    if model and model:IsA("Model") and model:FindFirstChildOfClass("Humanoid") then
        return model
    end
    
    -- Método 4: Buscar por UserId
    for _, child in ipairs(Workspace:GetChildren()) do
        if child:IsA("Model") then
            local hum = child:FindFirstChildOfClass("Humanoid")
            if hum then
                pcall(function()
                    if child:GetAttribute("UserId") == player.UserId or
                       child:GetAttribute("PlayerID") == player.UserId or
                       child:GetAttribute("Player") == player.Name then
                        char = child
                    end
                end)
                if char then return char end
            end
        end
    end
    
    return player.Character
end

local function GetHyperShotHumanoid(character)
    if not character then return nil end
    -- Buscar Humanoid directamente
    local hum = character:FindFirstChildOfClass("Humanoid")
    if hum then return hum end
    -- Buscar en descendientes (algunos juegos lo anidan)
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("Humanoid") then return desc end
    end
    return nil
end

local function GetHyperShotRootPart(character)
    if not character then return nil end
    -- Prioridad: HumanoidRootPart > PrimaryPart > Torso > UpperTorso
    return character:FindFirstChild("HumanoidRootPart")
        or character.PrimaryPart
        or character:FindFirstChild("Torso")
        or character:FindFirstChild("UpperTorso")
end

-- ================== TEAM CHECK ==================
local function IsHyperShotTeammate(player)
    if not player or player == LocalPlayer then return false end
    
    -- Método 1: Teams estándar
    local ok1, r1 = pcall(function()
        return player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team
    end)
    if ok1 and r1 then return true end
    
    -- Método 2: TeamColor
    local ok2, r2 = pcall(function()
        return player.TeamColor and LocalPlayer.TeamColor and player.TeamColor == LocalPlayer.TeamColor
    end)
    if ok2 and r2 then return true end
    
    -- Método 3: Atributos del personaje
    local ok3, r3 = pcall(function()
        local myChar = GetHyperShotCharacter(LocalPlayer)
        local theirChar = GetHyperShotCharacter(player)
        if myChar and theirChar then
            local myTeam = myChar:GetAttribute("Team") or myChar:GetAttribute("TeamID")
            local theirTeam = theirChar:GetAttribute("Team") or theirChar:GetAttribute("TeamID")
            if myTeam and theirTeam then return myTeam == theirTeam end
        end
        return false
    end)
    if ok3 and r3 then return true end
    
    -- Método 4: Buscar IntValue/StringValue "Team" dentro del personaje
    local ok4, r4 = pcall(function()
        local myChar = GetHyperShotCharacter(LocalPlayer)
        local theirChar = GetHyperShotCharacter(player)
        if myChar and theirChar then
            local myTeamVal = myChar:FindFirstChild("Team") or myChar:FindFirstChild("TeamValue")
            local theirTeamVal = theirChar:FindFirstChild("Team") or theirChar:FindFirstChild("TeamValue")
            if myTeamVal and theirTeamVal and myTeamVal:IsA("ValueBase") and theirTeamVal:IsA("ValueBase") then
                return myTeamVal.Value == theirTeamVal.Value
            end
        end
        return false
    end)
    if ok4 and r4 then return true end
    
    return false
end

local function ShouldSkip(player, teamCheck)
    return teamCheck and IsHyperShotTeammate(player)
end

-- ================== VISIBILITY CHECK ==================
local function IsHyperShotVisible(part)
    if not part then return false end
    local origin = Camera.CFrame.Position
    local dir = part.Position - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end
    local result = Workspace:Raycast(origin, dir.Unit * (dist - 0.3), _visParams)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(part.Parent)
end

-- ================== TARGET PARTS ==================
local HS_PARTS = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso"}
local randomPart = "Head"
local randomSwitch = 0

local function GetHyperShotTargetPart(character, setting)
    if not character then return nil end
    
    if setting == "Random" then
        if tick() - randomSwitch > 0.5 then
            local valid = {}
            for _, name in ipairs(HS_PARTS) do
                if character:FindFirstChild(name) then table.insert(valid, name) end
            end
            if #valid > 0 then randomPart = valid[math.random(#valid)] end
            randomSwitch = tick()
        end
        return character:FindFirstChild(randomPart)
            or character:FindFirstChild("Head")
            or character:FindFirstChild("HumanoidRootPart")
    end
    
    -- Buscar la parte solicitada con fallbacks
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

-- ================== SILENT AIM ==================
local CurrentTarget, CurrentTargetPos, CurrentTargetPart = nil, nil, nil
local _lastSilentUpdate = 0

local function UpdateSilentTarget()
    local now = tick()
    if now - _lastSilentUpdate < 0.05 then return end
    _lastSilentUpdate = now
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    if not (Config.Silent.Enabled and Config.Silent.Active) then
        CurrentTarget, CurrentTargetPos, CurrentTargetPart = nil, nil, nil
        return
    end
    
    local bestDist = Config.FOV.Enabled and Config.FOV.Radius or 9e9
    local closest, bestPos, bestPart = nil, nil, nil
    local mouse = UserInputService:GetMouseLocation()
    
    for _, plr in ipairs(GetCachedPlayers()) do
        if plr == LocalPlayer or ShouldSkip(plr, Config.Silent.TeamCheck) then continue end
        
        local char = GetHyperShotCharacter(plr)
        if not char then continue end
        
        local hum = GetHyperShotHumanoid(char)
        if not hum or hum.Health <= 0 then continue end
        if char:FindFirstChildOfClass("ForceField") then continue end
        
        local tp = GetHyperShotTargetPart(char, Config.Silent.TargetPart)
        if not tp then continue end
        
        if Config.Silent.VisibleCheck and not IsHyperShotVisible(tp) then continue end
        
        -- Predicción de posición
        local predicted = tp.Position
        pcall(function()
            if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                local vel = tp.AssemblyLinearVelocity
                if vel and vel.Magnitude > 0.5 then
                    predicted = predicted + vel * Config.Aimbot.Prediction
                end
            end
        end)
        
        -- Verificación de ángulo
        local camPos = Camera.CFrame.Position
        local look = Camera.CFrame.LookVector
        local toT = predicted - camPos
        local toTMag = toT.Magnitude
        if toTMag < 0.01 then continue end
        
        local dot = look.X * (toT.X / toTMag) + look.Y * (toT.Y / toTMag) + look.Z * (toT.Z / toTMag)
        local angle = math.deg(math.acos(math.clamp(dot, -1, 1)))
        if angle > MAX_SILENT_ANGLE_DEG then continue end
        
        local screen, onScreen = Camera:WorldToViewportPoint(predicted)
        if not onScreen then continue end
        
        local sd = (Vector2.new(screen.X, screen.Y) - mouse).Magnitude
        if sd < bestDist then
            bestDist = sd
            closest = plr
            bestPos = predicted
            bestPart = tp
        end
    end
    
    CurrentTarget = closest
    CurrentTargetPos = bestPos
    CurrentTargetPart = bestPart
end

-- ================== AIMBOT ==================
local hsAimbotLocked = nil
local hsAimbotRandom = "Head"
local hsAimbotSwitch = 0

local function GetHSAimbotPart(character)
    if not character then return nil end
    local s = Config.Aimbot.TargetPart
    
    if s == "Random" then
        local t = tick()
        if t - hsAimbotSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local valid = {}
            for _, n in ipairs(HS_PARTS) do
                if character:FindFirstChild(n) then table.insert(valid, n) end
            end
            if #valid > 0 then hsAimbotRandom = valid[math.random(#valid)] end
            hsAimbotSwitch = t
        end
        return character:FindFirstChild(hsAimbotRandom)
            or character:FindFirstChild("Head")
    end
    
    return character:FindFirstChild(s)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
end

local function IsHSPlayerValid(player)
    if not player or not player.Parent or player == LocalPlayer then return false end
    if ShouldSkip(player, Config.Aimbot.TeamCheck) then return false end
    local c = GetHyperShotCharacter(player)
    if not c or c:FindFirstChildOfClass("ForceField") then return false end
    local h = GetHyperShotHumanoid(c)
    return h and h.Health > 0
end

local function GetHSAimbotTarget()
    Camera = Workspace.CurrentCamera
    if not Camera then return nil end
    
    local fov = Config.Aimbot.FOVRadius or 150
    local vp = Camera.ViewportSize
    local center = Vector2.new(vp.X / 2, vp.Y / 2)
    local mousePos = UserInputService:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos
    
    -- Si Aimlock tiene target bloqueado
    if Config.Aimbot.Method == "Aimlock" and hsAimbotLocked then
        if IsHSPlayerValid(hsAimbotLocked) then
            local char = GetHyperShotCharacter(hsAimbotLocked)
            local tp = GetHSAimbotPart(char)
            if tp and (not Config.Aimbot.VisibleCheck or IsHyperShotVisible(tp)) then
                local sp, on = Camera:WorldToViewportPoint(tp.Position)
                if on then return tp end
            end
        end
        hsAimbotLocked = nil
    end
    
    local best, bestDist, bestP = nil, fov, nil
    for _, player in ipairs(GetCachedPlayers()) do
        if not IsHSPlayerValid(player) then continue end
        local char = GetHyperShotCharacter(player)
        local tp = GetHSAimbotPart(char)
        if not tp then continue end
        if Config.Aimbot.VisibleCheck and not IsHyperShotVisible(tp) then continue end
        local sp, on = Camera:WorldToViewportPoint(tp.Position)
        if not on then continue end
        local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
        if d < bestDist then bestDist = d; best = tp; bestP = player end
    end
    
    if Config.Aimbot.Method == "Aimlock" and bestP then hsAimbotLocked = bestP end
    return best
end

-- ================== ESP ==================
local HyperShotESP = {}
local HSLastESP = 0

local function CreateHSESP(player)
    if HyperShotESP[player] then return end
    local e = {}
    e.Box = Drawing.new("Square")
    e.Box.Thickness = 1; e.Box.Filled = false
    e.Box.Color = Color3.fromRGB(255, 255, 255); e.Box.Visible = false
    
    e.Outline = Drawing.new("Square")
    e.Outline.Thickness = 3; e.Outline.Filled = false
    e.Outline.Color = Color3.fromRGB(0, 0, 0); e.Outline.Transparency = 0.5; e.Outline.Visible = false
    
    e.Name = Drawing.new("Text")
    e.Name.Size = 13; e.Name.Center = true; e.Name.Outline = true
    e.Name.Color = Color3.fromRGB(255, 255, 255); e.Name.Visible = false
    
    e.Distance = Drawing.new("Text")
    e.Distance.Size = 12; e.Distance.Center = true; e.Distance.Outline = true
    e.Distance.Color = Color3.fromRGB(200, 200, 200); e.Distance.Visible = false
    
    e.HealthBG = Drawing.new("Square")
    e.HealthBG.Thickness = 1; e.HealthBG.Filled = true
    e.HealthBG.Color = Color3.fromRGB(0, 0, 0); e.HealthBG.Transparency = 0.5; e.HealthBG.Visible = false
    
    e.HealthBar = Drawing.new("Square")
    e.HealthBar.Thickness = 1; e.HealthBar.Filled = true
    e.HealthBar.Color = Color3.fromRGB(0, 255, 0); e.HealthBar.Visible = false
    
    HyperShotESP[player] = e
end

local function RemoveHSESP(p)
    local e = HyperShotESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    HyperShotESP[p] = nil
end

local function HideHSESP(p)
    local e = HyperShotESP[p]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

local function UpdateHyperShotESP()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(HyperShotESP) do HideHSESP(p) end
        return
    end
    
    local now = tick()
    if now - HSLastESP < 0.08 then return end
    HSLastESP = now
    
    Camera = Workspace.CurrentCamera
    if not Camera then return end
    
    local active = {}
    for _, player in ipairs(GetCachedPlayers()) do
        if player == LocalPlayer then continue end
        active[player] = true
        
        local isTm = IsHyperShotTeammate(player)
        if Config.ESP.TeamCheck and isTm then HideHSESP(player); continue end
        
        if not HyperShotESP[player] then
            pcall(function() CreateHSESP(player) end)
        end
        local esp = HyperShotESP[player]
        if not esp then continue end
        
        local c = GetHyperShotCharacter(player)
        local h = c and GetHyperShotHumanoid(c)
        local rp = c and GetHyperShotRootPart(c)
        local head = c and c:FindFirstChild("Head")
        
        if not c or not h or not rp or h.Health <= 0 or c:FindFirstChildOfClass("ForceField") then
            HideHSESP(player); continue
        end
        
        local dist = (Camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideHSESP(player); continue end
        
        local sp, on = Camera:WorldToViewportPoint(rp.Position)
        if not on then HideHSESP(player); continue end
        
        -- Calcular bounding box
        local hSP = head and select(1, Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))) or sp
        local fSP = select(1, Camera:WorldToViewportPoint(rp.Position - Vector3.new(0, 3, 0)))
        local height = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local width = height / 2
        local minX = sp.X - width / 2
        local minY = hSP.Y
        
        -- Color según equipo/visibilidad
        local col = isTm and Color3.fromRGB(80, 150, 255)
            or (head and IsHyperShotVisible(head) and Color3.fromRGB(50, 255, 50)
            or Color3.fromRGB(255, 50, 50))
        
        -- Box
        if Config.ESP.Boxes then
            esp.Outline.Size = Vector2.new(width + 2, height + 2)
            esp.Outline.Position = Vector2.new(minX - 1, minY - 1)
            esp.Outline.Visible = true
            esp.Box.Size = Vector2.new(width, height)
            esp.Box.Position = Vector2.new(minX, minY)
            esp.Box.Color = col
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
            esp.Outline.Visible = false
        end
        
        -- Name
        if Config.ESP.Names then
            esp.Name.Text = player.DisplayName or player.Name
            esp.Name.Position = Vector2.new(minX + width / 2, minY - 16)
            esp.Name.Color = col
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        -- Distance
        if Config.ESP.Distance then
            esp.Distance.Text = math.floor(dist) .. "m"
            esp.Distance.Position = Vector2.new(minX + width / 2, minY + height + 2)
            esp.Distance.Visible = true
        else
            esp.Distance.Visible = false
        end
        
        -- Health bar
        if Config.ESP.Boxes and h then
            local pct = math.clamp(h.Health / math.max(h.MaxHealth, 1), 0, 1)
            local bh = height * pct
            local hc = pct > 0.5
                and Color3.fromRGB(math.floor(255 * (1 - pct) * 2), 255, 0)
                or Color3.fromRGB(255, math.floor(255 * pct * 2), 0)
            esp.HealthBG.Size = Vector2.new(3, height)
            esp.HealthBG.Position = Vector2.new(minX - 6, minY)
            esp.HealthBG.Visible = true
            esp.HealthBar.Size = Vector2.new(3, bh)
            esp.HealthBar.Position = Vector2.new(minX - 6, minY + (height - bh))
            esp.HealthBar.Color = hc
            esp.HealthBar.Visible = true
        else
            esp.HealthBG.Visible = false
            esp.HealthBar.Visible = false
        end
    end
    
    -- Limpiar jugadores que ya no están
    for p in pairs(HyperShotESP) do
        if not active[p] then
            if not p.Parent then RemoveHSESP(p) else HideHSESP(p) end
        end
    end
end

-- ================== AC BYPASS ==================
local function SafeACBypass()
    -- Buscar y neutralizar anti-cheat remotes comunes en HyperShot
    pcall(function()
        local remotes = ReplicatedStorage:FindFirstChild("Remotes")
            or ReplicatedStorage:FindFirstChild("Events")
            or ReplicatedStorage:FindFirstChild("Network")
        if not remotes then return end
        
        -- Buscar remotes de analytics/anti-cheat
        for _, child in ipairs(remotes:GetDescendants()) do
            if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                local name = child.Name:lower()
                if name:find("analytic") or name:find("anticheat") or name:find("detect")
                    or name:find("report") or name:find("security") or name:find("validate") then
                    if child:IsA("RemoteEvent") and getconnections then
                        for _, conn in pairs(getconnections(child.OnClientEvent)) do
                            if conn.Function then
                                pcall(function()
                                    hookfunction(conn.Function, newcclosure(function() end))
                                end)
                            end
                        end
                    end
                end
            end
        end
    end)
    
    -- Kick hook
    if not getgenv()._AX_KickHooked then
        pcall(function()
            for _, name in ipairs({"Kick", "kick"}) do
                local fn = LocalPlayer[name]
                if typeof(fn) == "function" then
                    local old = fn
                    hookfunction(fn, newcclosure(function(self, ...)
                        if self == LocalPlayer then return end
                        return old(self, ...)
                    end))
                end
            end
            getgenv()._AX_KickHooked = true
        end)
    end
end
task.delay(4, SafeACBypass)

-- Limpieza periódica de _G anti-cheat
task.spawn(function()
    task.wait(30)
    while true do
        pcall(function()
            local sk = {"signature", "checksum", "exploit", "detect", "anticheat", "cheat", "hack"}
            for k in pairs(_G) do
                local ks = tostring(k):lower()
                for _, s in ipairs(sk) do
                    if ks:find(s) then _G[k] = nil; break end
                end
            end
        end)
        task.wait(25)
    end
end)

-- ================== NAMECALL HOOK ==================
task.delay(8, function()
    local char = LocalPlayer.Character
    if not char then
        local t = tick()
        repeat task.wait(0.5) until LocalPlayer.Character or tick() - t > 10
    end
    
    local _inHook = false
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        if _inHook or checkcaller() then return oldNamecall(self, ...) end
        
        local method = getnamecallmethod()
        local isRaycast = method == "Raycast" or method == "FindPartOnRay"
            or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist"
        local isFireServer = method == "FireServer"
        
        if not (isRaycast or isFireServer) then return oldNamecall(self, ...) end
        if not (Config.Silent.Enabled and Config.Silent.Active and CurrentTargetPos and CurrentTargetPart) then
            return oldNamecall(self, ...)
        end
        if math.random(100) > Config.Silent.HitChance then return oldNamecall(self, ...) end
        if tick() - _lastShotModified < MIN_SHOT_INTERVAL then return oldNamecall(self, ...) end
        
        _inHook = true
        local args = {...}
        
        if isRaycast and (self == Workspace or self == workspace) then
            local cam = Workspace.CurrentCamera
            
            if method == "Raycast" then
                local origin, direction = args[1], args[2]
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" and cam then
                    local cp = cam.CFrame.Position
                    local dx, dy, dz = origin.X - cp.X, origin.Y - cp.Y, origin.Z - cp.Z
                    if math.sqrt(dx * dx + dy * dy + dz * dz) <= 10 then
                        local tp = CurrentTargetPos
                        local tx, ty, tz = tp.X - origin.X, tp.Y - origin.Y, tp.Z - origin.Z
                        local tMag = math.sqrt(tx * tx + ty * ty + tz * tz)
                        local dMag = math.sqrt(direction.X * direction.X + direction.Y * direction.Y + direction.Z * direction.Z)
                        if tMag > 0 and dMag > 0 then
                            local dot = (direction.X / dMag) * (tx / tMag) + (direction.Y / dMag) * (ty / tMag) + (direction.Z / dMag) * (tz / tMag)
                            if math.deg(math.acos(math.clamp(dot, -1, 1))) <= MAX_SILENT_ANGLE_DEG then
                                local part = CurrentTargetPart
                                local size = part.Size
                                local off = Vector3.new(
                                    (math.random() - 0.5) * size.X * HITBOX_OFFSET_SCALE,
                                    (math.random() - 0.5) * size.Y * HITBOX_OFFSET_SCALE,
                                    (math.random() - 0.5) * size.Z * HITBOX_OFFSET_SCALE
                                )
                                local ft = tp + off
                                local nx, ny, nz = ft.X - origin.X, ft.Y - origin.Y, ft.Z - origin.Z
                                local nMag = math.sqrt(nx * nx + ny * ny + nz * nz)
                                if nMag > 0 then
                                    local sc = dMag / nMag
                                    args[2] = Vector3.new(nx * sc, ny * sc, nz * sc)
                                    _lastShotModified = tick()
                                    _inHook = false
                                    return oldNamecall(self, unpack(args))
                                end
                            end
                        end
                    end
                end
                
            elseif method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" and cam then
                    local origin, direction = ray.Origin, ray.Direction
                    local cp = cam.CFrame.Position
                    local dx, dy, dz = origin.X - cp.X, origin.Y - cp.Y, origin.Z - cp.Z
                    if math.sqrt(dx * dx + dy * dy + dz * dz) <= 10 then
                        local tp = CurrentTargetPos
                        local tx, ty, tz = tp.X - origin.X, tp.Y - origin.Y, tp.Z - origin.Z
                        local tMag = math.sqrt(tx * tx + ty * ty + tz * tz)
                        local dMag = math.sqrt(direction.X * direction.X + direction.Y * direction.Y + direction.Z * direction.Z)
                        if tMag > 0 and dMag > 0 then
                            local dot = (direction.X / dMag) * (tx / tMag) + (direction.Y / dMag) * (ty / tMag) + (direction.Z / dMag) * (tz / tMag)
                            if math.deg(math.acos(math.clamp(dot, -1, 1))) <= MAX_SILENT_ANGLE_DEG then
                                local part = CurrentTargetPart
                                local size = part.Size
                                local ft = tp + Vector3.new(
                                    (math.random() - 0.5) * size.X * HITBOX_OFFSET_SCALE,
                                    (math.random() - 0.5) * size.Y * HITBOX_OFFSET_SCALE,
                                    (math.random() - 0.5) * size.Z * HITBOX_OFFSET_SCALE
                                )
                                local nx, ny, nz = ft.X - origin.X, ft.Y - origin.Y, ft.Z - origin.Z
                                local nMag = math.sqrt(nx * nx + ny * ny + nz * nz)
                                if nMag > 0 then
                                    local sc = dMag / nMag
                                    args[1] = Ray.new(origin, Vector3.new(nx * sc, ny * sc, nz * sc))
                                    _lastShotModified = tick()
                                    _inHook = false
                                    return oldNamecall(self, unpack(args))
                                end
                            end
                        end
                    end
                end
            end
            
        elseif isFireServer then
            local isRemote = false
            pcall(function() isRemote = typeof(self) == "Instance" and self.ClassName == "RemoteEvent" end)
            if isRemote then
                local cam = Workspace.CurrentCamera
                if cam then
                    local cp = cam.CFrame.Position
                    local cl = cam.CFrame.LookVector
                    local tp = CurrentTargetPos
                    local tx, ty, tz = tp.X - cp.X, tp.Y - cp.Y, tp.Z - cp.Z
                    local tMag = math.sqrt(tx * tx + ty * ty + tz * tz)
                    local lMag = math.sqrt(cl.X * cl.X + cl.Y * cl.Y + cl.Z * cl.Z)
                    if tMag > 0 and lMag > 0 then
                        local dot = (cl.X / lMag) * (tx / tMag) + (cl.Y / lMag) * (ty / tMag) + (cl.Z / lMag) * (tz / tMag)
                        if math.deg(math.acos(math.clamp(dot, -1, 1))) <= MAX_SILENT_ANGLE_DEG then
                            local part = CurrentTargetPart
                            local size = part.Size
                            local ft = tp + Vector3.new(
                                (math.random() - 0.5) * size.X * HITBOX_OFFSET_SCALE,
                                (math.random() - 0.5) * size.Y * HITBOX_OFFSET_SCALE,
                                (math.random() - 0.5) * size.Z * HITBOX_OFFSET_SCALE
                            )
                            local modified = false
                            for i, arg in ipairs(args) do
                                if typeof(arg) == "CFrame" then
                                    args[i] = CFrame.new(arg.Position, ft)
                                    modified = true
                                end
                            end
                            if not modified then
                                -- También intentar modificar Vector3 de dirección
                                for i, arg in ipairs(args) do
                                    if typeof(arg) == "Vector3" then
                                        local aMag = arg.Magnitude
                                        if aMag > 5 then -- Probablemente es una dirección de disparo
                                            local dir = (ft - cp).Unit * aMag
                                            args[i] = dir
                                            modified = true
                                            break
                                        end
                                    end
                                end
                            end
                            if modified then
                                _lastShotModified = tick()
                                _inHook = false
                                return oldNamecall(self, unpack(args))
                            end
                        end
                    end
                end
            end
        end
        
        _inHook = false
        return oldNamecall(self, ...)
    end))
end)

-- ================== MAIN LOOPS ==================
-- Aimbot + Silent Target (RenderStepped para fluidez)
task.delay(3, function()
    RunService.RenderStepped:Connect(function()
        Camera = Workspace.CurrentCamera
        UpdateSilentTarget()
        
        if Config.Aimbot.Enabled and Config.Aimbot.Active then
            local t = GetHSAimbotTarget()
            if t then
                local pos = t.Position
                pcall(function()
                    if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 then
                        local v = t.AssemblyLinearVelocity
                        if v and v.Magnitude > 0.5 then
                            pos = pos + v * Config.Aimbot.Prediction
                        end
                    end
                end)
                
                local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
                if Config.Aimbot.Method == "Aimbot" then
                    local cur = Camera.CFrame
                    local tgt = CFrame.lookAt(cur.Position, pos)
                    Camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1 / sm)
                else
                    local sp, on = Camera:WorldToViewportPoint(pos)
                    if on then
                        local mp = UserInputService:GetMouseLocation()
                        local dx, dy = sp.X - mp.X, sp.Y - mp.Y
                        local d = math.sqrt(dx * dx + dy * dy)
                        if d > 1 then
                            local spd = math.clamp(1 / sm, 0.05, 0.8)
                            local mx = math.clamp(dx * spd, -150, 150)
                            local my = math.clamp(dy * spd, -150, 150)
                            if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then
                                mousemoverel(mx, my)
                            end
                        end
                    end
                end
            else
                if not Config.Aimbot.Active then hsAimbotLocked = nil end
            end
        else
            if not Config.Aimbot.Active then hsAimbotLocked = nil end
        end
    end)
end)

-- ESP (Heartbeat, menor prioridad)
task.delay(4, function()
    RunService.Heartbeat:Connect(function()
        UpdateHyperShotESP()
    end)
end)

-- ================== FLAGS DE MÓDULO ==================
getgenv().AX_HyperShotLoaded       = true
getgenv().AX_HyperShotHandlesAimbot = true
getgenv().AX_HyperShotHandlesESP    = true
getgenv().AX_HyperShotHandlesSilent = true

-- ================== INICIALIZACIÓN ESP ==================
task.delay(1, function()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            pcall(function() CreateHSESP(p) end)
        end
    end
end)

Players.PlayerAdded:Connect(function(p)
    task.delay(2, function()
        pcall(function() CreateHSESP(p) end)
    end)
end)

Players.PlayerRemoving:Connect(function(p)
    if hsAimbotLocked == p then hsAimbotLocked = nil end
    RemoveHSESP(p)
    for i, v in ipairs(_cachedPlayers) do
        if v == p then table.remove(_cachedPlayers, i); break end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    Camera = Workspace.CurrentCamera
    CurrentTarget = nil
    CurrentTargetPos = nil
    CurrentTargetPart = nil
    hsAimbotLocked = nil
    UpdateVisFilter()
    task.wait(3)
    pcall(SafeACBypass)
end)
