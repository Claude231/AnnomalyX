--[[
    ANNOMALY X - HyperShot Module v4
    Copiado DIRECTO del script funcional
]]

-- Esperar config
if not getgenv().AX_Config then
    local t = tick()
    repeat task.wait() until getgenv().AX_Config or tick() - t > 30
end
local Config = getgenv().AX_Config
local mousemoverel = mousemoverel or function() end

local players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera
local runService = game:GetService("RunService")
local userInput = game:GetService("UserInputService")

-- Esperar a que PlayerGui tenga todo cargado
local function waitForChild(parent, name, timeout)
    local t = tick()
    local child = parent:FindFirstChild(name, true)
    while not child and tick() - t < (timeout or 30) do
        task.wait(0.5)
        child = parent:FindFirstChild(name, true)
    end
    return child
end

warn("[AX HSX] Esperando módulos del juego...")

-- Esperar PlayerGui
repeat task.wait(0.5) until localPlayer:FindFirstChild("PlayerGui")
repeat task.wait(0.5) until localPlayer.PlayerGui:FindFirstChild("GameUI")
repeat task.wait(0.5) until localPlayer.PlayerGui:FindFirstChild("ControllerGUI")

-- Esperar módulos específicos
local gameUIFound = waitForChild(localPlayer.PlayerGui.GameUI, "GameUIMod")
local gunFound = waitForChild(localPlayer.PlayerGui.ControllerGUI, "Gun")

if not gameUIFound or not gunFound then
    warn("[AX HSX] ❌ No se encontraron los módulos del juego")
    return
end

warn("[AX HSX] Módulos encontrados, cargando...")

local globalStuff = require(game:GetService("ReplicatedStorage").Modules.GlobalStuff)
local gameUIMod = require(localPlayer.PlayerGui.GameUI.GameUIMod)
local gunModule = require(localPlayer.PlayerGui.ControllerGUI.NewMainLocal.Tools.Tool.Gun)

warn("[AX HSX] ✅ Módulos cargados")

-- ================== SILENT AIM (copiado exacto) ==================
local function getClosestTarget()
    local closestTarget, shortestDist = nil, Config.FOV.Enabled and Config.FOV.Radius or 300
    local mousePos = userInput:GetMouseLocation()
    local mobs = workspace:FindFirstChild("Mobs")
    if not mobs then return nil end
    for _, mob in ipairs(mobs:GetChildren()) do
        if globalStuff:SameTeam(localPlayer, mob) then continue end
        local humanoid = mob:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        local part = mob:FindFirstChild("Head") or mob:FindFirstChild("HumanoidRootPart")
        if not part then continue end
        local screenPos, onScreen = camera:WorldToScreenPoint(part.Position)
        if not onScreen then continue end
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < shortestDist then
            shortestDist = dist
            closestTarget = mob
        end
    end
    return closestTarget
end

-- Hook GetMousePos
local originalGetMousePos = gameUIMod.GetMousePos
gameUIMod.GetMousePos = function(self, ...)
    if Config.Silent.Enabled and Config.Silent.Active then
        local target = getClosestTarget()
        if target then
            local head = target:FindFirstChild("Head")
            if head then
                if math.random(100) <= Config.Silent.HitChance then
                    return head.Position
                end
            end
        end
    end
    return originalGetMousePos(self, ...)
end

-- Hook ConeOfFire
local originalConeOfFire = gunModule.ConeOfFire
gunModule.ConeOfFire = function(self, origin, mousePos, spread)
    if Config.Silent.Enabled and Config.Silent.Active then
        local target = getClosestTarget()
        if target then
            local head = target:FindFirstChild("Head")
            if head then
                if math.random(100) <= Config.Silent.HitChance then
                    return head.Position
                end
            end
        end
    end
    return originalConeOfFire(self, origin, mousePos, spread)
end

-- Hook GetTotalSpread
local originalGetTotalSpread = gunModule.GetTotalSpread
gunModule.GetTotalSpread = function(self)
    if Config.Silent.Enabled and Config.Silent.Active then
        if getClosestTarget() then
            return 0
        end
    end
    return originalGetTotalSpread(self)
end

warn("[AX HSX] ✅ Silent Aim hooks instalados")

-- ================== VISIBILITY (para ESP) ==================
local _visParams = RaycastParams.new()
_visParams.FilterType = Enum.RaycastFilterType.Exclude
_visParams.IgnoreWater = true

local function UpdateVisFilter()
    local t = {camera}
    local myChar = workspace:FindFirstChild(localPlayer.Name)
    if myChar then table.insert(t, myChar) end
    _visParams.FilterDescendantsInstances = t
end
UpdateVisFilter()

local function IsVisible(part)
    if not part then return false end
    local origin = camera.CFrame.Position
    local dir = part.Position - origin
    local dist = dir.Magnitude
    if dist < 3 then return true end
    local result = workspace:Raycast(origin, dir.Unit * (dist - 0.3), _visParams)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(part.Parent)
end

-- ================== AIMBOT ==================
local hsAimbotLocked = nil

runService.RenderStepped:Connect(function()
    camera = workspace.CurrentCamera
    
    if not Config.Aimbot.Enabled or not Config.Aimbot.Active then
        if not Config.Aimbot.Active then hsAimbotLocked = nil end
        return
    end

    local mobs = workspace:FindFirstChild("Mobs")
    if not mobs then return end

    local vp = camera.ViewportSize
    local center = Vector2.new(vp.X/2, vp.Y/2)
    local mousePos = userInput:GetMouseLocation()
    local ref = Config.Aimbot.Method == "Aimbot" and center or mousePos
    local bestPart, bestDist = nil, Config.Aimbot.FOVRadius or 150

    -- Aimlock mantener target
    if Config.Aimbot.Method == "Aimlock" and hsAimbotLocked and hsAimbotLocked.Parent then
        local hum = hsAimbotLocked:FindFirstChildOfClass("Humanoid")
        if hum and hum.Health > 0 then
            local p = hsAimbotLocked:FindFirstChild("Head") or hsAimbotLocked:FindFirstChild("HumanoidRootPart")
            if p and (not Config.Aimbot.VisibleCheck or IsVisible(p)) then
                local sp, on = camera:WorldToViewportPoint(p.Position)
                if on then bestPart = p end
            end
        end
        if not bestPart then hsAimbotLocked = nil end
    end

    if not bestPart then
        for _, mob in ipairs(mobs:GetChildren()) do
            if Config.Aimbot.TeamCheck and globalStuff:SameTeam(localPlayer, mob) then continue end
            local hum = mob:FindFirstChildOfClass("Humanoid")
            if not hum or hum.Health <= 0 then continue end
            local p = mob:FindFirstChild("Head") or mob:FindFirstChild("HumanoidRootPart")
            if not p then continue end
            if Config.Aimbot.VisibleCheck and not IsVisible(p) then continue end
            local sp, on = camera:WorldToViewportPoint(p.Position)
            if not on then continue end
            local d = (Vector2.new(sp.X, sp.Y) - ref).Magnitude
            if d < bestDist then
                bestDist = d
                bestPart = p
                if Config.Aimbot.Method == "Aimlock" then hsAimbotLocked = mob end
            end
        end
    end

    if not bestPart then return end

    local pos = bestPart.Position
    pcall(function()
        if Config.Aimbot.Prediction > 0 then
            local v = bestPart.AssemblyLinearVelocity
            if v and v.Magnitude > 0.5 then pos = pos + v * Config.Aimbot.Prediction end
        end
    end)

    local sm = math.max(Config.Aimbot.Smoothness or 5, 1)
    if Config.Aimbot.Method == "Aimbot" then
        local cur = camera.CFrame
        local tgt = CFrame.lookAt(cur.Position, pos)
        camera.CFrame = sm <= 1 and tgt or cur:Lerp(tgt, 1/sm)
    else
        local sp, on = camera:WorldToViewportPoint(pos)
        if on then
            local mp = userInput:GetMouseLocation()
            local dx, dy = sp.X - mp.X, sp.Y - mp.Y
            if math.sqrt(dx*dx + dy*dy) > 1 then
                local spd = math.clamp(1/sm, 0.05, 0.8)
                local mx = math.clamp(dx*spd, -150, 150)
                local my = math.clamp(dy*spd, -150, 150)
                if math.abs(mx) > 0.3 or math.abs(my) > 0.3 then mousemoverel(mx, my) end
            end
        end
    end
end)

-- ================== ESP ==================
local HSESP = {}
local lastESP = 0

local function MakeESP(key)
    if HSESP[key] then return end
    HSESP[key] = {
        Box = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Dist = Drawing.new("Text"),
        HBG = Drawing.new("Square"),
        HBar = Drawing.new("Square")
    }
    local e = HSESP[key]
    e.Box.Thickness=1; e.Box.Filled=false; e.Box.Visible=false
    e.Outline.Thickness=3; e.Outline.Filled=false; e.Outline.Color=Color3.fromRGB(0,0,0); e.Outline.Transparency=0.5; e.Outline.Visible=false
    e.Name.Size=13; e.Name.Center=true; e.Name.Outline=true; e.Name.Visible=false
    e.Dist.Size=12; e.Dist.Center=true; e.Dist.Outline=true; e.Dist.Color=Color3.fromRGB(200,200,200); e.Dist.Visible=false
    e.HBG.Thickness=1; e.HBG.Filled=true; e.HBG.Color=Color3.fromRGB(0,0,0); e.HBG.Transparency=0.5; e.HBG.Visible=false
    e.HBar.Thickness=1; e.HBar.Filled=true; e.HBar.Visible=false
end

local function KillESP(key)
    local e = HSESP[key]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d:Remove() end) end
    HSESP[key] = nil
end

local function HideESP(key)
    local e = HSESP[key]
    if not e then return end
    for _, d in pairs(e) do pcall(function() d.Visible = false end) end
end

runService.Heartbeat:Connect(function()
    if not Config.ESP.Enabled or not Config.ESP.Active then
        for k in pairs(HSESP) do HideESP(k) end
        return
    end
    local now = tick()
    if now - lastESP < 0.08 then return end
    lastESP = now
    camera = workspace.CurrentCamera
    if not camera then return end
    UpdateVisFilter()

    local mobs = workspace:FindFirstChild("Mobs")
    if not mobs then
        for k in pairs(HSESP) do HideESP(k) end
        return
    end

    local active = {}
    for _, mob in ipairs(mobs:GetChildren()) do
        if not mob:IsA("Model") then continue end
        local key = mob.Name
        active[key] = true

        if Config.ESP.TeamCheck and globalStuff:SameTeam(localPlayer, mob) then HideESP(key); continue end

        local hum = mob:FindFirstChildOfClass("Humanoid")
        local rp = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("FakeHRP") or mob:FindFirstChild("UpperTorso")
        local head = mob:FindFirstChild("Head")
        if not hum or not rp or hum.Health <= 0 then HideESP(key); continue end

        local dist = (camera.CFrame.Position - rp.Position).Magnitude
        if dist > Config.ESP.MaxDistance then HideESP(key); continue end

        local sp, on = camera:WorldToViewportPoint(rp.Position)
        if not on then HideESP(key); continue end

        if not HSESP[key] then MakeESP(key) end
        local e = HSESP[key]
        if not e then continue end

        local hSP = head and select(1, camera:WorldToViewportPoint(head.Position + Vector3.new(0,0.5,0))) or sp
        local fSP = select(1, camera:WorldToViewportPoint(rp.Position - Vector3.new(0,3,0)))
        local h = math.max(math.abs(hSP.Y - fSP.Y), 10)
        local w = h / 2
        local mx = sp.X - w/2
        local my = hSP.Y

        local isBot = key:find("__Bot") ~= nil
        local col = isBot and Color3.fromRGB(255,200,50)
            or (head and IsVisible(head) and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,50,50))

        if Config.ESP.Boxes then
            e.Outline.Size=Vector2.new(w+2,h+2); e.Outline.Position=Vector2.new(mx-1,my-1); e.Outline.Visible=true
            e.Box.Size=Vector2.new(w,h); e.Box.Position=Vector2.new(mx,my); e.Box.Color=col; e.Box.Visible=true
        else e.Box.Visible=false; e.Outline.Visible=false end

        if Config.ESP.Names then
            local dn = isBot and key:gsub("__Bot","").." [BOT]" or key
            e.Name.Text=dn; e.Name.Position=Vector2.new(mx+w/2,my-16); e.Name.Color=col; e.Name.Visible=true
        else e.Name.Visible=false end

        if Config.ESP.Distance then
            e.Dist.Text=math.floor(dist).."m"; e.Dist.Position=Vector2.new(mx+w/2,my+h+2); e.Dist.Visible=true
        else e.Dist.Visible=false end

        if Config.ESP.Boxes then
            local pct = math.clamp(hum.Health/math.max(hum.MaxHealth,1),0,1)
            local bh = h * pct
            local hc = pct>0.5 and Color3.fromRGB(math.floor(255*(1-pct)*2),255,0) or Color3.fromRGB(255,math.floor(255*pct*2),0)
            e.HBG.Size=Vector2.new(3,h); e.HBG.Position=Vector2.new(mx-6,my); e.HBG.Visible=true
            e.HBar.Size=Vector2.new(3,bh); e.HBar.Position=Vector2.new(mx-6,my+(h-bh)); e.HBar.Color=hc; e.HBar.Visible=true
        else e.HBG.Visible=false; e.HBar.Visible=false end
    end

    for k in pairs(HSESP) do
        if not active[k] then KillESP(k) end
    end
end)

-- ================== FLAGS ==================
getgenv().AX_HyperShotLoaded        = true
getgenv().AX_HyperShotHandlesAimbot = true
getgenv().AX_HyperShotHandlesESP    = true
getgenv().AX_HyperShotHandlesSilent = true

warn("[AX HSX] ✅ HyperShot v4 LOADED")
