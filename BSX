--[[
    ANNOMALY X - Blox Strike Module (BSX) v19.0
    
    Reconstruido desde cero basado en la arquitectura real de BloxStrike
    
    Cambios principales vs v18:
    - Silent Aim implementado interceptando bullet_module._performRaycast
    - Detección de equipos usando carpetas del workspace (método real de BloxStrike)
    - ESP con todos los elementos (caja, vida, tracer, head dot, arma)
    - Legit Aimbot con jitter humano y suavizado dinámico
    - Sistema de wallbang con penetración por material
    - Anti-detección básica
]]

-- ============================================
-- ESPERAR CONFIGURACIÓN Y CARGA DEL JUEGO
-- ============================================
if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

-- Intentar activar flag interna para efectos visuales
pcall(function()
    settings():GetService("RenderSettings").AdornShadingAPI = true
end)

local Config = getgenv().AX_Config

-- ============================================
-- SERVICIOS
-- ============================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Workspace = workspace

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Función de mover ratón (proporcionada por el executor)
local mousemoverel = mousemoverel or (Input and Input.MouseMove) or function() end

-- ============================================
-- TABLA DE DATOS INTERNOS
-- ============================================
local ESP_Table = {}
local LockedPlayer = nil
local RandomPart = "Head"
local LastRandomSwitch = 0
local PositionHistory = {}
local HISTORY_SAMPLES = 5

-- Para Silent Aim
local OriginalPerformRaycast = nil
local BulletModuleLoaded = false

-- Para registrar disparos propios
if not _G.LocalShots then
    _G.LocalShots = {}
end

-- ============================================
-- LÍMITES DE PENETRACIÓN POR MATERIAL (WALLBANG)
-- ============================================
local MaterialLimits = {
    [Enum.Material.Plastic] = 7,
    [Enum.Material.Wood] = 5,
    [Enum.Material.WoodPlanks] = 5,
    [Enum.Material.Slate] = 3,
    [Enum.Material.Concrete] = 0.25,
    [Enum.Material.Brick] = 1.5,
    [Enum.Material.Metal] = 0.5,
    [Enum.Material.CorrodedMetal] = 1,
    [Enum.Material.DiamondPlate] = 0.3,
    [Enum.Material.SmoothPlastic] = 7,
    [Enum.Material.Glass] = 9999,
    [Enum.Material.Neon] = 9999,
    [Enum.Material.ForceField] = 9999,
    [Enum.Material.Fabric] = 8,
    [Enum.Material.Sand] = 4,
    [Enum.Material.Grass] = 6,
    [Enum.Material.Ice] = 3,
    [Enum.Material.Marble] = 1,
    [Enum.Material.Granite] = 0.5,
    [Enum.Material.Pebble] = 4,
    [Enum.Material.Cobblestone] = 2,
}

-- ============================================
-- DETECCIÓN DE EQUIPOS (MÉTODO REAL DE BLOXSTRIKE)
-- BloxStrike usa carpetas en workspace para separar equipos
-- Los personajes están dentro de carpetas como "CT", "T", 
-- "Terrorists", "CounterTerrorists", etc.
-- ============================================
local function isEnemy(player)
    -- Si TeamCheck está desactivado, todos son enemigos
    local useTeamCheck = false
    
    if Config.Aimbot and Config.Aimbot.TeamCheck then
        useTeamCheck = true
    end
    if Config.ESP and Config.ESP.TeamCheck then
        useTeamCheck = true
    end
    
    if not useTeamCheck then
        return true
    end
    
    local myChar = LocalPlayer.Character
    local theirChar = player.Character
    
    if not myChar or not theirChar then return true end
    
    -- Método principal: comparar carpeta padre en workspace
    local myParent = myChar.Parent
    local theirParent = theirChar.Parent
    
    if myParent and theirParent then
        local myParentName = myParent.Name
        local theirParentName = theirParent.Name
        
        -- Si ambos están en la misma carpeta, son compañeros
        if myParentName == theirParentName then
            return false -- Mismo equipo, NO es enemigo
        end
        
        -- Si están en carpetas diferentes (y no es workspace directo)
        if myParentName ~= "Workspace" and theirParentName ~= "Workspace" 
           and myParentName ~= workspace.Name and theirParentName ~= workspace.Name then
            return true -- Diferente equipo, SÍ es enemigo
        end
    end
    
    -- Fallback: atributo Team en el jugador
    local myTeam, theirTeam
    pcall(function() myTeam = LocalPlayer:GetAttribute("Team") end)
    pcall(function() theirTeam = player:GetAttribute("Team") end)
    
    if myTeam and theirTeam then
        return tostring(myTeam) ~= tostring(theirTeam)
    end
    
    -- Fallback: equipo de Roblox nativo
    pcall(function()
        if LocalPlayer.Team and player.Team then
            if LocalPlayer.Team == player.Team then
                return false
            end
        end
    end)
    
    -- Si no podemos determinar, asumir enemigo
    return true
end

-- ============================================
-- VALIDACIÓN DE JUGADOR
-- ============================================
local function isValidTarget(player)
    if not player or player == LocalPlayer then return false end
    
    local character = player.Character
    if not character then return false end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    local head = character:FindFirstChild("Head")
    
    if not root or not humanoid or not head then return false end
    if humanoid.Health <= 0 then return false end
    if not isEnemy(player) then return false end
    
    return true
end

-- ============================================
-- TRACKING DE VELOCIDAD (más preciso que AssemblyLinearVelocity)
-- ============================================
local function UpdatePositionHistory(player, position)
    if not PositionHistory[player] then
        PositionHistory[player] = {}
    end
    
    local history = PositionHistory[player]
    table.insert(history, {pos = position, time = tick()})
    
    while #history > HISTORY_SAMPLES do
        table.remove(history, 1)
    end
end

local function GetSmoothedVelocity(player)
    local history = PositionHistory[player]
    if not history or #history < 2 then
        return Vector3.zero
    end
    
    local newest = history[#history]
    local oldest = history[1]
    local dt = newest.time - oldest.time
    
    if dt <= 0.001 then
        return Vector3.zero
    end
    
    return (newest.pos - oldest.pos) / dt
end

-- ============================================
-- VERIFICACIÓN DE VISIBILIDAD (MULTI-RAYCAST)
-- ============================================
local function CanSee(targetPart, targetCharacter)
    if not targetPart or not targetCharacter then return false end
    
    local myChar = LocalPlayer.Character
    if not myChar then return false end
    
    local origin = Camera.CFrame.Position
    local targetPos = targetPart.Position
    local direction = targetPos - origin
    local distance = direction.Magnitude
    
    if distance < 3 then return true end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {myChar, Camera}
    params.IgnoreWater = true
    
    -- Raycast principal al centro
    local result = Workspace:Raycast(origin, direction.Unit * (distance - 0.3), params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetCharacter) then return true end
    
    -- Raycasts secundarios a los bordes para visibilidad parcial
    local offsets = {
        Vector3.new(0, 0.3, 0),
        Vector3.new(0, -0.3, 0),
        Vector3.new(0.3, 0, 0),
        Vector3.new(-0.3, 0, 0),
    }
    
    for _, offset in ipairs(offsets) do
        local offsetPos = targetPos + offset
        local offsetDir = offsetPos - origin
        local offsetResult = Workspace:Raycast(origin, offsetDir.Unit * (offsetDir.Magnitude - 0.3), params)
        if not offsetResult then return true end
        if offsetResult.Instance and offsetResult.Instance:IsDescendantOf(targetCharacter) then return true end
    end
    
    return false
end

-- ============================================
-- SISTEMA DE WALLBANG
-- Verifica si un disparo puede penetrar paredes
-- ============================================
local function GetPenetrationStats(origin, targetPos, weaponPenetration)
    local direction = (targetPos - origin)
    local distance = direction.Magnitude
    local dirUnit = direction.Unit
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    params.IgnoreWater = true
    
    local totalThickness = 0
    local hits = {}
    local currentOrigin = origin
    local maxIterations = 10
    
    for i = 1, maxIterations do
        local result = Workspace:Raycast(currentOrigin, dirUnit * distance, params)
        
        if not result then
            break -- Llegamos al objetivo sin más obstáculos
        end
        
        -- Si impactamos al personaje objetivo, éxito
        -- (esto se verifica fuera de esta función)
        
        local material = result.Material
        local materialLimit = MaterialLimits[material] or 1
        
        -- Raycast inverso para encontrar el lado de salida
        local reverseResult = Workspace:Raycast(targetPos, -dirUnit * distance, params)
        
        local wallThickness = 1 -- Default
        if reverseResult then
            wallThickness = (result.Position - reverseResult.Position).Magnitude
        end
        
        totalThickness = totalThickness + wallThickness
        
        if totalThickness > weaponPenetration then
            return false, hits, totalThickness -- Demasiado grueso
        end
        
        table.insert(hits, {
            Instance = result.Instance,
            Position = result.Position,
            Material = result.Material,
            Normal = result.Normal,
            Thickness = wallThickness
        })
        
        -- Avanzar más allá del obstáculo
        currentOrigin = result.Position + dirUnit * (wallThickness + 0.1)
        distance = (targetPos - currentOrigin).Magnitude
        
        if distance < 0.5 then break end
    end
    
    return true, hits, totalThickness
end

local function IsHitPossible(targetCharacter, origin, weaponPenetration, targetPos)
    local canPenetrate, hits, thickness = GetPenetrationStats(origin, targetPos, weaponPenetration)
    return canPenetrate
end

-- ============================================
-- OBTENER PARTE DE APUNTADO
-- ============================================
local function GetAimPart(character, boneOverride)
    if not character then return nil end
    
    local boneName = boneOverride or (Config.Aimbot and Config.Aimbot.TargetPart) or "Head"
    
    if boneName == "Random" then
        local t = tick()
        if t - LastRandomSwitch > (Config.Aimbot.RandomInterval or 0.5) then
            local options = {}
            for _, name in ipairs({"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LeftUpperArm", "RightUpperArm"}) do
                local part = character:FindFirstChild(name)
                if part and part:IsA("BasePart") then
                    table.insert(options, name)
                end
            end
            if #options > 0 then
                RandomPart = options[math.random(#options)]
            end
            LastRandomSwitch = t
        end
        boneName = RandomPart
    end
    
    local part = character:FindFirstChild(boneName)
    if part and part:IsA("BasePart") then return part end
    
    -- Fallbacks
    return character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

-- ============================================
-- OBTENER NOMBRE DEL ARMA EQUIPADA
-- ============================================
local function GetWeaponName(player)
    local weaponName = "Unknown"
    pcall(function()
        local attr = player:GetAttribute("CurrentEquipped")
        if attr then
            local s, decoded = pcall(function()
                return HttpService:JSONDecode(attr)
            end)
            if s and decoded and decoded.Name then
                weaponName = decoded.Name
            end
        end
    end)
    return weaponName
end

-- ============================================
-- OBTENER PENETRACIÓN DEL ARMA ACTUAL
-- ============================================
local function GetCurrentWeaponPenetration()
    local pen = 2 -- Default
    pcall(function()
        local attr = LocalPlayer:GetAttribute("CurrentEquipped")
        if attr then
            local s, decoded = pcall(function()
                return HttpService:JSONDecode(attr)
            end)
            if s and decoded then
                pen = decoded.Penetration or decoded.WallPen or 2
            end
        end
    end)
    return pen
end

-- ============================================
-- ESP - CREAR OBJETOS DE DIBUJO
-- ============================================
local function CreateESP(player)
    if ESP_Table[player] then return end
    
    local data = {}
    
    -- Caja exterior (outline)
    data.BoxOutline = Drawing.new("Square")
    data.BoxOutline.Thickness = 3
    data.BoxOutline.Filled = false
    data.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
    data.BoxOutline.Transparency = 0.5
    data.BoxOutline.Visible = false
    
    -- Caja principal
    data.Box = Drawing.new("Square")
    data.Box.Thickness = 1
    data.Box.Filled = false
    data.Box.Color = Color3.fromRGB(255, 50, 50)
    data.Box.Visible = false
    
    -- Nombre
    data.Name = Drawing.new("Text")
    data.Name.Size = 13
    data.Name.Center = true
    data.Name.Outline = true
    data.Name.Color = Color3.fromRGB(255, 255, 255)
    data.Name.Visible = false
    
    -- Barra de vida outline
    data.HealthBarOutline = Drawing.new("Square")
    data.HealthBarOutline.Thickness = 1
    data.HealthBarOutline.Filled = true
    data.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    data.HealthBarOutline.Transparency = 0.5
    data.HealthBarOutline.Visible = false
    
    -- Barra de vida
    data.HealthBar = Drawing.new("Square")
    data.HealthBar.Thickness = 1
    data.HealthBar.Filled = true
    data.HealthBar.Color = Color3.fromRGB(0, 255, 0)
    data.HealthBar.Visible = false
    
    -- Distancia
    data.DistanceText = Drawing.new("Text")
    data.DistanceText.Size = 13
    data.DistanceText.Center = true
    data.DistanceText.Outline = true
    data.DistanceText.Color = Color3.fromRGB(200, 200, 200)
    data.DistanceText.Visible = false
    
    -- Tracer (línea hacia el enemigo)
    data.Tracer = Drawing.new("Line")
    data.Tracer.Thickness = 1
    data.Tracer.Color = Color3.fromRGB(255, 255, 255)
    data.Tracer.Visible = false
    
    -- Head dot (círculo en la cabeza)
    data.HeadDot = Drawing.new("Circle")
    data.HeadDot.Thickness = 1
    data.HeadDot.Filled = true
    data.HeadDot.Color = Color3.fromRGB(255, 255, 255)
    data.HeadDot.Visible = false
    
    -- Arma equipada
    data.Weapon = Drawing.new("Text")
    data.Weapon.Size = 12
    data.Weapon.Center = true
    data.Weapon.Outline = true
    data.Weapon.Color = Color3.fromRGB(180, 180, 255)
    data.Weapon.Visible = false
    
    ESP_Table[player] = data
end

local function RemoveESP(player)
    local data = ESP_Table[player]
    if not data then return end
    
    for _, drawing in pairs(data) do
        pcall(function() drawing:Remove() end)
    end
    
    ESP_Table[player] = nil
end

local function HideESP(player)
    local data = ESP_Table[player]
    if not data then return end
    
    for _, drawing in pairs(data) do
        pcall(function() drawing.Visible = false end)
    end
end

-- ============================================
-- ESP - ACTUALIZAR CADA FRAME
-- ============================================
local function UpdateESP()
    if not Config.ESP or not Config.ESP.Enabled or not Config.ESP.Active then
        for p in pairs(ESP_Table) do
            HideESP(p)
        end
        return
    end
    
    local cam = Workspace.CurrentCamera
    if not cam then return end
    
    local currentFov = cam.FieldOfView or 70
    local viewportSize = cam.ViewportSize
    local activePlayers = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        
        activePlayers[player] = true
        
        -- Crear ESP si no existe
        if not ESP_Table[player] then
            CreateESP(player)
        end
        
        local data = ESP_Table[player]
        if not data then continue end
        
        -- Verificar si es objetivo válido
        if not isValidTarget(player) then
            HideESP(player)
            continue
        end
        
        -- Verificar TeamCheck específico de ESP
        if Config.ESP.TeamCheck and not isEnemy(player) then
            HideESP(player)
            continue
        end
        
        local character = player.Character
        local root = character:FindFirstChild("HumanoidRootPart")
        local head = character:FindFirstChild("Head")
        local humanoid = character:FindFirstChild("Humanoid")
        
        if not root or not head or not humanoid then
            HideESP(player)
            continue
        end
        
        -- Proyectar posición 3D a pantalla 2D
        local pos, vis = cam:WorldToViewportPoint(root.Position)
        
        if not vis or pos.Z <= 0 then
            HideESP(player)
            continue
        end
        
        -- Calcular tamaño de la caja basado en distancia
        local fovScale = 70 / currentFov
        local size = math.max((2000 * fovScale) / math.max(pos.Z, 1), 10)
        local boxWidth = size
        local boxHeight = size * 1.5
        
        -- Posición centrada de la caja
        local boxX = pos.X - boxWidth / 2
        local boxY = pos.Y - boxHeight / 2
        
        -- Color según visibilidad
        local isVisible = CanSee(head, character)
        local espColor = isVisible 
            and Color3.fromRGB(50, 255, 50)  -- Verde = visible
            or Color3.fromRGB(255, 50, 50)   -- Rojo = detrás de pared
        
        -- === DIBUJAR CAJA ===
        if Config.ESP.Boxes then
            data.BoxOutline.Size = Vector2.new(boxWidth + 2, boxHeight + 2)
            data.BoxOutline.Position = Vector2.new(boxX - 1, boxY - 1)
            data.BoxOutline.Visible = true
            
            data.Box.Size = Vector2.new(boxWidth, boxHeight)
            data.Box.Position = Vector2.new(boxX, boxY)
            data.Box.Color = espColor
            data.Box.Visible = true
        else
            data.Box.Visible = false
            data.BoxOutline.Visible = false
        end
        
        -- === DIBUJAR NOMBRE ===
        if Config.ESP.Names then
            data.Name.Text = player.DisplayName or player.Name
            data.Name.Position = Vector2.new(pos.X, boxY - 16)
            data.Name.Visible = true
        else
            data.Name.Visible = false
        end
        
        -- === DIBUJAR BARRA DE VIDA ===
        if Config.ESP.Boxes and humanoid then
            local healthPer = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
            local barFullHeight = boxHeight
            local barHeight = barFullHeight * healthPer
            
            -- Color: rojo -> verde según vida
            local healthColor = Color3.fromRGB(255, 0, 0):Lerp(Color3.fromRGB(0, 255, 0), healthPer)
            
            -- Fondo de la barra (a la izquierda de la caja)
            data.HealthBarOutline.Size = Vector2.new(4, barFullHeight)
            data.HealthBarOutline.Position = Vector2.new(boxX - 7, boxY)
            data.HealthBarOutline.Visible = true
            
            -- Barra de vida (crece de abajo hacia arriba)
            data.HealthBar.Size = Vector2.new(2, barHeight)
            data.HealthBar.Position = Vector2.new(boxX - 6, boxY + (barFullHeight - barHeight))
            data.HealthBar.Color = healthColor
            data.HealthBar.Visible = true
        else
            data.HealthBarOutline.Visible = false
            data.HealthBar.Visible = false
        end
        
        -- === DIBUJAR DISTANCIA ===
        if Config.ESP.Distance then
            local myChar = LocalPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myRoot then
                local dist = math.floor((myRoot.Position - root.Position).Magnitude)
                data.DistanceText.Text = dist .. "m"
                data.DistanceText.Position = Vector2.new(pos.X, boxY + boxHeight + 2)
                data.DistanceText.Visible = true
            else
                data.DistanceText.Visible = false
            end
        else
            data.DistanceText.Visible = false
        end
        
        -- === DIBUJAR TRACER ===
        if Config.ESP.Tracers then
            data.Tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y)
            data.Tracer.To = Vector2.new(pos.X, pos.Y)
            data.Tracer.Color = espColor
            data.Tracer.Visible = true
        else
            data.Tracer.Visible = false
        end
        
        -- === DIBUJAR HEAD DOT ===
        if Config.ESP.HeadDot then
            local headPos = cam:WorldToViewportPoint(head.Position)
            data.HeadDot.Position = Vector2.new(headPos.X, headPos.Y)
            data.HeadDot.Radius = math.max(size / 8, 3)
            data.HeadDot.Color = espColor
            data.HeadDot.Visible = true
        else
            data.HeadDot.Visible = false
        end
        
        -- === DIBUJAR ARMA ===
        if Config.ESP.Weapon then
            local weaponName = GetWeaponName(player)
            data.Weapon.Text = weaponName
            data.Weapon.Position = Vector2.new(pos.X, boxY + boxHeight + 16)
            data.Weapon.Visible = true
        else
            data.Weapon.Visible = false
        end
    end
    
    -- Ocultar ESP de jugadores que ya no están activos
    for player in pairs(ESP_Table) do
        if not activePlayers[player] then
            HideESP(player)
        end
    end
end

-- ============================================
-- LEGIT AIMBOT - MOVER RATÓN SUAVEMENTE
-- Con jitter humano y suavizado dinámico
-- ============================================
local function FindLegitTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil, nil end
    
    local mousePos = UserInputService:GetMouseLocation()
    local fov = (Config.Aimbot and Config.Aimbot.FOVRadius) or 150
    
    -- Aimlock: mantener objetivo bloqueado
    if Config.Aimbot.Method == "Aimlock" and LockedPlayer then
        if isValidTarget(LockedPlayer) then
            if Config.Aimbot.TeamCheck and not isEnemy(LockedPlayer) then
                LockedPlayer = nil
            else
                local aimPart = GetAimPart(LockedPlayer.Character)
                if aimPart then
                    if not Config.Aimbot.VisibleCheck or CanSee(aimPart, LockedPlayer.Character) then
                        local sp, on = cam:WorldToViewportPoint(aimPart.Position)
                        if on then return aimPart, LockedPlayer end
                    end
                end
            end
        else
            LockedPlayer = nil
        end
    end
    
    local bestPart, bestDist, bestPlayer = nil, fov, nil
    
    for _, player in ipairs(Players:GetPlayers()) do
        if not isValidTarget(player) then continue end
        if Config.Aimbot.TeamCheck and not isEnemy(player) then continue end
        
        local character = player.Character
        local boneName = (Config.Aimbot and Config.Aimbot.LegitBone) or "Head"
        local aimPart = GetAimPart(character, boneName)
        if not aimPart then continue end
        
        if Config.Aimbot.VisibleCheck and not CanSee(aimPart, character) then
            continue
        end
        
        local sp, on = cam:WorldToViewportPoint(aimPart.Position)
        if not on then continue end
        
        -- Distancia en píxeles desde el cursor al enemigo
        local mag = (Vector2.new(sp.X, sp.Y) - mousePos).Magnitude
        
        if mag < bestDist then
            bestPart = aimPart
            bestDist = mag
            bestPlayer = player
        end
    end
    
    if Config.Aimbot.Method == "Aimlock" and bestPlayer then
        LockedPlayer = bestPlayer
    end
    
    return bestPart, bestPlayer
end

local function PerformLegitAim(targetPart, targetPlayer)
    local cam = Workspace.CurrentCamera
    if not cam or not targetPart then return end
    
    local targetPos = targetPart.Position
    
    -- Predicción de movimiento
    if Config.Aimbot.Prediction and Config.Aimbot.Prediction > 0 and targetPlayer then
        UpdatePositionHistory(targetPlayer, targetPos)
        local velocity = GetSmoothedVelocity(targetPlayer)
        
        -- Fallback a AssemblyLinearVelocity
        if velocity.Magnitude < 0.5 then
            pcall(function()
                local v = targetPart.AssemblyLinearVelocity
                if v and v.Magnitude > 0.5 then
                    velocity = v
                end
            end)
        end
        
        if velocity.Magnitude > 0.5 then
            targetPos = targetPos + velocity * Config.Aimbot.Prediction
        end
    end
    
    local tPos, onScreen = cam:WorldToViewportPoint(targetPos)
    if not onScreen then return end
    
    local mPos = UserInputService:GetMouseLocation()
    
    local targetX = tPos.X - mPos.X
    local targetY = tPos.Y - mPos.Y
    local dist = math.sqrt(targetX * targetX + targetY * targetY)
    
    -- No mover si ya estamos muy cerca (previene jittering)
    if dist < 0.5 then return end
    
    -- Suavizado base
    local baseSmooth = math.max((Config.Aimbot and Config.Aimbot.Smoothness) or 10, 1)
    
    -- Suavizado dinámico: más rápido lejos, más preciso cerca
    local dynamicFactor = 1
    if dist > 100 then
        dynamicFactor = 0.5  -- Más rápido cuando lejos
    elseif dist < 30 then
        dynamicFactor = 1.5  -- Más lento cuando cerca (preciso)
    end
    
    local finalSmooth = baseSmooth * dynamicFactor
    
    -- Jitter humano para parecer natural
    local jitterX = math.random(-10, 10) / 10  -- -1.0 a 1.0
    local jitterY = math.random(-10, 10) / 10
    
    local moveX = (targetX / finalSmooth) + jitterX
    local moveY = (targetY / finalSmooth) + jitterY
    
    -- Clamp para evitar movimientos extremos
    moveX = math.clamp(moveX, -200, 200)
    moveY = math.clamp(moveY, -200, 200)
    
    if math.abs(moveX) > 0.1 or math.abs(moveY) > 0.1 then
        mousemoverel(moveX, moveY)
    end
end

-- ============================================
-- SILENT AIM - INTERCEPTAR SISTEMA DE DISPAROS
-- Esta es la parte más crítica y la que faltaba
-- ============================================

-- Función para encontrar el mejor objetivo para silent aim
local function getClosestSilentTarget()
    local mouseLocation = UserInputService:GetMouseLocation()
    local origin = Camera.CFrame.Position
    local fov = (Config.Aimbot and Config.Aimbot.SilentFOV) or (Config.Aimbot and Config.Aimbot.FOVRadius) or 150
    local targetMode = (Config.Aimbot and Config.Aimbot.SilentMode) or "Near Crosshair"
    
    local candidates = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if not isValidTarget(player) then continue end
        if Config.Aimbot.TeamCheck and not isEnemy(player) then continue end
        
        table.insert(candidates, player)
    end
    
    if #candidates == 0 then return nil, nil, nil end
    
    -- Ordenar según el modo
    if targetMode == "Highest Damage" then
        table.sort(candidates, function(a, b)
            local ha = a.Character and a.Character:FindFirstChild("Humanoid")
            local hb = b.Character and b.Character:FindFirstChild("Humanoid")
            local healthA = ha and ha.Health or 999
            local healthB = hb and hb.Health or 999
            return healthA < healthB -- Menos vida primero
        end)
    else
        -- Near Crosshair: ordenar por distancia en píxeles
        table.sort(candidates, function(a, b)
            local charA = a.Character
            local charB = b.Character
            if not charA or not charB then return false end
            
            local rootA = charA:FindFirstChild("HumanoidRootPart")
            local rootB = charB:FindFirstChild("HumanoidRootPart")
            if not rootA or not rootB then return false end
            
            local posA = Camera:WorldToViewportPoint(rootA.Position)
            local posB = Camera:WorldToViewportPoint(rootB.Position)
            
            local distA = (Vector2.new(posA.X, posA.Y) - mouseLocation).Magnitude
            local distB = (Vector2.new(posB.X, posB.Y) - mouseLocation).Magnitude
            
            return distA < distB
        end)
    end
    
    -- Parámetros de raycast para verificar impacto
    local hitParams = RaycastParams.new()
    hitParams.FilterType = Enum.RaycastFilterType.Exclude
    hitParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    hitParams.IgnoreWater = true
    
    local weaponPen = GetCurrentWeaponPenetration()
    
    -- Función para verificar si podemos impactar a un objetivo
    local function checkHitStatus(targetPos, targetCharacter)
        local dir = targetPos - origin
        local result = Workspace:Raycast(origin, dir, hitParams)
        
        if not result then
            return 2 -- Camino libre
        end
        
        if result.Instance and result.Instance:IsDescendantOf(targetCharacter) then
            return 2 -- Visible directamente, impacto confirmado
        end
        
        -- Verificar wallbang
        if Config.Aimbot.WallBang then
            if IsHitPossible(targetCharacter, origin, weaponPen, targetPos) then
                return 1 -- Posible con wallbang
            end
        end
        
        return 0 -- No es posible impactar
    end
    
    -- Buscar el mejor candidato
    for _, player in ipairs(candidates) do
        local character = player.Character
        local boneName = (Config.Aimbot and Config.Aimbot.SilentBone) 
            or (Config.Aimbot and Config.Aimbot.TargetPart) 
            or "Head"
        local targetPart = GetAimPart(character, boneName)
        if not targetPart then continue end
        
        -- Verificar que está dentro del FOV
        local sp, on = Camera:WorldToViewportPoint(targetPart.Position)
        if not on then continue end
        
        local screenDist = (Vector2.new(sp.X, sp.Y) - mouseLocation).Magnitude
        if screenDist > fov then continue end
        
        -- Verificar si podemos impactar
        local hitStatus = checkHitStatus(targetPart.Position, character)
        
        if hitStatus >= 1 then
            -- Multipoint: verificar múltiples puntos del cuerpo
            local bestPoint = targetPart.Position
            local bestHitStatus = hitStatus
            
            if Config.Aimbot.Multipoint then
                local partsToCheck = {"Head", "HumanoidRootPart", "UpperTorso", "Torso"}
                for _, partName in ipairs(partsToCheck) do
                    local part = character:FindFirstChild(partName)
                    if part then
                        local status = checkHitStatus(part.Position, character)
                        if status > bestHitStatus then
                            bestHitStatus = status
                            bestPoint = part.Position
                            targetPart = part
                        end
                    end
                end
            end
            
            return targetPart, bestPoint, player
        end
        
        -- Si VisibleCheck está activado y no es visible, saltar
        if Config.Aimbot.VisibleCheck and hitStatus == 0 then
            continue
        end
    end
    
    return nil, nil, nil
end

-- Interceptar el módulo de balas del juego
local function SetupSilentAim()
    local success, bullet_module = pcall(function()
        return require(game.ReplicatedStorage.Components.Weapon.Classes.Bullet)
    end)
    
    if not success or not bullet_module then
        warn("[BSX] No se pudo cargar el módulo de balas. Intentando ruta alternativa...")
        
        -- Intentar rutas alternativas
        local alternativePaths = {
            game.ReplicatedStorage:FindFirstChild("Components"),
            game.ReplicatedStorage:FindFirstChild("Modules"),
            game.ReplicatedStorage:FindFirstChild("Shared"),
        }
        
        for _, path in ipairs(alternativePaths) do
            if path then
                pcall(function()
                    for _, descendant in ipairs(path:GetDescendants()) do
                        if descendant:IsA("ModuleScript") and 
                           (descendant.Name:lower():find("bullet") or descendant.Name:lower():find("weapon")) then
                            bullet_module = require(descendant)
                            if bullet_module and bullet_module._performRaycast then
                                success = true
                            end
                        end
                    end
                end)
            end
            if success then break end
        end
    end
    
    if not success or not bullet_module then
        warn("[BSX] No se pudo interceptar el sistema de disparos. Silent Aim no disponible.")
        return false
    end
    
    if not bullet_module._performRaycast then
        warn("[BSX] Módulo encontrado pero sin _performRaycast. Silent Aim no disponible.")
        return false
    end
    
    -- Guardar la función original
    OriginalPerformRaycast = bullet_module._performRaycast
    
    -- Reemplazar con nuestra versión
    bullet_module._performRaycast = function(self, spreadAmount, ...)
        -- Si Silent Aim está desactivado, usar función original
        if not Config.Aimbot or not Config.Aimbot.SilentAim then
            return OriginalPerformRaycast(self, spreadAmount, ...)
        end
        
        -- Buscar objetivo
        local targetPart, targetPoint, targetPlayer = getClosestSilentTarget()
        
        if not targetPart or not targetPoint then
            -- Sin objetivo, disparo normal
            return OriginalPerformRaycast(self, spreadAmount, ...)
        end
        
        -- Obtener posición de origen del disparo
        local startPos = Camera.CFrame.Position
        pcall(function()
            if self and self.Origin then
                startPos = self.Origin
            end
        end)
        
        local targetPos = targetPoint or targetPart.Position
        
        -- Guardar CFrame original de la cámara
        local originalCamCFrame = Camera.CFrame
        
        -- Rotar temporalmente la cámara hacia el objetivo
        -- Necesario para que el juego calcule la dirección correcta
        Camera.CFrame = CFrame.new(startPos, targetPos)
        
        local direction = (targetPos - startPos).Unit
        
        -- Verificar si necesitamos wallbang hits
        local wbHits = {}
        if Config.Aimbot.WallBang then
            local canPen, hits = GetPenetrationStats(startPos, targetPos, GetCurrentWeaponPenetration())
            if canPen and hits then
                wbHits = hits
            end
        end
        
        -- Construir resultado falso de raycast
        local fakeResult = {
            Hits = wbHits,
            Ray = Ray.new(startPos, direction),
            Instance = targetPart,
            Position = targetPos,
            Material = targetPart.Material,
            Normal = Vector3.new(0, 1, 0),
            Distance = (targetPos - startPos).Magnitude,
            Direction = direction,
            Origin = startPos
        }
        
        -- Restaurar la cámara a su posición real
        Camera.CFrame = originalCamCFrame
        
        -- Registrar el disparo para otros sistemas
        table.insert(_G.LocalShots, {
            Position = targetPos,
            Time = tick()
        })
        
        -- Limpiar disparos viejos (más de 5 segundos)
        local currentTime = tick()
        local i = 1
        while i <= #_G.LocalShots do
            if currentTime - _G.LocalShots[i].Time > 5 then
                table.remove(_G.LocalShots, i)
            else
                i = i + 1
            end
        end
        
        -- Monitorear si el daño fue aplicado
        task.spawn(function()
            local targetHumanoid = targetPart.Parent and targetPart.Parent:FindFirstChild("Humanoid")
            if targetHumanoid then
                local initialHealth = targetHumanoid.Health
                local damageDetected = false
                local connectionHC
                
                connectionHC = targetHumanoid.HealthChanged:Connect(function(newHp)
                    if newHp < initialHealth then
                        local diff = initialHealth - newHp
                        damageDetected = true
                        
                        -- Log de daño
                        local isHeadshot = targetPart.Name == "Head"
                        -- Aquí puedes añadir hitmarker, damage text, etc.
                        
                        if connectionHC then
                            connectionHC:Disconnect()
                            connectionHC = nil
                        end
                    end
                end)
                
                -- Timeout: si después de 1.2s no se detectó daño, fue rechazado
                task.delay(1.2, function()
                    if connectionHC then
                        connectionHC:Disconnect()
                        connectionHC = nil
                    end
                    if not damageDetected then
                        -- Disparo rechazado por el servidor
                    end
                end)
            end
        end)
        
        return fakeResult
    end
    
    BulletModuleLoaded = true
    return true
end

-- ============================================
-- FOV CIRCLE (Círculo visual del FOV)
-- ============================================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.Filled = false
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Transparency = 0.5
FOVCircle.Visible = false
FOVCircle.NumSides = 64

local function UpdateFOVCircle()
    if Config.Aimbot and Config.Aimbot.ShowFOV and Config.Aimbot.Active then
        local mousePos = UserInputService:GetMouseLocation()
        local vp = Camera.ViewportSize
        
        if Config.Aimbot.Method == "Aimbot" then
            FOVCircle.Position = Vector2.new(vp.X / 2, vp.Y / 2)
        else
            FOVCircle.Position = mousePos
        end
        
        FOVCircle.Radius = Config.Aimbot.FOVRadius or 150
        FOVCircle.Visible = true
    else
        FOVCircle.Visible = false
    end
end

-- ============================================
-- LOOP PRINCIPAL (RenderStepped)
-- ============================================
RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    -- Actualizar ESP
    UpdateESP()
    
    -- Actualizar FOV Circle
    UpdateFOVCircle()
    
    -- Legit Aimbot (solo si Silent Aim está desactivado o como complemento)
    if Config.Aimbot and Config.Aimbot.Enabled and Config.Aimbot.Active then
        -- Solo activar con botón del ratón presionado
        local mousePressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
            or UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
        
        if mousePressed then
            local target, targetPlayer = FindLegitTarget()
            if target and targetPlayer then
                PerformLegitAim(target, targetPlayer)
            end
        else
            -- Si no se presiona el botón, desbloquear objetivo en modo Aimlock
            if Config.Aimbot.Method ~= "Aimlock" then
                -- En modo no-aimlock, no mantener target
            end
        end
    else
        if not (Config.Aimbot and Config.Aimbot.Active) then
            LockedPlayer = nil
        end
    end
    
    -- Actualizar historial de posiciones para todos los enemigos
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        local char = player.Character
        if char then
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then
                UpdatePositionHistory(player, root.Position)
            end
        end
    end
end)

-- ============================================
-- INICIALIZACIÓN
-- ============================================

-- Crear ESP para jugadores existentes
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        CreateESP(p)
    end
end

-- Nuevos jugadores
Players.PlayerAdded:Connect(function(p)
    CreateESP(p)
end)

-- Intentar configurar Silent Aim
task.spawn(function()
    task.wait(2) -- Esperar a que el juego cargue los módulos
    
    local silentSuccess = SetupSilentAim()
    if silentSuccess then
        print("[BSX] Silent Aim configurado exitosamente")
    else
        warn("[BSX] Silent Aim no disponible - solo Legit Aimbot funcionará")
    end
end)

-- ============================================
-- LIMPIEZA
-- ============================================
Players.PlayerRemoving:Connect(function(p)
    if LockedPlayer == p then LockedPlayer = nil end
    RemoveESP(p)
    PositionHistory[p] = nil
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    LockedPlayer = nil
end)

-- ============================================
-- SEÑALES DE CARGA
-- ============================================
getgenv().AX_BSXLoaded = true
getgenv().AX_BSX_HandlesAimbot = true
getgenv().AX_PF_HandlesESP = true

print("[BSX v19.0] Módulo cargado correctamente")
print("[BSX] ESP: Activo")
print("[BSX] Legit Aimbot: Activo")
print("[BSX] Silent Aim: " .. (BulletModuleLoaded and "Activo" or "Pendiente..."))
