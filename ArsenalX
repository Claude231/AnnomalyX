--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║           ANNOMALY X - Arsenal Module v4                  ║
    ║           Real Arsenal Silent Aim Method                  ║
    ║           Creator: ElSacaLeche                            ║
    ╚═══════════════════════════════════════════════════════════╝
    
    WHY PREVIOUS VERSIONS FAILED:
    
    Arsenal does NOT use Mouse.Hit or Mouse.Target for shooting.
    Arsenal's weapon system works like this:
    
    1. Player clicks MouseButton1
    2. Weapon module gets mouse screen position via 
       UserInputService:GetMouseLocation()
    3. Creates a Ray using Camera:ViewportPointToRay(mouseX, mouseY)
       or Camera:ScreenPointToRay(mouseX, mouseY)
    4. Fires workspace:FindPartOnRayWithIgnoreList() with that ray
    5. Sends hit result to server via RemoteEvent
    
    METHODS THAT ACTUALLY WORK (used by paid scripts):
    
    METHOD 1: Hook Camera:ViewportPointToRay / Camera:ScreenPointToRay
    - These are called by the weapon module to create the bullet ray
    - Return a Ray pointing at target instead of where mouse is
    - This is the PRIMARY method used by undetected paid scripts
    
    METHOD 2: Hook workspace:FindPartOnRayWithIgnoreList via hookfunction
    - Not via __namecall (Arsenal caches the function reference)
    - hookfunction on the actual method so even cached calls get hooked
    - Return the enemy part as the hit result
    
    METHOD 3: Hook workspace.Raycast via hookfunction  
    - Some Arsenal updates use modern Raycast instead of FindPartOnRay
    - Same principle: redirect the ray direction
    
    METHOD 4: __namecall as fallback
    - Catches any raycast calls not caught by direct hooks
    
    All methods combined = maximum compatibility across Arsenal updates
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local clonefunction = clonefunction or function(f) return f end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function(t, v)
    if make_writeable and not v then make_writeable(t) end
end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- AC HANDLING
-- ============================================

pcall(function()
    local oldKick = LocalPlayer.Kick
    if typeof(oldKick) == "function" then
        hookfunction(oldKick, newcclosure(function(self, ...)
            if self == LocalPlayer then return end
            return oldKick(self, ...)
        end))
    end
end)

pcall(function()
    local SC = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function() conn:Disable() end)
        end
    end
end)

-- ============================================
-- MOUSE BUTTON TRACKING
-- Only redirect when actually shooting
-- ============================================

local isMouseDown = false

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- TARGET FINDER
-- ============================================

local CurrentTarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, cam}
    local origin = cam.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end
    
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team 
            and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        -- Skip spawning players
        if character:FindFirstChildOfClass("ForceField") then continue end
        
        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end
        
        local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end
    
    return closest
end

-- ============================================
-- HELPER: Should we redirect?
-- Checks all conditions before redirecting
-- ============================================

local function ShouldRedirect()
    if not Config.Silent.Enabled then return false end
    if not Config.Silent.Active then return false end
    if not CurrentTarget then return false end
    if not CurrentTarget.Parent then return false end
    if math.random(1, 100) > Config.Silent.HitChance then return false end
    return true
end

-- ============================================
-- METHOD 1: HOOK Camera:ViewportPointToRay AND
--           Camera:ScreenPointToRay
-- 
-- This is THE method that paid Arsenal scripts use.
-- Arsenal's weapon module calls one of these to create
-- the bullet ray from the mouse position on screen.
-- We return a ray that points at the target instead.
-- ============================================

local viewportHooked = false
local screenPointHooked = false

-- Hook Camera:ViewportPointToRay
pcall(function()
    local original = Camera.ViewportPointToRay
    hookfunction(original, newcclosure(function(self, x, y, depth)
        if ShouldRedirect() and isMouseDown then
            local cam = Workspace.CurrentCamera
            if cam then
                local targetPos = CurrentTarget.Position
                local origin = cam.CFrame.Position
                local direction = (targetPos - origin).Unit
                -- Get the screen position of our target
                local targetScreen, onScreen = cam:WorldToViewportPoint(targetPos)
                if onScreen then
                    -- Call original with target's screen position
                    return original(self, targetScreen.X, targetScreen.Y, depth)
                end
            end
        end
        return original(self, x, y, depth)
    end))
    viewportHooked = true
end)

-- Hook Camera:ScreenPointToRay
pcall(function()
    local original = Camera.ScreenPointToRay
    hookfunction(original, newcclosure(function(self, x, y, depth)
        if ShouldRedirect() and isMouseDown then
            local cam = Workspace.CurrentCamera
            if cam then
                local targetPos = CurrentTarget.Position
                local targetScreen, onScreen = cam:WorldToScreenPoint(targetPos)
                if onScreen then
                    return original(self, targetScreen.X, targetScreen.Y, depth)
                end
            end
        end
        return original(self, x, y, depth)
    end))
    screenPointHooked = true
end)

-- ============================================
-- METHOD 2: HOOK FindPartOnRay DIRECTLY
-- Arsenal may cache the function reference, so
-- hookfunction catches it even when cached.
-- We redirect the ray direction to point at target.
-- ============================================

local findPartHooked = false

-- workspace:FindPartOnRay
pcall(function()
    local original = Workspace.FindPartOnRay
    hookfunction(original, newcclosure(function(self, ray, ...)
        if ShouldRedirect() and isMouseDown then
            if typeof(ray) == "Ray" then
                local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                local newRay = Ray.new(ray.Origin, newDir)
                return original(self, newRay, ...)
            end
        end
        return original(self, ray, ...)
    end))
    findPartHooked = true
end)

-- workspace:FindPartOnRayWithIgnoreList
pcall(function()
    local original = Workspace.FindPartOnRayWithIgnoreList
    hookfunction(original, newcclosure(function(self, ray, ignoreList, ...)
        if ShouldRedirect() and isMouseDown then
            if typeof(ray) == "Ray" then
                local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                local newRay = Ray.new(ray.Origin, newDir)
                return original(self, newRay, ignoreList, ...)
            end
        end
        return original(self, ray, ignoreList, ...)
    end))
end)

-- workspace:FindPartOnRayWithWhitelist
pcall(function()
    local original = Workspace.FindPartOnRayWithWhitelist
    hookfunction(original, newcclosure(function(self, ray, whitelist, ...)
        if ShouldRedirect() and isMouseDown then
            if typeof(ray) == "Ray" then
                local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                local newRay = Ray.new(ray.Origin, newDir)
                return original(self, newRay, whitelist, ...)
            end
        end
        return original(self, ray, whitelist, ...)
    end))
end)

-- ============================================
-- METHOD 3: HOOK workspace:Raycast DIRECTLY
-- Modern Arsenal versions might use Raycast API
-- ============================================

local raycastHooked = false

pcall(function()
    local original = Workspace.Raycast
    hookfunction(original, newcclosure(function(self, origin, direction, raycastParams)
        if ShouldRedirect() and isMouseDown then
            if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                local newDirection = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                return original(self, origin, newDirection, raycastParams)
            end
        end
        return original(self, origin, direction, raycastParams)
    end))
    raycastHooked = true
end)

-- ============================================
-- METHOD 4: __NAMECALL FALLBACK
-- Catches any calls not caught by direct hooks
-- Safe in Arsenal (no BACS)
-- ============================================

local namecallHooked = false

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if checkcaller() then
            return oldNamecall(self, ...)
        end
        
        if not ShouldRedirect() or not isMouseDown then
            return oldNamecall(self, ...)
        end
        
        if self == Workspace or self == workspace then
            if method == "Raycast" then
                local origin = args[1]
                local direction = args[2]
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                    args[2] = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                    return oldNamecall(self, unpack(args))
                end
            end
            
            if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" 
                or method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                    args[1] = Ray.new(ray.Origin, newDir)
                    return oldNamecall(self, unpack(args))
                end
            end
        end
        
        -- Camera ray methods via namecall
        if typeof(self) == "Instance" and self:IsA("Camera") then
            if method == "ViewportPointToRay" or method == "ScreenPointToRay" then
                local cam = Workspace.CurrentCamera
                if cam then
                    local targetPos = CurrentTarget.Position
                    local targetScreen, onScreen
                    if method == "ViewportPointToRay" then
                        targetScreen, onScreen = cam:WorldToViewportPoint(targetPos)
                    else
                        targetScreen, onScreen = cam:WorldToScreenPoint(targetPos)
                    end
                    if onScreen then
                        args[1] = targetScreen.X
                        args[2] = targetScreen.Y
                        return oldNamecall(self, unpack(args))
                    end
                end
            end
        end
        
        return oldNamecall(self, ...)
    end))
    namecallHooked = true
end)

-- ============================================
-- METHOD 5: Mouse.__index (LEGACY FALLBACK)
-- Only redirects Mouse.Hit and Mouse.UnitRay
-- Some Arsenal weapon code paths still check these
-- Does NOT hook Mouse.Target (causes weapon swap bug)
-- ============================================

local mouseHooked = false

pcall(function()
    local mt = getrawmetatable(Mouse)
    if mt then
        local oldIndex = mt.__index
        setreadonly(mt, false)
        
        mt.__index = newcclosure(function(self, key)
            if self == Mouse and ShouldRedirect() and isMouseDown then
                if key == "Hit" then
                    return CFrame.new(CurrentTarget.Position)
                elseif key == "UnitRay" then
                    local cam = Workspace.CurrentCamera
                    if cam then
                        local origin = cam.CFrame.Position
                        local dir = (CurrentTarget.Position - origin).Unit
                        return Ray.new(origin, dir)
                    end
                end
            end
            return oldIndex(self, key)
        end)
        
        setreadonly(mt, true)
        mouseHooked = true
    end
end)

-- ============================================
-- TARGET UPDATE
-- ============================================

RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentTarget = FindTarget()
    else
        CurrentTarget = nil
    end
end)

-- ============================================
-- CLEANUP
-- ============================================

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    Camera = Workspace.CurrentCamera
    CurrentTarget = nil
    isMouseDown = false
end)

-- ============================================
-- SIGNAL
-- ============================================
getgenv().AX_ArsenalLoaded = true

print("  ✅ ARSENAL MODULE v4 loaded")
print("  ✅ Method 1 - ViewportPointToRay: " .. tostring(viewportHooked))
print("  ✅ Method 1 - ScreenPointToRay: " .. tostring(screenPointHooked))
print("  ✅ Method 2 - FindPartOnRay: " .. tostring(findPartHooked))
print("  ✅ Method 3 - Raycast: " .. tostring(raycastHooked))
print("  ✅ Method 4 - __namecall: " .. tostring(namecallHooked))
print("  ✅ Method 5 - Mouse.__index: " .. tostring(mouseHooked))
print("  ✅ 5-layer silent aim active")
