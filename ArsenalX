--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║           ANNOMALY X - Arsenal Module v3                  ║
    ║           Remote Intercept + Camera Hook Method           ║
    ║           Creator: ElSacaLeche                            ║
    ╚═══════════════════════════════════════════════════════════╝
    
    ARSENAL SILENT AIM - HOW IT ACTUALLY WORKS:
    
    Arsenal's weapon system does NOT use Mouse.Hit for hit detection.
    Arsenal works like this:
    
    1. Player clicks to shoot
    2. Game reads Camera.CFrame.LookVector for aim direction
    3. Internal weapon module creates a ray from camera
    4. Sends hit data via RemoteEvent to server
    
    METHODS USED BY PAID SCRIPTS:
    
    Method 1: Hook Camera.CFrame via __index on workspace.CurrentCamera
              When the weapon module reads Camera.CFrame, return a CFrame
              that looks at the target. This redirects the bullet.
    
    Method 2: Hook the remote that sends hit data
              Intercept FireServer calls and replace the hit position/part
    
    Method 3: Hook workspace.Raycast and FindPartOnRay
              Arsenal's internal raycast gets redirected to target
    
    We use ALL THREE for maximum compatibility:
    - Camera CFrame redirect (primary - this is what paid scripts use)
    - Raycast hooks (secondary)  
    - Remote intercept (tertiary)
    
    IMPORTANT: Arsenal does NOT have BACS. Safe to use hookmetamethod.
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function(t, v) 
    if make_writeable and not v then make_writeable(t) end 
end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- ARSENAL AC HANDLING
-- ============================================

pcall(function()
    local oldKick = LocalPlayer.Kick
    if typeof(oldKick) == "function" then
        hookfunction(oldKick, newcclosure(function(self, ...)
            if self == LocalPlayer then return end
            return oldKick(self, ...)
        end))
    end
end)

pcall(function()
    local SC = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function() conn:Disable() end)
        end
    end
end)

-- ============================================
-- TARGET FINDER
-- ============================================

local CurrentTarget = nil
local CurrentTargetPosition = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, cam}
    local origin = cam.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end
    
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team 
            and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end
        
        local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end
    
    return closest
end

-- ============================================
-- METHOD 1: CAMERA CFRAME HOOK (PRIMARY)
-- This is the main method used by paid Arsenal scripts.
-- 
-- Arsenal's weapon modules read Camera.CFrame to get
-- the aim direction. By hooking __index on the Camera's
-- metatable (via game's __index), when Arsenal reads
-- Camera.CFrame or Camera.CFrame.LookVector during a
-- shot, we return a CFrame looking at target.
--
-- We only redirect when:
-- 1. Silent is active
-- 2. Mouse button is held (shooting)
-- 3. Target exists
-- ============================================

local isMouseDown = false
local cameraHooked = false

-- Track mouse state for knowing when player is shooting
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- Hook game's __index to intercept Camera.CFrame reads
pcall(function()
    local oldIndex
    oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
        -- Only intercept Camera CFrame reads
        if not checkcaller() and CurrentTarget and CurrentTarget.Parent then
            if Config.Silent.Enabled and Config.Silent.Active then
                if math.random(1, 100) <= Config.Silent.HitChance then
                    -- Camera.CFrame redirect
                    if self == Workspace.CurrentCamera then
                        if key == "CFrame" then
                            local cam = Workspace.CurrentCamera
                            local realCF = oldIndex(self, key)
                            -- Only redirect when shooting
                            if isMouseDown then
                                return CFrame.lookAt(realCF.Position, CurrentTarget.Position)
                            end
                            return realCF
                        elseif key == "ViewportSize" then
                            return oldIndex(self, key)
                        end
                    end
                    
                    -- Mouse property redirects (backup)
                    if self == Mouse then
                        if key == "Hit" then
                            return CFrame.new(CurrentTarget.Position)
                        elseif key == "Target" then
                            return CurrentTarget
                        elseif key == "UnitRay" then
                            local cam = Workspace.CurrentCamera
                            if cam then
                                local origin = cam.CFrame.Position
                                local dir = (CurrentTarget.Position - origin).Unit
                                return Ray.new(origin, dir)
                            end
                        elseif key == "X" then
                            local cam = Workspace.CurrentCamera
                            if cam then
                                local pos = cam:WorldToScreenPoint(CurrentTarget.Position)
                                return pos.X
                            end
                        elseif key == "Y" then
                            local cam = Workspace.CurrentCamera
                            if cam then
                                local pos = cam:WorldToScreenPoint(CurrentTarget.Position)
                                return pos.Y
                            end
                        end
                    end
                end
            end
        end
        return oldIndex(self, key)
    end))
    cameraHooked = true
end)

-- ============================================
-- METHOD 2: NAMECALL HOOK FOR RAYCASTS
-- Arsenal uses workspace:FindPartOnRay() internally
-- Hook these to redirect bullet trajectory
-- ============================================

local namecallHooked = false

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if checkcaller() then
            return oldNamecall(self, ...)
        end
        
        if not Config.Silent.Enabled or not Config.Silent.Active then
            return oldNamecall(self, ...)
        end
        
        if not CurrentTarget or not CurrentTarget.Parent then
            return oldNamecall(self, ...)
        end
        
        if math.random(1, 100) > Config.Silent.HitChance then
            return oldNamecall(self, ...)
        end
        
        -- Workspace raycast methods
        if self == Workspace or self == workspace then
            if method == "Raycast" then
                local origin = args[1]
                local direction = args[2]
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                    args[2] = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                    return oldNamecall(self, unpack(args))
                end
            end
            
            if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" 
                or method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" then
                    local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                    args[1] = Ray.new(ray.Origin, newDir)
                    return oldNamecall(self, unpack(args))
                end
            end
        end
        
        -- Remote intercept - modify hit data sent to server
        if typeof(self) == "Instance" then
            if self:IsA("RemoteEvent") or self:IsA("RemoteFunction") then
                if method == "FireServer" or method == "InvokeServer" then
                    -- Look through args for Vector3/CFrame that could be hit position
                    for i, arg in ipairs(args) do
                        if typeof(arg) == "Vector3" then
                            -- Check if this looks like a position (near a player)
                            local cam = Workspace.CurrentCamera
                            if cam then
                                local camPos = cam.CFrame.Position
                                local dist = (arg - camPos).Magnitude
                                -- If it's a reasonable shooting distance
                                if dist > 5 and dist < 2000 then
                                    args[i] = CurrentTarget.Position
                                end
                            end
                        elseif typeof(arg) == "CFrame" then
                            local cam = Workspace.CurrentCamera
                            if cam then
                                local dist = (arg.Position - cam.CFrame.Position).Magnitude
                                if dist > 5 and dist < 2000 then
                                    args[i] = CFrame.new(CurrentTarget.Position)
                                end
                            end
                        end
                    end
                    return oldNamecall(self, unpack(args))
                end
            end
        end
        
        return oldNamecall(self, ...)
    end))
    namecallHooked = true
end)

-- ============================================
-- METHOD 3: REMOTE SPY - Find Arsenal's specific remotes
-- Arsenal sends weapon fire data through specific remotes
-- ============================================

local arsenalRemoteHooked = false

task.spawn(function()
    task.wait(2) -- Wait for game to load
    
    pcall(function()
        -- Arsenal commonly uses remotes in ReplicatedStorage
        local RS = cloneref(game:GetService("ReplicatedStorage"))
        
        -- Look for weapon-related remotes
        local function hookRemote(remote)
            if not remote:IsA("RemoteEvent") and not remote:IsA("RemoteFunction") then return end
            
            local remoteName = remote.Name:lower()
            -- Arsenal weapon remotes often have these names
            local weaponKeywords = {"fire", "shoot", "hit", "damage", "weapon", "gun", "bullet"}
            
            local isWeaponRemote = false
            for _, keyword in ipairs(weaponKeywords) do
                if remoteName:find(keyword) then
                    isWeaponRemote = true
                    break
                end
            end
            
            if isWeaponRemote and remote:IsA("RemoteEvent") then
                local oldFire = remote.FireServer
                hookfunction(oldFire, newcclosure(function(self, ...)
                    if Config.Silent.Enabled and Config.Silent.Active and CurrentTarget and CurrentTarget.Parent then
                        if math.random(1, 100) <= Config.Silent.HitChance then
                            local args = {...}
                            for i, arg in ipairs(args) do
                                if typeof(arg) == "Vector3" then
                                    args[i] = CurrentTarget.Position
                                elseif typeof(arg) == "CFrame" then
                                    args[i] = CFrame.new(CurrentTarget.Position)
                                elseif typeof(arg) == "Instance" and arg:IsA("BasePart") then
                                    args[i] = CurrentTarget
                                end
                            end
                            return oldFire(self, unpack(args))
                        end
                    end
                    return oldFire(self, ...)
                end))
                arsenalRemoteHooked = true
            end
        end
        
        -- Hook existing remotes
        for _, child in ipairs(RS:GetDescendants()) do
            pcall(function() hookRemote(child) end)
        end
        
        -- Hook new remotes
        RS.DescendantAdded:Connect(function(child)
            task.wait(0.1)
            pcall(function() hookRemote(child) end)
        end)
    end)
end)

-- ============================================
-- TARGET UPDATE
-- ============================================

RunService.Heartbeat:Connect(function()
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentTarget = FindTarget()
    else
        CurrentTarget = nil
    end
end)

-- ============================================
-- CLEANUP
-- ============================================

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    CurrentTarget = nil
    isMouseDown = false
end)

-- ============================================
-- SIGNAL
-- ============================================
getgenv().AX_ArsenalLoaded = true

print("  ✅ ARSENAL MODULE v3 loaded")
print("  ✅ Camera CFrame hook: " .. tostring(cameraHooked))
print("  ✅ Namecall hook: " .. tostring(namecallHooked))
print("  ✅ Remote spy: scanning...")
print("  ✅ Triple-layer silent aim active")
