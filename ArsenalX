--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║           ANNOMALY X - Arsenal Module v5                  ║
    ║           Real Method - Remote Intercept + GC Scan        ║
    ║           Creator: ElSacaLeche                            ║
    ╚═══════════════════════════════════════════════════════════╝
    
    RESEARCH RESULTS:
    
    Arsenal's shooting system works like this:
    
    1. Client clicks to shoot
    2. Client-side weapon module does a local raycast
    3. Client sends hit data to server via a specific RemoteEvent
    4. The remote call includes: hit part, hit position, etc.
    5. Server validates with generous margins
    
    WHAT ACTUALLY WORKS (verified from working scripts):
    
    The real method is finding Arsenal's network module/remote
    and intercepting the data sent to the server. The client
    tells the server "I hit this part at this position" and
    the server trusts it within reasonable bounds.
    
    Working scripts find the remote by:
    1. Scanning getgc() for the Fire/Shoot function
    2. Scanning ReplicatedStorage for the weapon framework
    3. Hooking __namecall on RemoteEvent:FireServer
    
    Arsenal's main remote is typically found through the
    weapon framework modules in ReplicatedStorage.
    
    The key insight: Arsenal's hit registration is CLIENT-SIDED.
    The client decides what it hit, the server just validates
    that the hit is physically possible (distance, angle, etc.)
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local clonefunction = clonefunction or function(f) return f end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function(t, v)
    if make_writeable and not v then make_writeable(t) end
end
local getupvalue = debug.getupvalue or getupvalue
local getupvalues = debug.getupvalues or getupvalues
local getconstants = debug.getconstants or getconstants
local getinfo = debug.getinfo or getinfo

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- AC HANDLING (Light - Arsenal AC is not heavy)
-- ============================================

pcall(function()
    local oldKick = LocalPlayer.Kick
    if typeof(oldKick) == "function" then
        hookfunction(oldKick, newcclosure(function(self, ...)
            if self == LocalPlayer then return end
            return oldKick(self, ...)
        end))
    end
end)

pcall(function()
    local SC = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function() conn:Disable() end)
        end
    end
end)

-- ============================================
-- MOUSE TRACKING
-- ============================================

local isMouseDown = false

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        isMouseDown = false
    end
end)

-- ============================================
-- TARGET FINDER
-- ============================================

local CurrentTarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, cam}
    local origin = cam.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end
    
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team 
            and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        if character:FindFirstChildOfClass("ForceField") then continue end
        
        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end
        
        local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end
    
    return closest
end

-- ============================================
-- HELPER
-- ============================================

local function ShouldRedirect()
    return Config.Silent.Enabled 
        and Config.Silent.Active 
        and CurrentTarget 
        and CurrentTarget.Parent 
        and math.random(1, 100) <= Config.Silent.HitChance
end

-- ============================================
-- ARSENAL REMOTE FINDER
-- Find the actual remote Arsenal uses for hit reg
-- Multiple search methods for compatibility
-- ============================================

local ArsenalRemote = nil
local ArsenalNetwork = nil

-- Method A: Search ReplicatedStorage for known remote patterns
local function FindRemoteInStorage()
    local found = nil
    
    -- Arsenal commonly uses these structures
    local searchPaths = {
        ReplicatedStorage:FindFirstChild("MainEvent"),
        ReplicatedStorage:FindFirstChild("Event"),
        ReplicatedStorage:FindFirstChild("Replicate"),
        ReplicatedStorage:FindFirstChild("GameEvent"),
        ReplicatedStorage:FindFirstChild("WeaponEvent"),
        ReplicatedStorage:FindFirstChild("Network"),
        ReplicatedStorage:FindFirstChild("Bridge"),
        ReplicatedStorage:FindFirstChild("Remotes"),
        ReplicatedStorage:FindFirstChild("Events"),
    }
    
    for _, obj in ipairs(searchPaths) do
        if obj then
            if obj:IsA("RemoteEvent") then
                found = obj
                break
            elseif obj:IsA("Folder") or obj:IsA("Model") then
                for _, child in ipairs(obj:GetChildren()) do
                    if child:IsA("RemoteEvent") then
                        found = child
                        break
                    end
                end
            end
        end
        if found then break end
    end
    
    -- Deep search if not found
    if not found then
        for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
            if obj:IsA("RemoteEvent") then
                local name = obj.Name:lower()
                if name:find("event") or name:find("main") or name:find("network")
                    or name:find("remote") or name:find("replicate") or name:find("fire")
                    or name:find("weapon") or name:find("gun") or name:find("shoot")
                    or name:find("hit") or name:find("damage") then
                    found = obj
                    break
                end
            end
        end
    end
    
    return found
end

-- Method B: Use getgc to find the remote reference from game scripts
local function FindRemoteViaGC()
    if not getgc then return nil end
    
    local found = nil
    
    pcall(function()
        for _, v in ipairs(getgc(true)) do
            if typeof(v) == "table" then
                pcall(function()
                    for key, val in pairs(v) do
                        if typeof(val) == "Instance" and val:IsA("RemoteEvent") then
                            if val:IsDescendantOf(ReplicatedStorage) then
                                local keyStr = tostring(key):lower()
                                if keyStr:find("event") or keyStr:find("remote") 
                                    or keyStr:find("network") or keyStr:find("fire")
                                    or keyStr:find("main") or keyStr:find("replicate") then
                                    found = val
                                end
                            end
                        end
                    end
                end)
            end
            if found then break end
        end
    end)
    
    -- Also search for the network/weapon module table
    if not found then
        pcall(function()
            for _, v in ipairs(getgc(true)) do
                if typeof(v) == "table" then
                    pcall(function()
                        -- Look for tables that have fire/shoot functions and remote references
                        local hasFireFunc = rawget(v, "Fire") or rawget(v, "fire") 
                            or rawget(v, "Shoot") or rawget(v, "shoot")
                            or rawget(v, "Send") or rawget(v, "send")
                        local hasRemote = rawget(v, "Remote") or rawget(v, "remote")
                            or rawget(v, "Event") or rawget(v, "event")
                            or rawget(v, "MainEvent") or rawget(v, "RemoteEvent")
                        
                        if hasFireFunc and typeof(hasFireFunc) == "function" then
                            ArsenalNetwork = v
                        end
                        
                        if hasRemote and typeof(hasRemote) == "Instance" 
                            and hasRemote:IsA("RemoteEvent") then
                            found = hasRemote
                        end
                    end)
                end
                if found then break end
            end
        end)
    end
    
    return found
end

-- Method C: Monitor remote traffic to identify the shooting remote
local remoteFireCounts = {}
local monitorConnection = nil

local function StartRemoteMonitor()
    if not hookmetamethod then return end
    
    -- We'll track which remotes fire when mouse is clicked
    -- The one that fires on click is likely the weapon remote
    monitorConnection = true -- flag
end

-- Execute search
task.spawn(function()
    task.wait(3) -- Wait for Arsenal to fully load
    
    ArsenalRemote = FindRemoteInStorage()
    if ArsenalRemote then
        print("  ✅ Arsenal Remote found (Storage): " .. ArsenalRemote:GetFullName())
    else
        ArsenalRemote = FindRemoteViaGC()
        if ArsenalRemote then
            print("  ✅ Arsenal Remote found (GC): " .. ArsenalRemote:GetFullName())
        else
            print("  ⚠ Arsenal Remote not found - using fallback methods")
        end
    end
end)

-- ============================================
-- MAIN HOOK: __namecall
-- This is the core of the silent aim.
-- We intercept ALL remote FireServer calls and
-- raycast calls. When the weapon system sends
-- hit data to the server, we modify it.
--
-- Arsenal's FireServer typically sends:
-- remote:FireServer("Damage", hitPart, hitPos, ...)
-- remote:FireServer(hitPart, hitPos, normal, ...)
-- Or variations of these
--
-- We detect the pattern and replace hit data
-- ============================================

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if checkcaller() then
        return oldNamecall(self, ...)
    end
    
    if not ShouldRedirect() then
        return oldNamecall(self, ...)
    end
    
    -- ============================================
    -- INTERCEPT REMOTE CALLS (Primary method)
    -- When Arsenal fires a remote with hit data,
    -- replace the hit part and position
    -- ============================================
    
    if method == "FireServer" and typeof(self) == "Instance" and self:IsA("RemoteEvent") then
        -- Only intercept when shooting (mouse down)
        if isMouseDown then
            local modified = false
            local newArgs = {unpack(args)}
            
            for i, arg in ipairs(newArgs) do
                -- Replace Instance arguments that are BaseParts (hit parts)
                -- but NOT the local player's parts
                if typeof(arg) == "Instance" and arg:IsA("BasePart") then
                    local isLocalPart = false
                    if LocalPlayer.Character then
                        isLocalPart = arg:IsDescendantOf(LocalPlayer.Character)
                    end
                    if not isLocalPart then
                        newArgs[i] = CurrentTarget
                        modified = true
                    end
                end
                
                -- Replace Vector3 arguments that look like hit positions
                -- (not tiny vectors which might be normals/directions)
                if typeof(arg) == "Vector3" then
                    local magnitude = arg.Magnitude
                    if magnitude > 10 then
                        -- This is likely a world position, replace with target pos
                        newArgs[i] = CurrentTarget.Position
                        modified = true
                    end
                end
                
                -- Replace CFrame arguments
                if typeof(arg) == "CFrame" then
                    local magnitude = arg.Position.Magnitude
                    if magnitude > 10 then
                        newArgs[i] = CFrame.new(CurrentTarget.Position)
                        modified = true
                    end
                end
            end
            
            if modified then
                return oldNamecall(self, unpack(newArgs))
            end
        end
    end
    
    -- ============================================
    -- INTERCEPT RAYCAST CALLS
    -- Redirect any raycasts to point at target
    -- ============================================
    
    if (self == Workspace or self == workspace) and isMouseDown then
        if method == "Raycast" then
            local origin = args[1]
            local direction = args[2]
            if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                args[2] = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                return oldNamecall(self, unpack(args))
            end
        end
        
        if method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" 
            or method == "FindPartOnRayWithWhitelist" then
            local ray = args[1]
            if typeof(ray) == "Ray" then
                local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
                args[1] = Ray.new(ray.Origin, newDir)
                return oldNamecall(self, unpack(args))
            end
        end
    end
    
    -- ============================================
    -- INTERCEPT CAMERA RAY METHODS
    -- Redirect ViewportPointToRay / ScreenPointToRay
    -- ============================================
    
    if typeof(self) == "Instance" and self:IsA("Camera") and isMouseDown then
        if method == "ViewportPointToRay" or method == "ScreenPointToRay" then
            local cam = Workspace.CurrentCamera
            if cam then
                local targetPos = CurrentTarget.Position
                local targetScreen, onScreen
                if method == "ViewportPointToRay" then
                    targetScreen, onScreen = cam:WorldToViewportPoint(targetPos)
                else
                    targetScreen, onScreen = cam:WorldToScreenPoint(targetPos)
                end
                if onScreen then
                    args[1] = targetScreen.X
                    args[2] = targetScreen.Y
                    return oldNamecall(self, unpack(args))
                end
            end
        end
    end
    
    return oldNamecall(self, ...)
end))

-- ============================================
-- DIRECT FUNCTION HOOKS (catches cached refs)
-- ============================================

-- Hook FindPartOnRayWithIgnoreList directly
pcall(function()
    local original = Workspace.FindPartOnRayWithIgnoreList
    hookfunction(original, newcclosure(function(self, ray, ...)
        if ShouldRedirect() and isMouseDown and typeof(ray) == "Ray" then
            local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
            return original(self, Ray.new(ray.Origin, newDir), ...)
        end
        return original(self, ray, ...)
    end))
end)

-- Hook FindPartOnRay directly
pcall(function()
    local original = Workspace.FindPartOnRay
    hookfunction(original, newcclosure(function(self, ray, ...)
        if ShouldRedirect() and isMouseDown and typeof(ray) == "Ray" then
            local newDir = (CurrentTarget.Position - ray.Origin).Unit * ray.Direction.Magnitude
            return original(self, Ray.new(ray.Origin, newDir), ...)
        end
        return original(self, ray, ...)
    end))
end)

-- Hook Raycast directly
pcall(function()
    local original = Workspace.Raycast
    hookfunction(original, newcclosure(function(self, origin, direction, ...)
        if ShouldRedirect() and isMouseDown then
            if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                local newDir = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                return original(self, origin, newDir, ...)
            end
        end
        return original(self, origin, direction, ...)
    end))
end)

-- Hook Camera:ViewportPointToRay directly
pcall(function()
    local cam = Workspace.CurrentCamera
    if cam then
        local original = cam.ViewportPointToRay
        hookfunction(original, newcclosure(function(self, x, y, ...)
            if ShouldRedirect() and isMouseDown then
                local c = Workspace.CurrentCamera
                if c then
                    local tScreen, onScreen = c:WorldToViewportPoint(CurrentTarget.Position)
                    if onScreen then
                        return original(self, tScreen.X, tScreen.Y, ...)
                    end
                end
            end
            return original(self, x, y, ...)
        end))
    end
end)

-- Hook Camera:ScreenPointToRay directly
pcall(function()
    local cam = Workspace.CurrentCamera
    if cam then
        local original = cam.ScreenPointToRay
        hookfunction(original, newcclosure(function(self, x, y, ...)
            if ShouldRedirect() and isMouseDown then
                local c = Workspace.CurrentCamera
                if c then
                    local tScreen, onScreen = c:WorldToScreenPoint(CurrentTarget.Position)
                    if onScreen then
                        return original(self, tScreen.X, tScreen.Y, ...)
                    end
                end
            end
            return original(self, x, y, ...)
        end))
    end
end)

-- ============================================
-- Mouse.__index (Hit + UnitRay only, no Target)
-- ============================================

pcall(function()
    local mt = getrawmetatable(Mouse)
    if mt then
        local oldIndex = mt.__index
        setreadonly(mt, false)
        mt.__index = newcclosure(function(self, key)
            if self == Mouse and ShouldRedirect() and isMouseDown then
                if key == "Hit" then
                    return CFrame.new(CurrentTarget.Position)
                elseif key == "UnitRay" then
                    local cam = Workspace.CurrentCamera
                    if cam then
                        local origin = cam.CFrame.Position
                        local dir = (CurrentTarget.Position - origin).Unit
                        return Ray.new(origin, dir)
                    end
                end
            end
            return oldIndex(self, key)
        end)
        setreadonly(mt, true)
    end
end)

-- ============================================
-- TARGET UPDATE
-- ============================================

RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentTarget = FindTarget()
    else
        CurrentTarget = nil
    end
end)

-- ============================================
-- CLEANUP
-- ============================================

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    Camera = Workspace.CurrentCamera
    CurrentTarget = nil
    isMouseDown = false
end)

-- ============================================
-- SIGNAL
-- ============================================
getgenv().AX_ArsenalLoaded = true

print("  ✅ ARSENAL MODULE v5 loaded")
print("  ✅ Remote intercept: FireServer hook active")
print("  ✅ Direct hooks: FindPartOnRay, Raycast, Camera rays")
print("  ✅ __namecall: All methods covered")
print("  ✅ Mouse.__index: Hit + UnitRay")
print("  ✅ Full coverage silent aim active")
