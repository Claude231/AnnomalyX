--[[
    ╔═══════════════════════════════════════════════════════════╗
    ║           ANNOMALY X - Arsenal Module v7                  ║
    ║           Real Method - Based on Arsonia Analysis          ║
    ║           Creator: ElSacaLeche                            ║
    ╚═══════════════════════════════════════════════════════════╝
    
    HOW ARSENAL ACTUALLY WORKS (from Arsonia source):
    
    HITSCAN WEAPONS:
    - Arsenal calls workspace:FindPartOnRayWithIgnoreList()
    - The ray origin is Camera.CFrame.Position (with offset)
    - The ray direction is Camera.CFrame.LookVector * range
    - We identify weapon raycasts by checking if origin == camera pos
    - We redirect the ray to point at our target
    
    PROJECTILE WEAPONS:
    - Arsenal calls CreateProjectile in ReplicatedStorage.Modules.ClientFunctions
    - Args: playerName, projectileType, speed, targetPos, originCFrame
    - We hook this function and redirect targetPos + originCFrame
    
    REMOTES:
    - ReplicatedStorage.Events.HitPart - hit registration
    - ReplicatedStorage.Events.Burn - weapon damage
    - ReplicatedStorage.Events.CreateProjectile - projectile creation  
    - ReplicatedStorage.Events.ControlTurn - player rotation
    
    CLIENT SCRIPTS:
    - PlayerGui.GUI.Client - main client script
    - PlayerGui.GUI.Client.Functions.Weapons - weapon functions module
    - ReplicatedStorage.Modules.ClientFunctions - shared functions
    - ReplicatedStorage.Modules.Spread - spread calculation
    
    WEAPON DATA:
    - ReplicatedStorage.Weapons - all weapon objects
]]

if not getgenv().AX_Config then
    repeat task.wait() until getgenv().AX_Config
end

local Config = getgenv().AX_Config

local cloneref = cloneref or function(o) return o end
local newcclosure = newcclosure or function(f) return f end
local hookfunction = hookfunction or replaceclosure or detour_function
local hookmetamethod = hookmetamethod
local getnamecallmethod = getnamecallmethod or get_namecall_method
local checkcaller = checkcaller or function() return false end
local getrawmetatable = getrawmetatable
local setreadonly = setreadonly or function(t, v)
    if make_writeable and not v then make_writeable(t) end
end

local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local Workspace = cloneref(game:GetService("Workspace"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
local Camera = Workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- ============================================
-- KICK PROTECTION
-- ============================================

pcall(function()
    local oldKick = LocalPlayer.Kick
    if typeof(oldKick) == "function" then
        hookfunction(oldKick, newcclosure(function(self, ...)
            if self == LocalPlayer then return end
            return oldKick(self, ...)
        end))
    end
end)

pcall(function()
    local SC = cloneref(game:GetService("ScriptContext"))
    if getconnections then
        for _, conn in ipairs(getconnections(SC.Error)) do
            pcall(function() conn:Disable() end)
        end
    end
end)

-- ============================================
-- TARGET FINDER
-- ============================================

local CurrentTarget = nil

local function IsVisible(targetPart)
    if not targetPart then return false end
    local character = LocalPlayer.Character
    if not character then return true end
    local cam = Workspace.CurrentCamera
    if not cam then return true end
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character, cam}
    local origin = cam.CFrame.Position
    local direction = targetPart.Position - origin
    local result = Workspace:Raycast(origin, direction, params)
    if result then return result.Instance:IsDescendantOf(targetPart.Parent) end
    return true
end

local function GetTargetPart(character, setting)
    if not character then return nil end
    local parts = {"Head", "HumanoidRootPart", "UpperTorso", "Torso", "LowerTorso"}
    if setting == "Random" then
        local valid = {}
        for _, name in ipairs(parts) do
            local p = character:FindFirstChild(name)
            if p then table.insert(valid, p) end
        end
        if #valid > 0 then return valid[math.random(1, #valid)] end
    end
    return character:FindFirstChild(setting)
        or character:FindFirstChild("Head")
        or character:FindFirstChild("HumanoidRootPart")
        or character:FindFirstChild("UpperTorso")
        or character:FindFirstChild("Torso")
end

local function FindTarget()
    local cam = Workspace.CurrentCamera
    if not cam then return nil end
    
    local closest = nil
    local closestDist = Config.FOV.Enabled and Config.FOV.Radius or math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if Config.Silent.TeamCheck and player.Team and LocalPlayer.Team
            and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        if character:FindFirstChildOfClass("ForceField") then continue end
        
        local part = GetTargetPart(character, Config.Silent.TargetPart)
        if not part then continue end
        
        if Config.Silent.VisibleCheck and not IsVisible(part) then continue end
        
        local screenPos, onScreen = cam:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = part
        end
    end
    
    return closest
end

-- ============================================
-- HELPER: Extract origin position from a Ray
-- Arsenal creates rays from camera position
-- This is how Arsonia identifies weapon raycasts
-- ============================================

local function GetRayOrigin(ray)
    if typeof(ray) == "Ray" then
        return ray.Origin
    end
    return nil
end

local function IsWeaponRaycast(rayOrigin)
    -- Arsenal weapon raycasts originate from camera position
    -- with a Y offset of +1.5 + CameraOffset.Y from HRP
    local cam = Workspace.CurrentCamera
    if not cam then return false end
    
    local character = LocalPlayer.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local camOffset = humanoid and humanoid.CameraOffset.Y or 0
    
    -- Arsenal uses: HRP.Position + Vector3.new(0, 1.5 + CameraOffset.Y, 0)
    -- or Camera.CFrame.Position directly
    local expectedOrigin1 = cam.CFrame.Position
    local expectedOrigin2 = hrp.Position + Vector3.new(0, 1.5 + camOffset, 0)
    
    local dist1 = (rayOrigin - expectedOrigin1).Magnitude
    local dist2 = (rayOrigin - expectedOrigin2).Magnitude
    
    -- Allow small margin for floating point
    return dist1 < 2 or dist2 < 2
end

local function ShouldRedirect()
    return Config.Silent.Enabled
        and Config.Silent.Active
        and CurrentTarget
        and CurrentTarget.Parent
        and math.random(1, 100) <= Config.Silent.HitChance
end

-- ============================================
-- METHOD 1: __NAMECALL HOOK
-- Primary method - intercepts FindPartOnRayWithIgnoreList
-- This is exactly what Arsonia does
--
-- Arsenal's weapon system calls:
-- workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
-- where ray origin = camera position or HRP + offset
--
-- We check if the ray origin matches camera/player position
-- to confirm it's a weapon raycast (not a visibility check
-- or other game raycast), then redirect to target
-- ============================================

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if checkcaller() then
        return oldNamecall(self, ...)
    end
    
    -- ============================================
    -- HITSCAN SILENT AIM
    -- Intercept FindPartOnRayWithIgnoreList
    -- This is THE method Arsenal uses for bullet raycasts
    -- ============================================
    
    if method == "FindPartOnRayWithIgnoreList" then
        if ShouldRedirect() then
            local ray = args[1]
            if typeof(ray) == "Ray" then
                -- Check if this is a weapon raycast (origin = camera pos)
                if IsWeaponRaycast(ray.Origin) then
                    -- Get proper origin (same as Arsenal uses)
                    local character = LocalPlayer.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if hrp and humanoid then
                            local origin = hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0)
                            local direction = CurrentTarget.Position - origin
                            args[1] = Ray.new(origin, direction)
                            return oldNamecall(self, unpack(args))
                        end
                    end
                end
            end
        end
    end
    
    -- ============================================
    -- PROJECTILE SILENT AIM
    -- Intercept CreateProjectile remote
    -- Arsonia hooks: Events.CreateProjectile FireServer
    -- Args: "CreateProjectile", playerName, projType, speed, targetPos, originCFrame
    -- We modify targetPos (arg d/4th) and originCFrame (arg e/5th)
    -- ============================================
    
    if method == "FireServer" then
        if typeof(self) == "Instance" and self:IsA("RemoteEvent") then
            if ShouldRedirect() then
                local remoteName = self.Name
                
                -- Check if first arg identifies the action
                if typeof(args[1]) == "string" then
                    local action = args[1]
                    
                    -- CreateProjectile: redirect projectile direction
                    if action == "CreateProjectile" then
                        -- args: action, projType(?), speed(?), targetPos, originCFrame
                        -- Find Vector3 and CFrame args and redirect them
                        local character = LocalPlayer.Character
                        if character then
                            local hrp = character:FindFirstChild("HumanoidRootPart")
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if hrp and humanoid then
                                for i = 2, #args do
                                    if typeof(args[i]) == "Vector3" then
                                        -- This is the target position
                                        args[i] = CurrentTarget.Position
                                    elseif typeof(args[i]) == "CFrame" then
                                        -- This is the origin CFrame
                                        args[i] = CFrame.new(hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0))
                                    end
                                end
                                return oldNamecall(self, unpack(args))
                            end
                        end
                    end
                    
                    -- ControlTurn: optionally sync server-side rotation
                    -- args: "ControlTurn", pitch, lookVector
                    -- This makes your character face the target on server
                    if action == "ControlTurn" and CurrentTarget and CurrentTarget.Parent then
                        local character = LocalPlayer.Character
                        if character then
                            local head = character:FindFirstChild("Head")
                            if head then
                                local angles = Vector3.new(
                                    CFrame.new(head.Position, CurrentTarget.Position):ToEulerAnglesYXZ()
                                )
                                -- Modify pitch (args[2]) to face target
                                args[2] = angles.X
                                -- Don't modify lookVector (args[3]) to avoid obvious detection
                                return oldNamecall(self, unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- ============================================
    -- ALSO CATCH: FindPartOnRay, Raycast
    -- Some Arsenal code paths might use these
    -- ============================================
    
    if self == Workspace or self == workspace then
        if ShouldRedirect() then
            if method == "FindPartOnRay" then
                local ray = args[1]
                if typeof(ray) == "Ray" and IsWeaponRaycast(ray.Origin) then
                    local character = LocalPlayer.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if hrp and humanoid then
                            local origin = hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0)
                            args[1] = Ray.new(origin, CurrentTarget.Position - origin)
                            return oldNamecall(self, unpack(args))
                        end
                    end
                end
            end
            
            if method == "FindPartOnRayWithWhitelist" then
                local ray = args[1]
                if typeof(ray) == "Ray" and IsWeaponRaycast(ray.Origin) then
                    local character = LocalPlayer.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if hrp and humanoid then
                            local origin = hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0)
                            args[1] = Ray.new(origin, CurrentTarget.Position - origin)
                            return oldNamecall(self, unpack(args))
                        end
                    end
                end
            end
            
            if method == "Raycast" then
                local origin = args[1]
                local direction = args[2]
                if typeof(origin) == "Vector3" and typeof(direction) == "Vector3" then
                    if IsWeaponRaycast(origin) then
                        args[2] = (CurrentTarget.Position - origin).Unit * direction.Magnitude
                        return oldNamecall(self, unpack(args))
                    end
                end
            end
        end
    end
    
    return oldNamecall(self, ...)
end))

-- ============================================
-- METHOD 2: HOOK CreateProjectile FUNCTION
-- Arsonia hooks this directly for projectile weapons
-- ReplicatedStorage.Modules.ClientFunctions.CreateProjectile
-- ============================================

local projectileHooked = false

task.spawn(function()
    task.wait(3) -- Wait for game to load
    
    pcall(function()
        local ClientFunctions = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("ClientFunctions"))
        if ClientFunctions and ClientFunctions.CreateProjectile then
            local originalCreateProjectile = ClientFunctions.CreateProjectile
            ClientFunctions.CreateProjectile = function(playerName, projectileType, speed, targetPos, originCFrame, ...)
                if ShouldRedirect() then
                    if playerName == LocalPlayer.Name then
                        local character = LocalPlayer.Character
                        if character then
                            local hrp = character:FindFirstChild("HumanoidRootPart")
                            local humanoid = character:FindFirstChildOfClass("Humanoid")
                            if hrp and humanoid then
                                targetPos = CurrentTarget.Position
                                originCFrame = CFrame.new(hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0))
                                
                                -- For Bow/Arrow: fire HitPart directly (Arsonia method)
                                if projectileType == "Arrow" then
                                    pcall(function()
                                        local events = ReplicatedStorage:FindFirstChild("Events")
                                        if events then
                                            local hitPart = events:FindFirstChild("HitPart")
                                            if hitPart then
                                                -- Direct hit registration for arrows
                                                local hitPos = CurrentTarget.Position + Vector3.new(math.random(), math.random(), math.random())
                                                -- Note: We don't have the Hitparter format string
                                                -- So we just redirect the projectile instead
                                            end
                                        end
                                    end)
                                end
                            end
                        end
                    end
                end
                return originalCreateProjectile(playerName, projectileType, speed, targetPos, originCFrame, ...)
            end
            projectileHooked = true
        end
    end)
end)

-- ============================================
-- METHOD 3: HOOK SPREAD CALCULATION
-- Arsonia hooks ReplicatedStorage.Modules.Spread.calcspread
-- Setting spread to 0 makes bullets go exactly where aimed
-- This complements silent aim for perfect accuracy
-- ============================================

local spreadHooked = false

task.spawn(function()
    task.wait(3)
    
    pcall(function()
        local SpreadModule = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Spread"))
        if SpreadModule and SpreadModule.calcspread then
            local originalCalcSpread = SpreadModule.calcspread
            SpreadModule.calcspread = function(spreadAmount, ...)
                if Config.Silent.Enabled and Config.Silent.Active and CurrentTarget then
                    -- Remove spread when silent aim is active
                    spreadAmount = 0
                end
                return originalCalcSpread(spreadAmount, ...)
            end
            spreadHooked = true
        end
    end)
end)

-- ============================================
-- METHOD 4: HOOK FLAME/SPECIAL WEAPONS
-- Arsonia hooks the flame function for flamethrower-type weapons
-- getsenv(Client).flamemoment.doflame
-- ============================================

local flameHooked = false

task.spawn(function()
    task.wait(5)
    
    pcall(function()
        local clientScript = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("GUI"):WaitForChild("Client")
        if clientScript then
            local env = getsenv(clientScript)
            if env and env.flamemoment and env.flamemoment.doflame then
                local originalDoFlame = env.flamemoment.doflame
                env.flamemoment.doflame = function(playerName, direction, ...)
                    if ShouldRedirect() then
                        if playerName == LocalPlayer.Name then
                            local character = LocalPlayer.Character
                            if character then
                                local hrp = character:FindFirstChild("HumanoidRootPart")
                                local humanoid = character:FindFirstChildOfClass("Humanoid")
                                if hrp and humanoid then
                                    local origin = hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0)
                                    direction = CFrame.new(origin, CurrentTarget.Position)
                                end
                            end
                        end
                    end
                    return originalDoFlame(playerName, direction, ...)
                end
                flameHooked = true
            end
        end
    end)
end)

-- ============================================
-- TARGET UPDATE
-- ============================================

RunService.Heartbeat:Connect(function()
    Camera = Workspace.CurrentCamera
    if Config.Silent.Enabled and Config.Silent.Active then
        CurrentTarget = FindTarget()
    else
        CurrentTarget = nil
    end
end)

-- ============================================
-- CLEANUP
-- ============================================

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    Camera = Workspace.CurrentCamera
    CurrentTarget = nil
    
    -- Re-hook flame function on respawn
    task.spawn(function()
        task.wait(3)
        pcall(function()
            local clientScript = LocalPlayer.PlayerGui:FindFirstChild("GUI")
            if clientScript then
                clientScript = clientScript:FindFirstChild("Client")
                if clientScript then
                    local env = getsenv(clientScript)
                    if env and env.flamemoment and env.flamemoment.doflame and not flameHooked then
                        local originalDoFlame = env.flamemoment.doflame
                        env.flamemoment.doflame = function(playerName, direction, ...)
                            if ShouldRedirect() then
                                if playerName == LocalPlayer.Name then
                                    local character = LocalPlayer.Character
                                    if character then
                                        local hrp = character:FindFirstChild("HumanoidRootPart")
                                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                                        if hrp and humanoid then
                                            local origin = hrp.Position + Vector3.new(0, 1.5 + humanoid.CameraOffset.Y, 0)
                                            direction = CFrame.new(origin, CurrentTarget.Position)
                                        end
                                    end
                                end
                            end
                            return originalDoFlame(playerName, direction, ...)
                        end
                    end
                end
            end
        end)
    end)
end)

-- ============================================
-- SIGNAL
-- ============================================
getgenv().AX_ArsenalLoaded = true

print("  ✅ ARSENAL MODULE v7 loaded (Arsonia Method)")
print("  ✅ __namecall: FindPartOnRayWithIgnoreList hooked")
print("  ✅ __namecall: CreateProjectile remote hooked")
print("  ✅ __namecall: ControlTurn sync active")
print("  ✅ CreateProjectile function: " .. tostring(projectileHooked))
print("  ✅ Spread removal: " .. tostring(spreadHooked))
print("  ✅ Flame redirect: " .. tostring(flameHooked))
print("  ✅ Weapon raycast identification: Camera/HRP origin check")
